# 创建型模式

* 抽象工厂模式(Abstract Factory)：提供了一系列相关或相互依赖对象的接口，无需指定它们具体的实现类
• java.util.Calendar#getInstance()
• java.util.Arrays#asList()
• java.util.ResourceBundle#getBundle()
• java.net.URL#openConnection()
• java.sql.DriverManager#getConnection()
• java.sql.Connection#createStatement()
• java.sql.Statement#executeQuery()
• java.text.NumberFormat#getInstance()
• java.lang.management.ManagementFactory (所有getXXX()方法)
• java.nio.charset.Charset#forName()
• javax.xml.parsers.DocumentBuilderFactory#newInstance()
• javax.xml.transform.TransformerFactory#newInstance()
• javax.xml.xpath.XPathFactory#newInstance()
* 工厂方法模式(Factory Method)：定义**一个**用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
• java.lang.Object#toString() (在其子类中可以覆盖该方法)
• java.lang.Class#newInstance()
• java.lang.Integer#valueOf(String) (Boolean, Byte, Character,Short, Long, Float 和 Double与之类似)
• java.lang.Class#forName()
• java.lang.reflect.Array#newInstance()
• java.lang.reflect.Constructor#newInstance()
* 创建者模式(Builder)：将一个复杂对象的创建和表示相分离，使得同样的创建过程可以创建不同的表示
• java.lang.StringBuilder#append()
• java.lang.StringBuffer#append()
• java.nio.ByteBuffer#put() (CharBuffer, ShortBuffer, IntBuffer,LongBuffer, FloatBuffer 和DoubleBuffer与之类似)
• javax.swing.GroupLayout.Group#addComponent()
• java.sql.PreparedStatement
• java.lang.Appendable的所有实现类

* 单例模式(Singleton)：保证一个类只要一个实例
• java.lang.Runtime#getRuntime()
• java.awt.Desktop#getDesktop()

* 原型模式(Prototype)
• java.lang.Object#clone() (支持浅克隆的类必须实现java.lang.Cloneable接口)





工厂模式按照抽象程度不同可以分为三种：简单工厂（也叫静态工厂模式）、抽象工厂、工厂方法。其中简单工厂并不是23种设计模式之一。 http://ichennan.com/2016/08/09/DesignPattern.html


简单工厂很粗暴，用参数控制创建的东西是什么：传入1造火箭、传入2煮面条、传入3种土豆，简直无所不能，所以简单工厂还有一个一个别名：上帝类。简单粗暴也算是优点吧。


缺点也很明显，太简单粗暴了。任何东西都能被得到，负担太中，当需要的产品很多的时候，工厂方法的代码量可能会很庞大。另外，在遵循开闭原则的条件下，简单工厂对于增加新产品无能为力。因为增加新产品只能靠修改工厂方法来实现。


而工厂方法能解决这个问题，它提供了**一个**能生产产品的接口，至于生产的产品具体是什么，需要子类自己实现。工厂方法很好解决了上面的问题，但是缺点也很明显，就是功能太单一了，如果需要n种产品，那么就需要n个工厂的实现类。

而抽象工厂是针对“产品簇”提出的。工厂方法是一种极端的抽象工厂（只生产一种产品的抽象工厂模式）。
