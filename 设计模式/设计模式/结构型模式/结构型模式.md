# 结构型模式

* 适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口。
•java.util.Arrays#asList()
•javax.swing.JTable(TableModel)
•java.io.InputStreamReader(InputStream)
•java.io.OutputStreamWriter(OutputStream)
•javax.xml.bind.annotation.adapters.XmlAdapter#marshal()
•javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()

* 桥接模式(Bridge)：将抽象部分与实现部分分离，使它们都可以独立的变化。
• AWT (提供了抽象层映射于实际的操作系统)
•JDBC

* 组合模式(Composite)
•javax.swing.JComponent#add(Component)
•java.awt.Container#add(Component)
•java.util.Map#putAll(Map)
•java.util.List#addAll(Collection)
•java.util.Set#addAll(Collection)

* 装饰器模式(Decorator)：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。
•java.io.BufferedInputStream(InputStream)
•java.io.DataInputStream(InputStream)
•java.io.BufferedOutputStream(OutputStream)
•java.util.zip.ZipOutputStream(OutputStream)
•java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()
* 外观模式(Facade)
•java.lang.Class
•javax.faces.webapp.FacesServlet

* 享元模式(Flyweight)
•java.lang.Integer#valueOf(int)
•java.lang.Boolean#valueOf(boolean)
• java.lang.Byte#valueOf(byte)
•java.lang.Character#valueOf(char)

* 代理模式(Proxy)
• java.lang.reflect.Proxy
•java.rmi.*
