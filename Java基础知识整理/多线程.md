# 多线程

这个专题真的好神圣，因为多线程在我心中就是一座永远不能登高的高峰。因为从来没有弄明白过，sad。


## 进程和线程

在正式学习之前，我们需要补一下操作系统的相关知识。
首先明确"CPU"、“多核处理器”、"多处理器"这些名词的关系。

首先"CPU"，中央处理器，是一块超大规模的集成电路，是一条计算机的运算核心和控制核心。通常家用电脑就一个CPU，一些服务器和图形工作站都有2个、4个或者更多的CPU，大型服务器或者超级电脑有多少个都行。

“多核”指的是什么呢?多核处理器是指在一枚处理器中集成两个或者多个完整的计算引擎（内核）。在运算效果上等同于多个“单核CPU”。”多核处理器“和“多处理器”是完全不同的概念。至于单个“多核处理器”和多个“单核处理器”之间的区别和优劣，网上讨论很多了。不再赘述了。

> 看知乎上有个形象的总结：简单来说就是一家子人干活和几家人干活的区别，假设人数一样，一家人开个门就能商量，几家人要过街才能商量。

> 多CPU的方式称为分布式计算！

进程的概念有一个背景：多道程序设计技术。

在这个技术引进之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。

而多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。

注意这里的描述“相互穿插的运行”，这是什么意思？一个CPU在同一时间只能处理一项任务，那么如何选择处理哪项任务呢，这就是所谓的任务调度。大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行。由于CPU的效率非常高，所以每个任务没有隔多久就又被执行了，从我们的感官来看，就好像每个任务都没有被耽误，多个任务都在**并发(concurrent)**执行。

这里又有一个概念：**并发(concurrent)**，和它经常放在一起比较的另外一个词是：**并行(parallel)**。两者有什么区别和联系呢？

Erlang 之父 Joe Armstrong用下面这张图解释了concurrent和parallel的区别：

![concurrent&paralle](http://ovn0i3kdg.bkt.clouddn.com/concurrent&parallel.jpg?imageView/2/w/400)


可以看到，两队人交替使用同一个咖啡机，是并发（concurrent）；两队人同时使用两个咖啡机，是并行（parallel）；一队人使用一台咖啡机，是串行（serialization）。

> 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
> 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。

话题扯远了，回到正题。既然多道程序设计允许多个程序同时进入内存并发并行，那么就要每个程序都分配程序计数器了，那么如何描述、刻画这样执行的程序呢？因此引入了“进程”。下面进程的一种定义：

> 进程是具有独立功能的程序关于某个**数据集合**上的一次**运行活动**，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。

注意定义里面的几个关键词，"运行活动"说明进程是程序的一次执行过程，如果程序要执行两次甚至多次，那么需要两次甚至多次进程。“数据集合”是说系统资源（如内存、文件）以进程为单位分配，操作系统为每个进程分配了独立的地址空间，通过“调度”把控制权交给进程。

有了进程的概念，那么为什么还要引入线程呢？有这些考虑：
1. 应用的需要。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。
2. 开销的考虑。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件）
3. 性能的考虑。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。

线程有以下特点：
1. 有标识符ID
2. 有状态及状态转换，所以需要提供一些状态转换操作
3. 不运行时需要保存上下文环境，所以需要程序计数器等寄存器
4. 有自己的栈和栈指针
5. 共享所在进程的地址空间和其它资源

> 线程和进程更通俗易懂的解释可以参考 https://www.zhihu.com/question/25532384 ,讲的很明白易懂了。

线程和进程之间的区别：

| 比较项     | 进程     | 线程|
| :------------- | :------------- |: --- |
| 定义| 程序在某个数据集合上的一次运行活动     | 线程是进程中的一个执行路径。|
|角色   |  系统资源分配的单位 | CPU调度的单位  |
|资源共享   |进程之间不能共享资源。一个进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成   | 线程共享所在进程的地址空间和其它资源。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈  |
|独立性   |  有自己独立的地址空间 |  没有独立空间，线程必须依赖于进程而存在。 |
|开销   |   切换的开销较大|相对较小   |


## 多线程和多核
前面提到的"同一时间只有一个任务在执行"，这句话在当下看来是不对的，至少是不全面的。这句话说的是单个单核处理器的情况，但是现在大都是多核处理器，这时候会怎么进行进程和线程的处理呢？

**多核(心)处理器**是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个**内核线程**。

**内核线程（Kernel Thread， KLT）**就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。

现在的电脑一般是双核四线程、四核八线程，是采用**超线程技术**将一个**物理处理核心**模拟成**两个逻辑处理核心**，对应**两个内核线程**，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。

那么，四核八线程处理器是不是能让八线程并行呢？
不是！CPU中的线程与操作系统中的线程不是一个概念，CPU中的操作是以时序为准的，它类似一个流水线操作，8线程指同时有8条指令被执行，但这所谓的执行在时序上是有差别的。由于同时处理多条指令从而提高了CPU的处理速度。但对PC系统而言它的处理还是一个分时系统，每次只能完成一个任务片段。而"四核八线程"是指四个物理核心，八个逻辑核心，有几核心就有多少个真实线程，多出来的都是假的。

## 线程的同步与互斥

### 竞争状态和临界区
在同一个程序中运行多个线程本身不会导致问题，问题在于如果多个线程访问了同一个资源，如同一内存区(变量、数组或对象)，系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了**写操作**时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。写操作比如下面这个例子：
```java
public Class Counter{
  protected long count = 0;
  public void add(long value){
    this.count += value;
  }
}
```
假设有A和B两个线程同时执行**同一个Counter对象**的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：
1. 从内存获取 this.count 的值放到寄存器
2. 将寄存器中的值增加value
3. 将寄存器中的值写回内存

观察线程A和B交错执行会发生什么：
 * this.count = 0;
 * A:	读取 this.count 到一个寄存器 (0)
 * B:	读取 this.count 到一个寄存器 (0)
 * B: 	将寄存器的值加2
 * B:	回写寄存器值(2)到内存. this.count 现在等于 2
 * A:	将寄存器的值加3
 * A:	回写寄存器值(3)到内存. this.count 现在等于 3

两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在**竞态条件**。导致竞态条件发生的代码区称作**临界区**。

上例中要怎么做改变才能得到预期的结果5呢？很简单，只允许每次只有一个线程能执行add方法，比如A首先执行了add方法，在A没执行完之前，B不能用，等A完成了B才能进行add操作。道理都懂，但是怎么才能保证每次只有一个线程在执行呢？想想，给这个方法加一个标识就行了，A执行的时候，拿到这个标识，就表示：诶这个方法我先用了，其他人先等着。等到A执行完之后，释放这个标识，就表示：我用完了，其他人自便。那这个标识是什么呢？我们给这个标识起个很形象的名字，叫做“锁”。

> 以前学习操作系统的时候，关于多线程的互斥有过很多的解决方法，其中两个重要的概念就是“互斥量”和“信号量”，两者有什么联系和区别呢？
> 互斥量和信号量都是操作系统中为并发编程设计的基本概念。两者的区别在于，对于同一个资源，互斥量只有0和1的概念，而信号量远不止于此。信号量可以使资源同时被多个线程访问，但是互斥锁只能是线程同时被一个线程访问。另外一个不同点是，互斥量用于线程的互斥，而信号量用于线程的同步。

如果实现这个“锁”，就是问题的关键所在，这就是Java的"锁机制"。

> 互斥和同步不是一个概念，这段视频讲的很清楚：http://www.imooc.com/video/5118

## 锁机制
### 一些小背景
首先需要明确的是，需要对一个对象的哪些资源进行协调。有JVM基本数据分区概念之后知道，JVM只要对其中两种数据进行监视：
1. 保存在堆中的实例变量
2. 保存在方法区的类变量
> 方法区和堆是线程不隔离的，所以需要进行线程同步，而保存在栈中的数据是不需要进行保护的，因为这个区域是线程隔离的。


### synchronized关键字
一个很重要的常识是：**Java中每一个对象都有一个内置锁**。这是Java语言层实现的线程机制，不同于JDK 5中的`Lock`，不用显式地释放。可以使用`synchronized`关键字来获取这个内置锁。`synchronized`关键字可以修饰方法和代码块，分别叫做“同步方法”和“同步代码块”。

#### 同步方法
用`synchronized`关键字修饰的方法，称为“同步方法”。由于每个对象都有内置锁，所以当`synchronized`关键字修饰方法时，内置锁会保护整个方法在同一时间只能被一个线程访问。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。对上面的例子来说，可以写成这样：
```java
public Class Counter{
  protected long count = 0;
  public synchronized void add(long value){
    this.count += value;
  }
}
```
特别的是，如果`synchronized`修饰的是静态方法，那么将会锁住整个类。

但是同步方法会影响效率，最好不要使用同步方法而改用同步代码块。

#### 同步代码块
用`synchronized`关键字修饰的代码块，称为“同步代码块”，这时候，内置锁保护的区域是代码块。例如：
```java
public Class Counter{
  protected long count = 0;
  public void add(long value){
    synchronized(this){
      this.count += value;
    }
  }
}
```
由于add方法只有一条语句，这条语句放到了同步代码块中，所以它的效果和上面同步方法的效果是一样的。


同步方法和同步代码块能够保证同一时刻最多只有一个线程执行方法或代码块，下面是几个测试程序：
* 当两个并发线程访问**同一个对象object**中的这个**synchronized(this)**同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
```java
public class Thread1 implements Runnable {  
     public void run() {  
          synchronized(this) {  
               for (int i = 0; i < 5; i++) {  
                    System.out.println(Thread.currentThread().getName() + " synchronized loop " + i);  
               }  
          }  
     }  
     public static void main(String[] args) {  
          Thread1 t1 = new Thread1();  
          Thread ta = new Thread(t1, "A");  
          Thread tb = new Thread(t1, "B");  
          ta.start();  
          tb.start();  
     }
}
```
执行结果是：
```java
A synchronized loop 0  
A synchronized loop 1  
A synchronized loop 2  
A synchronized loop 3  
A synchronized loop 4  
B synchronized loop 0  
B synchronized loop 1  
B synchronized loop 2  
B synchronized loop 3  
B synchronized loop 4
```
ta线程首先执行，两者都执行了同一个对象的run方法，而run方法中的代码都放到了同步块中，所以ta首先拿到了对象t1的锁，此时tb线程只能等待ta执行完毕再执行。

* 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

  ```java
  public class ThreadTest {
      public void m1(){
          synchronized (this){
              int i = 5;
              while (i-- > 0){
                  System.out.println(Thread.currentThread().getName() + " : " + i);
                  try{
                      Thread.sleep(500);
                  }catch (InterruptedException e){

                  }
              }
          }
      }

      public void  m2(){
          int i = 5;
          while( i-- > 0) {
              System.out.println(Thread.currentThread().getName() + " : " + i);
              try {
                  Thread.sleep(500);
              } catch (InterruptedException ie) {
              }
          }
      }

      public static void main(String[] args) throws Exception{
              ThreadTest test = new ThreadTest();
              Thread t1 = new Thread(new Runnable() {
                  @Override
                  public void run() {
                      test.m1();
                  }
              });
              Thread t2 = new Thread(new Runnable() {
                  @Override
                  public void run() {
                      test.m2();
                  }
              });

              t1.start();
              t2.start();
      }

  }
  ```
执行结果是：

  ```java
  Thread-1 : 4
  Thread-0 : 4
  Thread-0 : 3
  Thread-1 : 3
  Thread-0 : 2
  Thread-1 : 2
  Thread-1 : 1
  Thread-0 : 1
  Thread-1 : 0
  Thread-0 : 0
  ```

* **当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。**
将上例中的m2方法改成下面这种形式：

  ```java
  public void  m2(){
     synchronized (this){
         int i = 5;
         while( i-- > 0) {
             System.out.println(Thread.currentThread().getName() + " : " + i);
             try {
                 Thread.sleep(500);
             } catch (InterruptedException ie) {
             }
         }
     }

  }
  ```
  打印的结果是：
  ```java
  Thread-0 : 4
  Thread-0 : 3
  Thread-0 : 2
  Thread-0 : 1
  Thread-0 : 0
  Thread-1 : 4
  Thread-1 : 3
  Thread-1 : 2
  Thread-1 : 1
  Thread-1 : 0
  ```
也就是当一个对象的锁被其中一个线程获得的时候，其他的线程只能访问该对象的其他非同步方法，不能访问其他同步方法。

* 以上规则对其他对象锁也同样适用
注意到同步方法块`synchronized`有一个参数（同步方法的默认参数是this），这个参数代表什么意思呢？ 这个参数表示"锁"加到谁的身上。`synchronized(this)`表示线程锁加在被调用对象本身上，因此，同一时刻，该对象只能有一个synchronized方法会被一个线程调用，其它线程调用的synchronized方法都会阻塞以等待锁的释放。`synchronized(obj)`表示的线程的锁加到了`obj`这个对象上（也有可能是类上，比如`synchronized(OtherClass.class)`这种写法。），表示锁住的是另一个对象。

在同步方法块中用括号括起来的对象叫做“监视器对象”。

> 对于这一点，http://www.cnblogs.com/devinzhang/archive/2011/12/14/2287675.html 这篇博文中”房间和钥匙”的比喻很生动了，可以参考加深理解。

> 注意理解"`synchronized`是线程级的，而不是方法级"这句话的意思。如果两个方法A和B都对同一个对象加了synchronized方法，并且在A方法中调用了B方法。这时候有线程1调用A方法，那么执行到调用B方法的时候会等着释放锁么？不会。A和B都在一个线程里，线程1已经获得了锁，所以会畅通无阻地执行下去。

`synchronized(this)`适用于方法彼此间都会修改对象的某个状态，如果在某个对象的两个synchronized彼此不会共享任何资源，比如A中修改资源r1,B中修改资源r2,则在A和B中同时加上`synchronized(this)`会引起不必要的性能开销，因为调用A和B的线程不必要同步，此时简单的办法就是通过为A和B加不同的锁：
```java
Object lock1 = new Object();
Object lock2 = new Object();
public void A(){
   synchronized(lock1){
 }
}
public void B(){
   synchronized(lock2){
  }
}
```
这样调用A和调用B的两个进程不会同步，只有都调用A或者都调用B的线程间需要同步。

之前提到“对象锁”和“类锁”的概念，如果`synchronized`同时修饰静态和非静态方法，会有什么结果呢？看下面这段测试程序：
```java
public class ThreadTest {
    public synchronized  void m1(){
            int i = 5;
            while (i-- > 0){
                System.out.println(Thread.currentThread().getName() + " : " + i);
                try{
                    Thread.sleep(500);
                }catch (InterruptedException e){

                }
            }
    }

    public synchronized static void  m2(){
            int i = 5;
            while( i-- > 0) {
                System.out.println(Thread.currentThread().getName() + " : " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ie) {
                }
            }
    }

    public static void main(String[] args) throws Exception{
            ThreadTest test = new ThreadTest();
            Thread t1 = new Thread(new Runnable() {
                @Override
                public void run() {
                    test.m1();
                }
            });
            Thread t2 = new Thread(new Runnable() {
                @Override
                public void run() {
                    ThreadTest.m2();
                }
            });

            t1.start();
            t2.start();
    }
}
```
最后的输出结果是：
```java
Thread-0 : 4
Thread-1 : 4
Thread-0 : 3
Thread-1 : 3
Thread-1 : 2
Thread-0 : 2
Thread-1 : 1
Thread-0 : 1
Thread-0 : 0
Thread-1 : 0
```
可以看到两个线程是交替进行了，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。

有了上面的解释，来看看下面这段程序会输出什么？
```java
public class ThreadTest {
    class Inner{
        public void m1(){
            int i = 5;
            while (i-- > 0){
                System.out.println(Thread.currentThread().getName() + " : " + i);
                try{
                    Thread.sleep(500);
                }catch (InterruptedException e){

                }
            }
        }
        public void  m2(){
            int i = 5;
            while( i-- > 0) {
                System.out.println(Thread.currentThread().getName() + " : " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ie) {
                }
            }
        }

    }
    private void m1(Inner inner){
        synchronized (inner){ //使用对象锁
            inner.m1();
        }
    }

    private void m2(Inner inner){
        inner.m2();
    }

    public static void main(String[] args) throws Exception{
        final ThreadTest test = new ThreadTest();
        final Inner inner = test.new Inner();

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                test.m1(inner);
            }
        }, "t1");
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                test.m2(inner);
            }
        }, "t2");

        t1.start();
        t2.start();
    }
}
```
尽管t1获得了inner对象的锁，但是t2访问的是同一个inner中的非同步部分。所以两个线程不会互相干扰。交替执行。但是如果ThreadTest中m2方法改成这样：
```java
private void m2(Inner inner){
   synchronized (inner){
       inner.m2();
   }
}
```
那么将会先执行t1，再执行t2。
如果main方法给成这样呢（在上例改变m2的基础上）？
```java
public static void main(String[] args) throws Exception{
    final ThreadTest test = new ThreadTest();
    final Inner inner1 = test.new Inner();
    final Inner inner2 = test.new Inner();


    Thread t1 = new Thread(new Runnable() {
        @Override
        public void run() {
            test.m1(inner1);
        }
    }, "t1");
    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            test.m2(inner2);
        }
    }, "t2");

    t1.start();
    t2.start();
}
```
当然是两个线程交替执行了，因为引用的不是同一个Inner类实例。

总结一下：
1. 线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。
2. 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。
3. 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。
4. 对于同步，要时刻清醒在哪个对象上同步，这是关键。

#### 实现原理
前面说道，`synchronized`取得的是内置锁，那么背后到底是什么原理呢？其实就是操作系统中“监视器”的概念。

> 关于监视器的具体说明，可以参考[监视器–JAVA同步基本概念](http://ifeve.com/monitors-java-synchronization-mechanism/)

在SUN的HopSpot JVM中，`synchronized`锁又叫做"监视器锁"。在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的。对于对象来说，相关联的监视器保护对象的实例变量。对于类来说，相关联的监视器保护类的类变量。换句话说，如果一个对象没有实例变量，或者一个类没有类变量，相关联的监视器就什么都不监视。

为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。

但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）

类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。

一个线程可以多次对同一个对象上锁。对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。

而`syncrhoized(lock)`加锁时，用到的其实只是`lock`对象内置的`monitor`而已，假设有代码块
```java
syncrhoized（Object lock）{
  同步代码...;
}
```
它在字节码文件中被编译为：
```java
monitorenter;//获取monitor许可证，进入同步块
同步代码...
monitorexit;//离开同步块后，释放monitor许可证
```
当多个线程访问这个对象的时候，对象监视器会将这些请求存储在不同的容器中：
1. **Contention List**：竞争队列，所有请求锁的线程首先被放在这个竞争队列中
2. **Entry List**：Contention List中那些有资格成为候选资源的线程被移动到Entry List中
3. **Wait Set**：那些调用wait方法被阻塞的线程被放置在这里
4. **OnDeck**：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck
5. **Owner**：当前已经获取到所资源的线程被称为Owner
6. **!Owner**：当前释放锁的线程
他们之间的关系如下图所示：

![monitor](http://ovn0i3kdg.bkt.clouddn.com/monitor.png)

他们协调工作的实现细节可以参见原博客http://www.cnblogs.com/longshiyVip/p/5213771.html

#### 原子性和可见性
把代码块声明为`synchronized`，有两个重要后果，通常是指该代码具有原子性（`automicity`）和可见性（`visibility`）。
* `原子性`：原子性意味着某个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor Object保护。从而防止多个线程在更新共享状态时相互冲突。
* `可见性`：可见性要对付内存缓存和编译器优化的各种反常行为。它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。

原子性比较好理解，可见性非常重要。如果没有同步机制提供这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。如何实现可见性的呢？当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。同样，在对象释放锁之前，它会刷新其高速缓存。强制使已做的任何更改都出现在主内存中。这样，可以保证在同一个锁上同步的两个线程看到在synchronized块内修改的变量的相同值。

Java中有一个修饰符`volatile`，这个修饰符只能保证可见性，不能保证原子性。

#### 死锁

死锁是多线程开发中比较常见的一个问题。若有多个线程访问多个资源时，相互之间存在竞争，就容易出现死锁。下面就是一个死锁的示例，当一个线程等待另一个线程持有的锁时，而另一个线程也在等待该线程锁持有的锁，这时候两个线程都会处于阻塞状态，程序便出现死锁。
```Java
class Thread01 extends Thread{
    private Object resource01;
    private Object resource02;
    public Thread01(Object resource01, Object resource02) {
        this.resource01 = resource01;
        this.resource02 = resource02;
    }
    @Override
    public void run() {
        synchronized(resource01){
            System.out.println("Thread01 locked resource01");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (resource02) {
                System.out.println("Thread01 locked resource02");
            }
        }
    }
}

class Thread02 extends Thread{
    private Object resource01;
    private Object resource02;
    public Thread02(Object resource01, Object resource02) {
        this.resource01 = resource01;
        this.resource02 = resource02;

    }
    @Override
    public void run() {
        synchronized(resource02){
            System.out.println("Thread02 locked resource02");
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (resource01) {
                System.out.println("Thread02 locked resource01");
            }
        }
    }
}
public class DeadLock {

    public static void main(String[] args) {
        final Object resource01="resource01";
        final Object resource02="resource02";
        Thread01 thread01=new Thread01(resource01, resource02);
        Thread02 thread02=new Thread02(resource01, resource02);
        thread01.start();
        thread02.start();
    }
}
```
执行结果:
```java
Thread02 locked resource02
Thread01 locked resource01
```

执行上面的程序就会一直等待下去，出现死锁。当线程Thread01获得resource01的锁后，等待500ms，然后尝试获取resource02的锁，但是此时resouce02锁已经被Thread02持有，同样Thread02也等待了500ms尝试获取resouce01锁，但是该所已经被Thread01持有，这样两个线程都在等待对方所有的资源，造成了死锁


#### 锁重入
关键字`synchronized`具有锁重入功能。锁重入的意思是：当一个线程已经持有一个对象锁之后，再次请求该对象锁是可以得到该对象的锁的。这种方式是必须的，否在在一个`synchronized`方法内部就没办法调用该对象的另一个`synchronized`方法了。

锁重入的原理是通过为每个锁关联一个计数器和一个占有它的线程。当计数器为0的时候，表示锁是未被占有的。线程请求一个被未被占有的锁时，JVM会记录锁的占有者，并为计数器设置为1.如果同一个线程再次请求该锁，计数器会递增，每次占有的线程退出同步代码块的时候计数器会递减，直至减为0的时锁才会被释放。

**在声明一个对象作为锁的时候要注意字符串类型锁对象，因为字符串有一个常量池，如果不同的线程持有的锁是具有相同字符的字符串锁时，两个锁实际上是同一个锁。**
#### 限制
1. 它无法中断一个正在等候获得锁的线程。
2. 无法通过投票得到锁，如果不想等下去，也就没法得到锁。
3. 同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行，多数情况下，这没问题（而且与异常处理交互的很好），但是，确实存在一些非块结构的锁更合适的情况。


### Lock
`Lock`是JDK5开始，包`java.util.concurrent.locks`中的一个接口。`Lock`提供了比使用`synchronized`方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题。注意到，这里`locks`用了复数，是因为这个包中有很多`Lock`的实现类，常用的有`ReentrantLock`、`ReadWriteLock`（实现类`ReentrantReadWriteLock`），其实现都依赖`java.util.concurrent.AbstractQueuedSynchronizer`类（简称`AQS`）。

### Condition


## 线程的创建方式
### 继承Thread类

### 实现Runnable接口

### 应用程序可以使用Executor框架来创建线程池

### 实现Callable接口

## 线程组和线程池
线程组和线程池都对线程进行了管理，也可以对线程进行控制（休眠，唤醒，结束，创建，中断（暂停），但是不一定都包含这些操作），两者有什么联系和区别么？

两者并没有什么从属联系，虽然都是对线程进行管理，但是立足点是不一样的。

线程组存在的意义，首要原因是安全。Java默认创建的线程都是属于系统线程组，而同一个线程组的线程是可以相互修改对方的数据的。但如果在不同的线程组中，那么就不能“跨线程组”修改数据，可以从一定程度上保证数据安全。

线程池存在的意义，首要作用是效率。线程的创建和结束都需要耗费一定的系统时间（特别是创建），不停创建和删除线程会浪费大量的时间。所以，在创建出一条线程并使其在执行完任务后不结束，而是使其进入休眠状态，在需要用时再唤醒，那么 就可以节省一定的时间。如果这样的线程比较多，那么就可以使用线程池来进行管理。保证效率。


## 线程的生命周期
当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。那么这些线程中同一时刻只能有一个是被执行的，其他的都在等待，这就有了“线程的生命周期”一说。

下面是一张完整的线程的生命周期图，这张图给我背下来！闭着眼睛都能画出来的程度！

![thread_life_cycle](http://ovn0i3kdg.bkt.clouddn.com/thread_lifecycle.jpeg)

线程一般有5种状态
1. 新建：就是新建了一个线程对象。
2. 就绪：即可运行状态，就是调用start()方法后，线程将进入一个线程池，等待系统分配资源，（注意不是说用start()方法后，线程就被执行的，他得等待获得资源），一旦得到CPU资源就能运行
3. 运行：就是系统给分配了资源（有的教材认为资源就是CPU的使用权），程序开始执行
4. 阻塞：由于某种原因，程序执行到某种程度时，放弃了资源的使用权，暂时停止运行。满足相应条件后，又变成可运行状态，这个由分为几种情况：
  1. 等待阻塞：运行的线程执行了wait()方法；
  2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用；
  3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
5. 结束：也叫死亡状态，就是程序执行完成了，或发生异常退出run()方法了。

与线程状态转化相关的一些方法：`wait`、`notify`、`notifyAll`、`yield`、`sleep`、`join`、`interrupt`。它们各自的用法和区别需要牢记在心。下面是一个总结：

| 方法 | 所属类、方法类别    | 说明 | 受影响的线程|状态转化| **锁处理**|  操作结果| 说明|
| :------------- | :------------- |
| wait      | Object类，实例方法     |调用该方法的当前线程将在该实例上等待一定时间，直到时间结束，或者由别的线程在该实例上唤醒|当前线程| 运行态 -> （等待）阻塞| 释放所持有的锁  | 当前线程由运行状态转变为阻塞状态，在某个对象上等待，直到等待时间结束或者由别的线程使用该对象的notify或者notifyAll方法唤醒，当前线程调用该方法后将释放锁|  |
|notify   | Object类，实例方法  | 调用某个实例notify方法，将唤醒所有在该实例上等待的线程   |  在该对象上wait的线程| （等待）阻塞  - > (同步)阻塞| 既没有锁的获得也没有锁的失去   | 当前线程调用某个对象的notify方法，将会唤醒所有在该对象上等待的线程，但是注意，唤醒线程并不等于获得锁，这些线程仍然处于阻塞状态，它们仍需要竞争锁，所以该过程没有释放锁也没有获得锁|   |  
|notifyAll  | Object类，实例方法  |调用某个实例的notifyAll方法，将唤醒所有在该实例上等待的线程  |  在该对象上wait的所有线程 |  (等待)阻塞 -> (同步)阻塞  | 既没有没有获得锁也没有锁的失去  |  当前线程调用某个对象的notifyAll方法，将会唤醒所有正在该对象省等待的线程，但是注意，唤醒线程并不等于获得锁，这些线程仍旧处于阻塞状态，它们仍旧需要竞争锁，所以该过程没有释放锁也没有获得锁|  |
|yield   | Thread类，实例方法  |  调用该方法的当前线程将自动放弃时间片，做出让步，回到就绪状态，但是注意，该线程本省不会释放任何资源，它只是给和自己具有相同优先级的、已经就绪的线程再一次选择的机会  | 当前线程   |  运行状态 -> 就绪状态  |  不会释放任何资源 | 当前线程从运行状态转为就绪状态，让和自己有相同优先级别的线程再一次竞争，不能保证比自己优先级高的一定会在下一次被选中， 也有可能是自己再一次重新进入运行状态 | 只是暂时回到了起跑点，不会释放任何资源   |
|sleep   |Thread类，静态方法   |调用该方法的当前线程将休眠，进入阻塞状态，不会释放任何资源 | 当前线程  |  运行状态 - > （其他）阻塞  |不会释放任何资源   | 当前线程进行休眠，不释放锁， 可可以使得任何优先级的线程得到优先执行的机会  |  实际上是调用了wait方法，当参数为0的时候表示无限等待，notify方法也可以唤醒sleep的线程，唤醒之后，将变为就绪状态。特别注意，该方法需要捕获`InterruptedException`异常|
|join   | Thread类，实例方法  | 当前方法A调用了其他线程B的该方法，那么原本并发的两个线程就变成了串行，A线程需要等到B线程执行完毕后才能继续执行  |当前线程   | 运行状态 -> (其他)阻塞   |  不释放任何资源|  并发过程将变成串行过程，谁主动调用，谁垫后|   |
|interrupt   |   |   |   |   |   |   |   |

## 线程死锁
## 线程分类
用户线程、守护线程

## 并发编程

### 同步器
JDK提供的用于并发编程的同步器：
参考
* [多核 CPU 和多个 CPU 有何区别？](https://www.zhihu.com/question/20998226)
* [多核与多个CPU啥区别](http://blog.csdn.net/hellochenlu/article/details/51507989)
* [编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程](http://blog.csdn.net/luoweifu/article/details/46595285)
* [多个处理器和多核处理器的区别](http://blog.csdn.net/kevin_yzlong/article/details/70196168)
* [进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
* [线程和进程的区别是什么？](https://www.zhihu.com/question/25532384)
* [我是一个线程](http://kb.cnblogs.com/page/542462/)
* [深入理解进程和线程](http://www.cnblogs.com/tiankong101/p/4229584.html)
* [Java中Wait、Sleep和Yield方法的区别](http://www.jianshu.com/p/25e959037eed)
* [Java线程状态转换](https://www.toutiao.com/i6368772681411592706/)
* [一张图让你看懂JAVA线程间的状态转换](https://my.oschina.net/mingdongcheng/blog/139263)
* [Java线程：线程的同步与锁](http://lavasoft.blog.51cto.com/62575/99155/)
* [Java 多线程（七）——线程组与线程池](http://blog.csdn.net/zen99t/article/details/50909099)
* [java中的互斥锁,信号量和多线程等待机制](http://blog.csdn.net/feifeiwendao/article/details/52212719)
* [Java并发编程——信号量与互斥量](http://www.jianshu.com/p/c71840db31d2)
* [Java线程：线程的同步与锁](http://lavasoft.blog.51cto.com/62575/99155/)
* [【Java线程】锁机制：synchronized、Lock、Condition](http://blog.csdn.net/vking_wang/article/details/9952063)
* [深入浅出Java并发包—锁机制(一)](http://www.cnblogs.com/longshiyVip/p/5213771.html)
* [监视器–JAVA同步基本概念](http://ifeve.com/monitors-java-synchronization-mechanism/)
