# 哈希散列

数据类型按照物理存储方式分为四类：顺序存储、链式存储、散列存储和索引存储。

数组实现顺序存储，能实现O(1)效率的存取，但是必须要求元素连续存储。链式存储不要求连续存储，但是存取的效率是O(n)，对于索引存储，需要额外的空间来保存数据和位置之间的索引关系，存取的效率是O(1)，那么有没有一种实现既省时，又省空间呢？有，这就是散列存储。

>数组本身就是一个散列表

散列，又叫做哈希，主要的思想就是根据节点的关键字能够直接计算出该节点的存储地址。这个过程叫做“散列”，而这种计算方式叫做“散列函数”，用h表示。存放记录的数组叫做散列表(Hash Table)，用HT表示。散列表中的一个位置称为一个槽（slot），散列表HT中的数目用变量M表示，槽从0到M-1标号。

散列的过程就是：根据码值，借助散列函数，计算得到槽的位置，如果产生了散列冲突（就是说计算得到的槽已经被人占了），那就要想办法解决冲突。

所以散列过程有以下三个重要的元素。
### 码值
码值最好能够唯一的标识一个元素。可以是数值，也可以是字符串或者其他类型。我们常常以哈希值作为码值输入，因为它的计算方式已经够复杂以至于能唯一标识一个个体了。不同的对象具有不同的哈希码的计算方法，比如`String`类（忘记的回去复习下），当然我们也可以自己改造，比如`HashMap`就是改造了`hashCode`方法。


#### 散列函数

从技术上来说，任何能把所有可能关键码值映射到散列表槽中的函数都是散列函数。下面是一些常用的散列函数
1. 平均取中方法
对于数值类型的码值（比如哈希码），计算码值的平方，然后取中间几位，散列到相应的位置。这样做是因为码值的大多数位或者所有位对结果都有贡献。比如基数是10的四位关键码，散列到长度为100的散列表中，例如码值为4567，其平方值是`4567 * 4567 = 20857489`，取中间两位是57。位数等于`ln100`。
2. 折叠方法
对于字符串类型的输入，计算方法是将每个字符的ASCII值累加起来，对M求模。缺点是，如果和sum比M小，就会产生较差的分布，增加了冲突的机率。

....
散列方法有很多，一般都是利用除余、乘法等计算方法。但是散列有好有坏，我们用冲突率来衡量好坏。具体计算这个不多说。

理想的散列方法就是一个萝卜一个坑，一个冲突都没有，但是有些冲突是不可避免的。冲突发生之后，我们如何解决冲突。

### 解决冲突
解决冲突的方法可以分为两类：开散列方法（Open hashing）和闭散列方法（Closed hashing）。

#### 开散列方法
也叫做“单链方法”，Separate chaining，思想就是将冲突记录到表外面。


#### 闭散列方法
也叫做“开地址方法”，Open addressing，思路就是讲冲突记录在表内的另一个空槽内。
主要的方法有：桶式散列、线性探查、二次探查、伪随机探查、双散列方法

##### 桶式散列
思想是：将散列表的多个槽(slot)分成多个桶(bucket)，即将M个槽分成B个桶，每个桶中包含M/B个槽。

散列过程是：散列函数把每条记录分配到某个桶中的第一个槽中，如果槽已经被占用了，那么就顺序沿着桶查找，直到找到一个空槽，如果没有槽了，就放到一个无限容量的溢出桶中。
例如有一个散列表，有6个槽，分为3个桶，每个桶2个槽。即`B = 3`，散列函数是：
```java
int h(int i)
{
    return i % B;
}
```
将`9 30 27 4 8`按照顺序放入哈希表中，最后将会变成这样：

![桶式散列](http://ovn0i3kdg.bkt.clouddn.com/%E6%A1%B6%E5%BC%8F%E6%95%A3%E5%88%97.png)

桶式散列的一个变体是：将码值散列到槽中，当槽满的时，再把码值散列扫同一个桶的其他槽中，如果没哟空槽，就散列到溢出桶中。
即散列函数是：
```java
int h(int i)
{
    return i % M;
}
```
仍旧是上面的例子，此时M = 6，同样的顺序结果为：

![桶式散列的变体](http://ovn0i3kdg.bkt.clouddn.com/%E6%95%A3%E5%88%97%E6%A1%B6%E5%8F%98%E4%BD%93.png)


#### 线性探查
比较常用，允许冲突元素记录在散列表中的任何一个空槽。思想是：如果发生了冲突，那么寻找下一个空槽，直到记录被存放。而中间经过的槽的序列叫做冲突解决策略产生的“探查序列”，这个是由“探查函数”产生的。探查函数类似如下：
```java
//@param{i} 第几次探查参数
//@param{k} 码值
int p(int k, int i)
{
    return a * i + b;
}
```
其中a和b是常数，注意该函数返回相对于初始位置的偏移而不是散列表的一个槽。使用的时候如下：
```java
return (h(k)+p(k, i))%M;
```
为了使探查列走遍所有槽，a和M必须互素。
线性探查会导致“基本聚集”这个问题。例如同样使用上面的例子，使用最基本的探查函数`return i`，其中`M = 6`， 对于顺序插入序列`9 30 27 4 8 `，那么9的探查序列是`3 4 5 0 1 2`，而27也是如此，到插入的记录多了，就是大部分都聚到了一起。解决方法就是二次探测或伪随机探查。

#### 二次探查
二次探查的探查函数如下：
```java
int p(int k, int i)
{
    return a*i*i+b*i+c;
}
```
a、b和c都是常数。二次探查的缺点在于，在某种特定情况下，只有特定的槽能被谈查到。比如`M = 3`，`p(k , i) = i * i`。那么散列到槽0的只会探查到0和1，不会探查到2。当散列表长度为素数，以及探查函数为` p(k, i) = i*i` 时，至少能够访问到表中一半的槽。 如果散列表长为` 2 `的指数，并且探查函数为` p(k, i) = (i*i+i)/2` ， 那么表中所有槽都能被探查序列访问到。

#### 伪随机探查
在伪随机探查中，探查序列中的第 i 个槽是 `(h(k) + ri) mod M` ，`ri`是` 1` 到` M-1` 之间的数的随机序列。
所有的插入和检索都使用相同的伪随机序列。

尽管二次探查和伪随机探查能够解决基本聚集问题，然而如果散列函数在某个基槽聚集，依然会保持聚集。这个问题称为二次聚集（secondary clustering）
解决二次聚集问题可以使用双散列方法。

#### 双散列方法
思想就是在探查函数中再增加一个散列方法：
```Java
int p(int k, int i)
{
    return i*h2(k);
}
```
h2 是第二个散列函数
好的双散列实现方法应当保证所有探查序列常数都与表 `M` 长度互素。
其中一种方法是设置 `M` 为素数，而`h2` 返回 `1<=h2<=M-1` 之间的值。
另外一种方法是给定一个 `m` 值，设置 `M = 2^m` ，然后让 `h2` 返回 `1` 到 `2m` 之间的一个奇数值。


#### 装填因子
装填因子`α = n / m`，其中n为要散列的元素的个数，m为哈希表的长度。

不同种解决冲突的方法在解决哈希冲突是哈希表的平均查找长度如下：参考[哈希表等概率情况下查找成功和查找不成功的平均查找长度的计算
](http://blog.csdn.net/wangran51/article/details/8826633/)

参考
* [数据结构和算法分析笔记]散列 hasing](http://blog.51cto.com/sauron/1227923)
* [数据结构：散列（hashing）](http://blog.csdn.net/u014613043/article/details/50726630)
