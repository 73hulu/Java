# 反射机制

反射机制非常重要，这关系到Java的语言特性，还和用到的各种Java框架息息相关。

网络上很多教程都是按部就班地告诉你怎么利用反射去做事，但是没有告诉我为什么会有反射这个东西，所以这篇博文搜集各方材料，尽量从原理到实现，层层递进，希望写完这篇博文之后能对反射有所理解吧。

### 什么是反射

反射允许**运行**中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。

Java反射框架主要提供以下功能：

1. 在运行时判断任意一个对象所属的类；
2. 在运行时构造任意一个类的对象；
3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
4. 在运行时调用任意一个对象的方法

### 为什么要用反射
我们为什么要用到反射？在写程序的时候，我们难道不是直接new一个对象，然后用操作对象完成一系列操作的么？但是对于一些写好框架，比如Spring，它的内部处理并不知道用户要写哪些类，这些都是由用框架的人来定的，这时候你还能在Spring内部去new对象呢？当然不能，这时候用户需要却配置文件中去配置路径，这就是一个经典的反射的例子。

反射是在运行的过程中去取得对象的实例的。这里涉及到两个概念：静态编译和动态编译。

静态编译就是在编译的时候把你所有的模块都编译进执行文件，当你启动执行文件的时候，所有的模块都加载进来了。而动态编译就不一样的，在静态编译时候，这些部分还没有编译进去，这样在启动程序（初始化）的手这些模块就不会被加载，而是在运行的时候，用到哪个模块用哪个模块。

例如，写一个阅读器，支持text、pdf和udm三种格式，暂时把读txt、读pdf和读udm定义为三种功能模块。使用静态编译：我想看个txt，点击应用程序图标之后三个功能都加载进来了，然后进行格式判断，使用txt模式，这样的话，另外两个模块的作用就是占用资源。如果使用动态编译，那么我想看个txt，点击应用程序，判断格式，只加载txt模块，使用它读txt模块。


对于
所以很显然，动态编译速度快，节省资源，而且有利于今后拓展。


### 反射的原理
反射既然这么好，能实现么？为什么能实现？

能实现！这种实现需要从类的加载说起。

JVM内存分区，这点不用解释了。具体的分区就是下面这张图。

![JVM内存](https://pic4.zhimg.com/50/v2-4face8109e0d52ef5894c41c69e4ec6b_hd.jpg)


比如写了`Object obj = new Object()`，JVM启动之后，这个代码会编译成字节码文件，然后被类加载如内存，放到哪里呢？方法区，这个地方保存了类的一些特性，然后在**堆**区域创建了`Object`类的`Class`对象，注意，这个不是new出来的对象，而一个类的类型对象。每一个类只有一个class对象，作为方法区类的数据结构的接口。之后，JVM创建对象之前，都会先检查类是否加载，寻找类对应的class对象，如果加载好了，就会为你的对象分配内存，初始化也就是代码`new Object()`。

> "反"是相对于“正”而言的。一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类去产生实例化对象，但是”反”是通过对象找到类。

这一过程类似于下图
![类的加载过程](http://img.blog.csdn.net/20170513133210763)

通过上面的图，可以总结出反射的实质是：根据`class`对象反向获取到到`Student`对象的各种信息。
所以接下来我们需要了解下`Class`这个类的作用了。

### Class类

`Class`这个类呢是对所有类的抽象，比如类是不是接口啊，是不是类啊，类的名字是什么啊，类有哪些公有方法啊，类的加载器是什么啊等等等等。总之是对某一个类本身的一个概括。

每一个类对应了唯一的一个类对象实例（`Class`对象），这个类对象实例是不能人为去new出来的，那么怎么得到的呢？是类本身被类加载器加载入内存的时候，JVM帮我们创建出来的，这时候，这个`class`对象就帮我们给这个类做了个登记：谁把它带进来的（类加载器）、名字叫什么（类的全部路径）、是什么身份（是类还是接口）、都有什么功能（实现了什么接口、继承了谁、有多少方法、有多少注解等），相当于有了一个花名册，这个花名册放到哪里呢？放在当前线程的堆中的区域。以后遇到一个类的时候，判断这个类来没来啊（是不是被加载进来了），就要去花名册看看，有的话就找到这个类，然后实例化一个类对象，没有的话就通知类加载器：这人没来，帮我找找然后来我这边登记。

就是这么一个过程啊。

如果我们拿到了花名册，是不是可以等级的信息为所欲为了呢。完全可以啊。这里的为所欲为说的是打破封闭原则，拿到这个类的所有属性，比如原来不能通过类的实例访问私有属性，现在通过这个“花名册”中的记录，我们能做任何事情了。

那么问题来了：花名册好办，就是`Class`这个类，我们怎么取得上面的特定的记录呢？比如我想要拿到叫”Student“这个名字的花名册记录？有三种方法：
1. 通过类名，从花名册中找。
已经知道了类名，我们直接可以利用`Class`类的静态方法，例如：
```java
Class studentClass = Class.forName("Student");
```

  比如我们在使用JDBC的时候会使用这种方法来加载数据库驱动：

  ```java
  Class.forName("com.mysql.jdbc.Driver");
  ```
2. 通过已经实例化的对象
每个类的实例都有一个方法指向了这个类的类对象，这个方法叫做`getClass`，这是继承自`Object`的方法，我们可以通过这个属性得到类对象。例如：
```java
Student student = new Student();
Class studentClass = student.getClass();
```
3. 通过类本身的静态方法
类本身就也有就可以知道自己的类对象的地址，这个属性是`class`属性。例如
```java
Class studentClass = Student.class;
```

好了拿到了类对象，真的可以为所欲为了，可以做什么事呢？

很多很多，比如我想用它实例化一个对象：`Student sdt = studentClass.newInstance()`。
想看看它是不是一个接口：`boolean isInterface = studentClass.isInterface()`，想要获取类的所有的属性和方法，想要获取特定的属性等等，想怎么做就怎么做。

常用的一些操作要眼熟：获取类的对象

> Class类位于`java.lang`包下，其具体方法可以参考《源码解读——Class》


当然，这其中还涉及到其他一些相关的类，都在`java.lang.reflet`子包下面，具体的有
* `java.lang.reflect.Constructor`
* `java.lang.reflect.Field`
* `java.lang.reflect.Method`
* `java.lang.reflect.Modifier`
这些类的具体实现可以参考《源码实现》中的相关博客。


这五个类的常见用法要熟悉，具体的可以参考[深入解析Java反射（1） - 基础](http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F)这里的讲解。

一些常用的操作要熟悉:
1. 获取类对象的方法（3种）
2. 创建一个类的对象的方法（3种）
3. 触发一个对象的方法操作（2种）
4. 判断是否为某个类的实例
5. 获取域、方法、构造器
6. 利用反射创建数组，详见`Array`类的源码解读


> 反射会破坏封装性，而且会消耗额外的系统资源，所以不是非必须情况下还是不要用反射，但是反射非常重要，它是各种框架实现的基础。

下一步，就要看看在Spring是如何利用反射的。

参考
* [深入解析Java反射（1） - 基础
](http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F)
* [学习java应该如何理解反射？
](https://www.zhihu.com/question/24304289)
* [Java程序编译和运行的过程](http://www.cnblogs.com/qiumingcheng/p/5398610.html)
