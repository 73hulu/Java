# 基本数据类型
基本数据类型也称为原生类、内置类型。

 ### 基本数据类型等级
 由低到高级分别为：(byte, short, char) -- int -- long -- float -- double

  Java默认的整型是int，浮点型是long。所以定义float的时候需要加上‘f’。判断下面的写法是不是正确的。
  ```Java
  float f1 = 1.0;//错误。1.0默认是long类型，要么强制转化成float，要么在后面加上f
  double l1 = 1.0;//正确，浮点型默认为double类型
  int i = 1;//正确，浮点型默认为int类型
  long l = 1;//正确，1虽然是int类型，但是可以从int自动转为long类型
  Float f = 1.0; //错误，1.0默认是long类型。自动装箱也不会用只能用long基本数值类型进行装箱
  Double l = 1.0; //正确，1.0是long类型
  Integer i = 1; //正确，1默认为int类型，自动装箱
  Long l = 1; //错误，1默认是int类型，这时候不能进行自动类型转化，需要在后面加上L。
  ```
 数据类型之间的转换可以分成这几种情况：
1. 由低级到高级的自动类型转换(注意，自动转化只发生在基本数据类型之间，不会发生在基本数据类型和包装类型之间，看上面的例子)
2. 有高级到低级的强制类型转换（会导致溢出或丢失精度）
3. 基本类型向包装类型转换
4. 基本类型向字符串转换
5. 包装类型向字符串转换


### 基本数据类型之间的转换规则：
 * 在一个双操作数以及位运算等算术运算式中，会根据操作数的类型将低级的数据类型自动转为高级的数据类型，分为以下几种情况：
   1. 只要两个操作数中有一个是double类型的，另一个将会被装换成double类型，并且结果也是double类型。
   1. 只要两个操作数中有一个是float类型的，另一个将会被转化成float类型，并且结果也是float类型。，并且结果也是float类型。
   1. 只要两个操作数中有一个是long类型，另一个将会被转化成long类型，并且结果也是long类型。结果也是long类型。
   1. 两个操作数（包括byte、short、int、 char） 都会被转化成int类型，并且结果也是int类型。并且结果也是int类型。
   2. 被fianl修饰的变量不会自动改变类型，当操作符的2个操作数都被final修饰时，结果会根据左边变量的类型而转化。

> 自动转换规则只针对基本数据类型，不针对包装类型，比如double d = 1；是对的，但是Double d = 1就不对了。

  特别需要注意的是第四条规则，正是这样的规则，使得两个short类型变量的和是int型。如果要得到short型，需要强制转化。

  例如`short s1 = 1; s1 = s1 + 1;`编译会报错，正确的写法是`short s1 = 1; s1 = (short) (s1 + 1);`。但是有一种情况特殊，“`+=`”为Java语言规定的运算语，Java编译器对其进行特殊处理，因此语句`short s1 = 1; s1 += 1;`编译成功。

  * 如果低级类型为char类型，向高级类型（整型）转化的时，会转化为对应的ASCII码，再做其他类型的自动转化。
  * 对于byte、short和char三种类型而言，他们是平级的，因此不能相互**自动**转化，但是可以强制转换。例如
  ```java
  short i  = 99;
  char ch = (char)i;
  System.out.println("output: " + ch);
  ```
  另外注意倒数最后一条规则，下面是一道笔试题：
  下列代码片段中，存在编辑错误的语句是（）？
  ```java
  byte b1 = 1, b2 = 2, b3, b6, b8;
  final byte b4 = 4,b5 = 6,b7;
  b3 = (b1 + b2);  /*语句1*/
  b6 = b4 + b5;    /*语句2*/
  b8 = (b1 + b4);  /*语句3*/
  b7 = (b2 + b5);  /*语句4*/
  System.out.println(b3 + b6);
  ```
	A. 语句1

	B. 语句2

	C. 语句3

	D. 语句4

  答案是 ACD，解析如下：

  语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；

  语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；

  语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);

  语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。



* 布尔值不能与任何数字类型之间强制转换。
* 不能级别的数据类型之间的强制转换，可能会导致溢出或精度的下降。
* 当byte类型参与运算的时候，Java会自动提升为int型。

参考： http://www.cnblogs.com/Chenshuai7/p/5047882.html
