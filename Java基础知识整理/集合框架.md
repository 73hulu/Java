# 集合框架
## 概述
在Java2之前，Java是没有完整的集合框架的。只有一些简单的可以自扩容的容器类，比如`Vector`、`Stack`、`HashTable`等，这些容器类在使用中饱受诟病，所以在Java2中被重新设计，于是有了现在的集合框架，需要注意的是，原来的那些容器类并没有被抛弃而是进行了保留，主要的目的是为了向下兼容，即使这样，我们还是应该注意尽量少使用。
Java集合框架涵盖众多数据结构类，其结构图如下：

![java_container](http://ovn0i3kdg.bkt.clouddn.com/Java%E9%9B%86%E5%90%88%E7%B1%BB.png)
>一般用接口定义框架；用抽象类提供接口的一部分实现；用抽象类通过具体的数据结构实现整个接口。

> JDK1.8 [集合框体系](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html)
从上面的集合框架图可以看出，Java集合框架主要包括两种类型的容器：
1. `集合Collection`：存储一个元素集合,`Collection`接口又有3种子类型的接口`List`、`Set`、`Queue`，再下面是一些抽象类，再下面是具体的实现类，常用的有`HashSet`、`LinkedHashSet`、`ArrayList`、`LinkedList`等。
2. `图Map`：存储键/值对映射，有两个抽象类`AbstractMap`和`SortedMap`，常用的实现类有`HashMap`、`LinkedHashMap`、`WeakHashMap`等。

## Collection接口
`Collection`接口是处理对象接口的根接口，其中定义了很多对元素进行操作的方法，例如`add`、`remove`、`addAll`、`contains`、`toArray`等。


`Collection`接口有3个子接口：`List`、`Set`、`Queue`，它们各自又有自己的实现类，继承结构如下：

![Collection_interface_tree](http://ovn0i3kdg.bkt.clouddn.com/collection_interface_tree.jpg)

接下来就具体的实现进行学习。

## List接口
`List`接口扩展自`Collection`，可以定义一个** 允许有重复** 的有序集合。从`List`接口中的方法来看，`List`接口主要是增加了面向位置的操作，允许指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器 `ListIterator`。`AbstractList`类提供了`List`接口的部分实现，`AbstractSequentialList`扩展自`AbstractList`，主要提供了对链表的支持。
下面介绍`List`接口的两个重要的实现类：数组线性表`ArrayList`和链式线性表`LinkedList`。
### 1. ArrayList
`ArrayList`直接继承`AbstractList`类，实现`List接口`、`RandomAccess`接口、`Cloneable`接口和`Serializable`接口。

由于实现了`RandomAccess`接口，所以使用for循环遍历比使用迭代器效率更高。

`ArrayList`使用数组存储元素，提供了三种构造方法。需要注意的是，如果是初始化时人为指定容量大小，那么数组空间在初始化的时候就被申请了；如果没有指定大小或者指定大小为0，那么在构造函数中是指数组空间指向了默认空间`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`或`EMPTY_ELEMENTDATA`，其真正的空间分配在第一次插入元素的时候，默认大小是10。

需要注意的是，元素的个数和容量并不是一个概念，方法`size`可得到元素的真实个数，这个数一定小于等于数组容量。当元素个数超过数组容量的时候，数组需要进行扩容。扩容原则是扩容为原来的1.5倍，这个扩容的大小是固定的，不能认为指定。数组不能无限增长，约定数组的最大容量为`Integer.MAX_VALUE - 8`，而实际上数组的最大容量可以达到`Integer.MAX_VALUE`。`ArrayList`类定义了多个与空间容量有关的方法，比如`ensureCapacityInternal`、`ensureExplicitCapacity`和`grow`，三者层层调用，`grow`才是最终绝对扩容容量的方法。所谓的扩容，实际上是重新申请了一块更大的空间，然后将原来的元素复制到新空间中，这一步采取的方法是`Arrays.copyOf`方法。`ArrayList`的数组空间可以自动扩容，却不能自动缩容。但是可以通过`trimToSize`方法进行收缩，使得元素个数正好等于容量，避免空间浪费。

`ArrayList`类有很多常用的方法。例如
1. `add`是最常用的对单元素操作的方法，有两个重载：一个用来追加元素，一个用来添加元素到指定位置，但是建议尽量少使用后面一种重载方法，因为数组的添加和删除操作涉及到元素的移动，频繁的移动简直是噩梦，虽然这种实现是基于`System.arraycopy`实现的，效率相对较高，但是能避免就避免吧。
2. `remove`是为最常用到的对单个元素操作的方法，有两个重载，不同于`add`方法的两个重载， `remove`的两个方法都是单个参数，一个用来删除指定索引上的元素，另一个以Object对象作为参数，用来删除**第一个**与之匹配的元素，需要注意的是，参数是`Object`类型，需要考虑null类型可能造成的空指针异常问题。
3. 对于集合的操作，`ArrayList`定义了三种方法，`addAll`、`removeAll`和`retainAll`。`addAll`重载了两个方法，同样提供了对位置的操作。`removeAll`顾名思义不多做解释。`retainAll`是保留与参数集合相同的那些元素，实际上，`removeAll`和`retainAll`正好是两个相反的实现过程，在源码中都是巧妙地利用了`batchRemove`的方法，利用布尔参数控制某个元素是否保留，比较巧妙，值得学习。
4. `ArrayList`还提供了一些基于位置的操作，比如`get`、`set`、`indexOf`、`lastIndexOf`等。
5. `ArrayList`实现了`Cloneable`接口，所以必须提供`clone`方法，`ArrayList`重写了该方法，但是要注意该方法提供的是浅拷贝，对于得到的拷贝对象的操作可能会影响原来的对象。
6. `ArrayList`的`toArray`方法需要注意，有两个，而我们如果想要得到特定类型的数组，一般的写法是：`String[] Strings = x.toArray(new String[])`;
7. `ArrayList`实现了`Iterable`接口，所以他必须提供迭代器方法。在`ArrayList`内部分别提供了两种迭代器方法：`iterator`和`listIterator`，前者返回`Iterator`类型迭代器，后者返回`ListIterator`。后者提供了双向迭代方法，比`Iterator`更强大。而两者类型的迭代器的实现是基于`ArrayList`的两个内部类：`Itr`和`ListItr`，前者实现`Iterator`接口，后者实现`ListIterator`接口。我们也可以学习这种方法来自定义自己的迭代器。需要注意的是，`ArrayList`中有一个变量`modCount`，这是用来观测在使用迭代器期间，外部对象是否对集合做出修改，如果做出修改，那么迭代器将不能使用。这个变量实际上就是计数器，记录外部对象修改操作的次数，修改操作例如add、remove、retainAll等。初始化迭代器的时候，会将这个量保存在迭代器的变量`expectedModCount`中，每次迭代器的操作都会先检查这个量和外部对象此时的`modCount`是否相等，不相等则说明发生了非迭代器的操作，那么迭代器操作就不能进行下去。

`ArrayList`可以和数组相互转化。`ArrayList`通过`toArray`方法转为为数组，注意写法，在上面第6条解释过。数组可以通过`Arrays.asList(变长字符串数组)`可以创建字符串线性表，但是需要注意的是，这个方法返回值是`Arrays.ArrayList`，而不是`java.util.ArrayList`。

`ArrayList`是非线程安全的，其方法全部都是非线程安全的。如果要求实现线程安全，那么使用`Vector`或者使用`Collections.Collections.synchronizedList`来创建线程安全的`ArrayList`。

### 2. LinkedList
`LinkedList`类直接继承自抽象父类`AbstractSequentialList`，实现`List`、`Deque`、`Cloneable`和`Serializable`接口。

与`ArrayList`不同，`LinkedList`使用**双向链表**存储数据，所以链表没有初始化大小的概念，也没有空间大小的限制。

由于数据结构的实现是双向链表，所以`LinkedList`提供了一些时间复杂度为O(1)的操作，比如`getFirst`用来获取第一个节点元素，`getLast`用来获取最后一个节点元素，同理还有`removeFirst`、`removeLast`、`addFirst`、`addLast`操作。当然对于插入和删除，`LinkedList`提供了`add`（两种重载），`remove`（两种重载）、`addAll`、`removeAll`操作，这些操作和`ArrayList`提供的方法具有相同的功能。源码实现的时候稍有技巧，如果指定了index，将会比较index是靠近链表头还是链表为，以决定双向链表遍历的方向。

其他线性表的操作与`ArrayList`类似，在此不做赘述。

`LinkedList`采取双向链表的数据结构，使得它实现了栈、单向队列和双线队列的功能。

对于栈的实现，`LinkedList`提供了`pop`和`push`方法，分别对应出栈和入栈操作，实际上，此时链表的头就是栈顶，方法的实现分别依赖于`addFirst`和`removeFirst`方法。

对于单向队列的实现，`LinkedList`提供了`offer`(基于`add`方法)、`poll`（基于`removeFirst`方法）、`remove`方法(基于`removeFirst`方法)、`peek`（基于`getFirst`方法）和`element`（基于`getFirst`）方法。实际上，此时链表头是队头，链表尾是队尾，`offer`方法是真正的入队操作，`poll`和`remove`方法是真正的出队操作，两者的不同点在于前者在遇到空链表的时候返回null，而后者抛出异常。`peek`和`element`方法用来获取队头元素，不出队，两者的不同在于`peek`方法在遇到空队列的时候返回null，而后者抛出异常。

对于双向队列，`LinkedList`提供 `offerFirst`、`offerLast`、`pollFirst`、`pollLast`、`peekFirst`和`peekLast`方法，很容易想的明白具体的实现细节。


> `ArrayList`和 `LinkedList`的不同是由于各自的数据结构不同造成的，即数组和链表的区别。所以在实际使用中我们需要根据特定的需求来选择合适的类：如果经常读取、除了在末尾外不能再其他位置插入或删除元素，则 `ArrayList`效率更高；如果经常插入或删除元素，就选择`LinkedList`。


### 3. Vector

同步版本的`ArrayList`，现在很少使用。可以使用`Collections.synchronizedList`实现`ArrayList`的同步操作。


### 4. Stack
对于栈操作的抽象，直接继承`Vector`，是栈基于数组的实现。由于数组具有空间的限制，且大部分操作都是在一段进行插入和删除操作，这种特点使用链表来实现更加合适，所以这个类一般不被使用，而是使用`LinkedList`提供的栈操作来代替。


>  对于 `List`，需要说明的是，`List`的顺序是元素插入的顺序，本身不支持有序存储（这里的有序是指大小有序），但是可以利用`Collections`类中的静态方法来实现排序。



## Set接口
`Set`接口扩展自 `Collection`，与`List`的不同之处在于`Set`不允许包含重复元素。即一个规则集内，一定不存在两个相等元素。这一点非常好理解，因为`Set`本身模拟的是数学中“集合”的概念，而集合本身是不能有重复元素的。

`AbstractSet`是一个实现`Set`接口的抽象类。`Set`接口有三个具体实现类：散列集`HashSet`、链式散列集`LinkedHashSet`和树形集`TreeSet`。

### 1. 散列集HashSet
`HashSet`是`Set`接口的最常用的实现类。该类中有一个`HashMap`类型的属性，而集合中的元素保存为`HashMap`的key值。所以说，`HashSet`是基于`HashMap`实现的，这也就能理解，为什么`HashSet`不允许有重复元素，以及最多包含一个null元素。

既然`HashSet`是基于`HashMap`实现的，那就一定存在`HashMap`的容量和装载因子问题，默认情况下，`HashSet`的初始容量为16，默认装载因为为0.75，当使用集合来实例化`HashSet`对象的时候，初始化容量为集合大小的4/3与16中的较大值。`HashSet`有5种重载的构造方法，其中需要注意，三个参数的构造方法中创建的是`LinkedHashMap`的实例，该构造方法的主要用途是为了创建`LinkedHashSet`对象。

### 2. 链式散列集LinkedHashSet
`LinkedHashSet`是用一个链表实现来扩展HashSet类，它支持对规则集内的元素**排序**。需要注意的是，这里的排序说的是按照插入顺序进行排序，并非指按照某种自定义的顺序（比如字典序），进行排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。

`LinkedHashSet`是基于`HashSet`实现的，或者从根本来说，是基于`LinkedHashMap`实现的。默认初始化大小为16，默认装载因子为0.75，如果以集合来实例化对象，其初始化大小为2倍的集合大小与11中的较大值。

### 3. 树形集TreeSet
`TreeSet`扩展自AbstractSet，并实现了`SortedSet`，`AbstractSet`扩展自`AbstractCollection`，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。
在实例化TreeSet时，我们可以给TreeSet指定一个比较器`Comparator`来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。下面是一个`TreeSet`的例子
```java
  public class TestSet {

    public static void main(String[] args) {

        TreeSet<Integer> set = new TreeSet<>();

        set.add(1111);
        set.add(2222);
        set.add(3333);
        set.add(4444);
        set.add(5555);

        System.out.println(set.first()); // 输出第一个元素
        System.out.println(set.lower(3333)); //小于3333的最大元素
        System.out.println(set.higher(2222)); //大于2222的最大元素
        System.out.println(set.floor(3333)); //不大于3333的最大元素
        System.out.println(set.ceiling(3333)); //不小于3333的最大元素

        System.out.println(set.pollFirst()); //删除第一个元素
        System.out.println(set.pollLast()); //删除最后一个元素
        System.out.println(set);
    }
}
```
> 更新一个集合时，如果不需要保持元素的排序关系，应该使用散列集，因为在散列集中插入和删除元素所花的时间少；如果需要保持集合中的元素排序时，可以把散列集转化为树形集。如下:


```java
public class TestHashSet {
	public static void main(String[] args) {
		Set<String> set = new HashSet<String>();

		set.add("London");
		set.add("Paris");
		set.add("New York");
		set.add("New York");
		set.add("San Francisco");

		TreeSet<String> treeSet = new TreeSet<String>(set);
		System.out.println(treeSet);
		for (String string : treeSet) {
			System.out.println(string + " ");
		}
	}
}
```


## Queue接口
`Queue`接口扩展自`Collection`，并提供插入、提取、检验等操作。以下是`Queue` 接口中的全部方法：

![Queue](http://ovn0i3kdg.bkt.clouddn.com/Queue.png)

常用的方法有：
`offer()`：表示向队列添加一个元素。
`poll()`与`remove()`方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。
`element()`与`peek()`主要是获取头部元素，不删除。

`Deque`接口，是一个扩展自`Queue`的双端队列，它支持在两端插入和删除元素，因为`LinkedList`类实现了`Deque`接口，所以通常我们可以使用`LinkedList`来创建一个队列。`PriorityQueue`类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。
```java
public class TestQueue {

    public static void main(String[] args) {

        Queue<String> queue = new LinkedList<>();

        queue.offer("aaaa");
        queue.offer("bbbb");
        queue.offer("cccc");
        queue.offer("dddd");

        while (queue.size() > 0) {
            System.out.println(queue.remove() + "");
        }
    }
}
```
### 1. LinnkedList
### 2. PriorityQueue



## Map接口
图是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但** 不能有重复的键**，每个键都对应一个值，真正存储在图中的是键值构成的条目。`Map`接口常用的三个实现类，分别是`HashMap`、`LinkedHashMap`、`TreeMap`。
### 1. HashMap
### 2. LinkedHashMap
### 3. TreeMap

参考
* [java集合继承关系图](https://www.cnblogs.com/jing99/p/7057245.html)
