# 集合框架
## 概述
在Java2之前，Java是没有完整的集合框架的。只有一些简单的可以自扩容的容器类，比如`Vector`、`Stack`、`HashTable`等，这些容器类在使用中饱受诟病，所以在Java2中被重新设计，于是有了现在的集合框架，需要注意的是，原来的那些容器类并没有被抛弃而是进行了保留，主要的目的是为了向下兼容，即使这样，我们还是应该注意尽量少使用。
Java集合框架涵盖众多数据结构类，其结构图如下：

![java_container](http://ovn0i3kdg.bkt.clouddn.com/Java%E9%9B%86%E5%90%88%E7%B1%BB.png)
>一般用接口定义框架；用抽象类提供接口的一部分实现；用抽象类通过具体的数据结构实现整个接口。

> JDK1.8 [集合框体系](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html)
从上面的集合框架图可以看出，Java集合框架主要包括两种类型的容器：
1. `集合Collection`：存储一个元素集合,`Collection`接口又有3种子类型的接口`List`、`Set`、`Queue`，再下面是一些抽象类，再下面是具体的实现类，常用的有`HashSet`、`LinkedHashSet`、`ArrayList`、`LinkedList`、`HashMap`、`LinkedHashMap`等。
2. `图Map`：存储键/值对映射

## Collection接口
Collection接口是处理对象接口的根接口，其中定义了很多对元素进行操作的方法。`AbstractCollection`是提供Collection部分实现的抽象类。下图展示了Collection接口中的全部方法。

![Collection_interface](../../img/Collection_interface.png)

其中有几个常用的方法：
* `add()`：添加元素到集合中。
* `addAll()`：将制定集合中的所有元素添加到集合中。
* `contains()`：检测集合中是否包含指定元素。
* `toArray()`：返回一个表示集合的数组。

`Collection`接口有3个子接口：`List`、`Set`、`Map`。
## `List`接口
`List`接口扩展自`Collection`，可以定义一个** 允许有重复** 的有序集合。从`List`接口中的方法来看，`List`接口主要是增加了面向位置的操作，允许指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器 `ListIterator`。`AbstractList`类提供了`List`接口的部分实现，`AbstractSequentialList`扩展自`AbstractList`，主要提供了对链表的支持。
下面介绍`List`接口的两个重要的实现类：数组线性表`ArrayList`和链式线性表`LinkedList`。
### 1. ArrayList
`ArrayList`继承`AbstractList`类，实现了`List`接口、`RandomAccess`接口、`Cloneable`接口、`Serializable`接口。它用数组存储元素，默认大小是10。数组动态创建，当超过数组的容量时，则创建一个更大的数组并将当前数组中的所有元素复制到新数组中，默认扩充为原来的1.5倍。每次扩充大小不可以指定。不能自动收缩，需要借助`trimToSize()`方法。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。
 * 方法`add(E e)`向集合中添加指定元素
 ````
 public boolean add(E e) {
      ensureCapacityInternal(size + 1);  // Increments modCount!!
      elementData[size++] = e;
      return true;
  } ````

* 此方法最重要的就是确定要创建的数组的大小。
  ````  
  private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }  ````

* 最后是创建数组，可以明显看到显示确定了添加元素后的大小之后将元素复制到新数组中。
  ````
  private void grow(int minCapacity) {
       // overflow-conscious code
       int oldCapacity = elementData.length;
       int newCapacity = oldCapacity + (oldCapacity >> 1);
       if (newCapacity - minCapacity < 0)
           newCapacity = minCapacity;
       if (newCapacity - MAX_ARRAY_SIZE > 0)
           newCapacity = hugeCapacity(minCapacity);
       // minCapacity is usually close to size, so this is a win:
       elementData = Arrays.copyOf(elementData, newCapacity);
   } ````

> `Arrays.asList(变长字符串数组)`可以创建字符串线性表，注意这个函数的返回值是`Arrays.ArrayList`，是`Arrays`类的静态内部类，而不是`java.util.ArrayList`。

### 2. LinkedList
同样阅读源码可以看到`LinkedList`的实现数据结构是链表，初始默认大小也是10。

> `ArrayList`和 `LinkedList`的不同是由于各自的数据结构不同造成的，即数组和链表的区别。所以在实际使用中我们需要根据特定的需求来选择合适的类：如果经常读取、除了在末尾外不能再其他位置插入或删除元素，则 `ArrayList`效率更高；如果经常插入或删除元素，就选择`LinkedList`。
>   `List`不支持有序存储，但是可以利用`Collections`类[** 不是Collection接口 **]中的静态方法来实现排序。

## Set接口
`Set`接口扩展自 `Collection`，与`List`的不同之处在于`Set`不允许包含重复元素。即一个规则集内，一定不存在两个相等元素。`AbstractSet`是一个实现`Set`接口的抽象类。`Set`接口有三个具体实现类：散列集`HashSet`、链式散列集`LinkedHashSet`和树形集`TreeSet`。

### 1. 散列集HashSet
`HashSet`是一个用于实现`Set`接口的具体类，下图展示了HashSet的全部方法。
![HashSet](../../img/HashSet.png)

HashSet中不能存在相同的元素，如果重复插入，只有一次生效，且元素的顺序没有按照插入时候的顺序。看一下例子：
````
public class TestHashSet {

    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("11111");
        set.add("22222");
        set.add("33333");
        set.add("44444");
        set.add("22222");

        System.out.println(set.size());

        for (String e : set) {
            System.out.println(e);
        }
    }
}````
从结果数据可以知道，规则集最后只有4个元素，且输出时的顺序是无序的。

在散列集中，需要注意两个名词：** 初始容量** 和 ** 客座率**。`HashSet`的默认初始容量为16（为何是16，见下方对HashMap的描述）,客座率为0.75，当元素个数超过容量的0.75倍时，就会自动进行扩容，扩容增量为原容量的1倍。

### 2. 链式散列集LinkedHashSet
`LinkedHashSet`是用一个链表实现来扩展HashSet类，它支持对规则集内的元素** 排序**。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。下面是`LinkedHashSet`的全部方法：
![LinkedHashSet](../../img/LinkedHashSet.png)

### 3. 树形集TreeSet
`TreeSet`扩展自AbstractSet，并实现了`SortedSet`，`AbstractSet`扩展自`AbstractCollection`，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。下面是`TreeSet`类的所有方法：
![TreeSet](../../img/TreeSet.png)
在实例化TreeSet时，我们可以给TreeSet指定一个比较器`Comparator`来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。下面是一个`TreeSet`的例子
````
  public class TestSet {

    public static void main(String[] args) {

        TreeSet<Integer> set = new TreeSet<>();

        set.add(1111);
        set.add(2222);
        set.add(3333);
        set.add(4444);
        set.add(5555);

        System.out.println(set.first()); // 输出第一个元素
        System.out.println(set.lower(3333)); //小于3333的最大元素
        System.out.println(set.higher(2222)); //大于2222的最大元素
        System.out.println(set.floor(3333)); //不大于3333的最大元素
        System.out.println(set.ceiling(3333)); //不小于3333的最大元素

        System.out.println(set.pollFirst()); //删除第一个元素
        System.out.println(set.pollLast()); //删除最后一个元素
        System.out.println(set);
    }
}
````
> 更新一个集合时，如果不需要保持元素的排序关系，应该使用散列集，因为在散列集中插入和删除元素所花的时间少；如果需要保持集合中的元素排序时，可以把散列集转化为树形集。如下:


````  
public class TestHashSet {
	public static void main(String[] args) {
		Set<String> set = new HashSet<String>();

		set.add("London");
		set.add("Paris");
		set.add("New York");
		set.add("New York");
		set.add("San Francisco");

		TreeSet<String> treeSet = new TreeSet<String>(set);
		System.out.println(treeSet);
		for (String string : treeSet) {
			System.out.println(string + " ");
		}
	}
}````


## Queue接口
`Queue`接口扩展自`Collection`，并提供插入、提取、检验等操作。以下是`Queue` 接口中的全部方法：

![Queue](../../img/Queue.png)

常用的方法有：
`offer()`：表示向队列添加一个元素。
`poll()`与`remove()`方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。
`element()`与`peek()`主要是获取头部元素，不删除。

`Deque`接口，是一个扩展自`Queue`的双端队列，它支持在两端插入和删除元素，因为`LinkedList`类实现了`Deque`接口，所以通常我们可以使用`LinkedList`来创建一个队列。`PriorityQueue`类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。
````
public class TestQueue {

    public static void main(String[] args) {

        Queue<String> queue = new LinkedList<>();

        queue.offer("aaaa");
        queue.offer("bbbb");
        queue.offer("cccc");
        queue.offer("dddd");

        while (queue.size() > 0) {
            System.out.println(queue.remove() + "");
        }
    }
}
````


## Map接口
图是一种存储键值对映射的容器类，在Map中键可以是任意类型的对象，但** 不能有重复的键**，每个键都对应一个值，真正存储在图中的是键值构成的条目。下面是接口Map的类结构:
![map](../../img/map.png)
从上面这张图中我们可以看到接口`Map`提供了很多查询、更新和获取存储的键值对的方法，更新包括方法`clear()`、`pullAll()`、`remove()`等等，查询方法包括`containsKey()`、`containesValue()`等等。`Map`接口常用的三个实现类，分别是`HashMap`、`LinkedHashMap`、`TreeMap`。
### 1. HashMap
