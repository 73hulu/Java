# NIO

NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。
## BIO、NIO和BIO
实际上，我们常常听到另外两个词，BIO和NIO。它们有什么区别呢？在分辨这几个概念之前，我们需要回答以下几个问题：
1. 什么是异步和同步？
2. 什么是阻塞和非阻塞？
3. 什么是同步阻塞、什么是同步非阻塞、什么是异步非阻塞？

同步和异步是针对应用程序和内核的交互而言的。

阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。  

由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。

| 名词 | 含义 |  例子|
| :------------- | :------------- | :---|
| 同步 | 指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪	 |自己上街买衣服，自己亲自干这件事，别的事干不了。 |
|异步   |异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）	   | 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS）  |
|阻塞   |所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止	   |  去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。） |
|非阻塞   |非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待。   | 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。  |

下面就是对BIO、NIO和AIO的具体解释了：
* 同步阻塞IO —— BIO：即synchronous Blocking IO
  同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
* 同步非阻塞IO(Java NIO)—— NIO：即synchronous Non blocking IO
同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。
* 异步阻塞IO —— JAVA NIO
 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！  

* 异步非阻塞IO——Java AIO（Java NIO2.0）：即Asynchronous non blocking IO
 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。

## Java NIO和IO的区别
| IO | NIO |
| :------------- | :------------- |
| 面向流     |面向缓冲      |
|阻塞IO   |  非阻塞IO |
|  无  |  选择器 |

### 面向流和面向缓冲
Java IO和NIO之间第一个最大的区别是，**IO是面向流的，NIO是面向缓冲区的**。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，**它们没有被缓存在任何地方**。此外，它**不能前后移动流中的数据**。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 而Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中

### 阻塞和非阻塞
**Java IO的各种流是阻塞的**。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。**Java NIO的非阻塞模式**，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。


### 选择器Selector
Java NIO的选择器允许**一个单独的线程来监视多个输入通道**，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得**一个单独的线程很容易来管理多个通道。**

Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。

> NIO将阻塞交给了后台线程执行


## Channel
涵盖了UDP 和 TCP 网络IO，以及文件IO
### FileChannel

### DatagramChannel
### SocketChannel
### ServerSocketChannel

## Buffer
### ByteBuffer
### CharBuffer
### DoubleBuffer
### FloatBuffer
### IntBuffer
### LongBuffer
### ShortBuffer


## Selector



参考
* [Java NIO 与 IO之间的区别](http://blog.csdn.net/evan_man/article/details/50910542)
