# 序列化和反序列化


### 为什么会有序列化和反序列化



###   JSON处理工具包

Java Bean、集合、Map、日期、Enum
#### FastJson
非常快，首选
源码地址: https://github.com/alibaba/fastjson
添加maven依赖：
```xml
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>fastjson</artifactId>
	<version>1.2.12</version>
</dependency>
```
FastJson API入口类是`com.alibaba.fastjson.JSON`，基本用该类的静态方法来完成序列化和反序列化，常用方法有：

| 常用方法 | 说明 |
| :------------- | :------------- |
| public static final Object parse(String text); | 把JSON文本parse为JSONObject或者JSONArray  |
|public static final JSONObject parseObject(String text);   | 把JSON文本parse成JSONObject      |
|**public static final  T parseObject(String text, Class clazz);  ** | **把JSON文本parse为JavaBean **  |
|public static final JSONArray parseArray(String text);   |  把JSON文本parse成JSONArray  |
|**public static final  List parseArray(String text, Class clazz);   **|  **把JSON文本parse成JavaBean集合 ** |
|**public static final String toJSONString(Object object); **  |   **将JavaBean序列化为JSON文本 **|
|  public static final String toJSONString(Object object, boolean prettyFormat);  | 将JavaBean序列化为带格式的JSON文本   |
|public static final Object toJSON(Object javaObject);    |   将JavaBean转换为JSONObject或者JSONArray|
高亮方法为常用方法。
#### Gson

#### Jackson


### 实践：JavaBean时间参数的序列化和反序列化
一个经常遇到的问题：在借助序列化工具，需要将POJO中的时间参数进行json格式化的时候将其规划话。在实践中遇到了一点麻烦，归根到底是因为将各个序列化工具的配置混为一谈，下面就来总结一下：
1. FastJson
需要在JavaBean中时间参数字段或其set方法上加上
```java
@JSONField(format="yyyy-MM-dd")
```
2. Gson
需要在创建的gson的时候设定时间格式
```java
Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss");
```
3. Jackson
这是我最先接触的，如果输入“Java json 时间 序列化”，搜到的答案基本是适用于它的，有个地方可以对gson时间格式进行设置：
 * 配置文件中添加：
 ```xml
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
```
覆盖这个工程，只要使用`jackson`，时间的格式将被转为`yyyy-MM-dd HH:mm:ss`这样的格式。
  * 在JavaBean时间参数上可添加两个注解：
  ```java
  @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm") //入参，yyyy-MM-dd HH:mm格式的字符串将转为时间类型参数
  @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm") //出参，时间参数序列化时候将格式化为yyyy-MM-dd HH:mm形式
  ```
  > JsonFormat注释于public类型属性或者get函数才有效，private属性无效
  > @JsonFormat将会覆盖配置文件中的配置




参考
* [Java深度历险（十）——Java对象序列化与RMI](http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi/)
* [序列化和反序列化](https://kb.cnblogs.com/page/515982/)
* [Gson - Java-JSON 序列化和反序列化入门](https://www.jianshu.com/p/a03bc97875b8)
* [spring boot 返回json数据日期格式化](https://www.jianshu.com/p/7084f081b871)
* [@JsonFormat和@DateTimeFormat 实践测试](http://blog.csdn.net/silyvin/article/details/71450270)
* [fastjson把Date类型数据转换成一长串数字](http://blog.csdn.net/qq_25428769/article/details/52817389)
* [序列化和反序列化](https://kb.cnblogs.com/page/515982/)
* [Java的Json解析包FastJson使用](https://www.cnblogs.com/wgale025/p/5875430.html)
