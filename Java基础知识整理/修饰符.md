# 修饰符
<!-- toc -->
<!--tocstop  -->

按照修饰对象的不同，Java修饰符可以分为三类：类修饰符、数据域修饰符和方法修饰符；

按照修饰作用的不同，Java修饰符又可以分为两类：可访问控制修饰符和非可访问控制修饰符。
其中访问控制修饰符是指`public`、`protected`、`default`、`private`四种，其各自的访问限制范围如下图所示：

![access_control](http://ovn0i3kdg.bkt.clouddn.com/access_control.png)

现在我们以前者为主要分类标准，后者为辅进行整理。

## 类修饰符
### 可访问控制修饰符
  * `public`：表示公共类，任意的其他类都能访问该类。
  * `default`：缺省，该类只能包内访问

### 非可访问控制修饰符
  * `abstract`：表示抽象类。
  * `final`：表示最终类，不能被继承。最终类通常是一些有固定作用、用来完成某种标准功能的类，如`StringBuffer`、`StringBuider`。** 一个类不能既被声明为abstract，又被声明为final**。

> 当类为内部类的时候，这时候可以将内部类当做一个特殊的成员变量，此时类能够被其他数据域或方法域修饰符修饰。

## 数据域修饰符
### 可访问控制修饰符
  * `public`：公共访问控制符，任意类都能访问。
  * `protected`：保护访问控制符，只能被类本身、子类、同一个包内的类访问。
  * `default`：缺省访问控制符，只能包内访问。
  * `private`：私有访问控制修饰符，只能被类本身访问。

### 非可访问控制修饰符
  * `static`：静态修饰符。用static修饰的成员变量仅属于** 类的变量**，而不属于任何一个具体的对象。静态成员变量的值保存于类内存区域的公共存储单元，而不保存在某一个对象的内存区间。任何一个类的对象访问它时取到的都是相同的数据。任何一个类的对象修改它时，也都是对同一个内存单元进行操作。
  > Java没有全局变量的概念，但是用静态变量可以在一定程度上达到全局的效果。
  > 在Java中，不能在成员函数的内部定义static变量，以下程序编译失败。
  >
  ````
   public class Test {
     public static int testStatic() {
		static final int i = 0;
		System.out.println(i);
	}
	public static void main(String[] args) {
		Test test = new Test();
		test.testStatic();
	}````


  * `final`：最终域修饰符，定义常量符号。用来修饰对象的时候，对象引用不可用。** 注意**，是引用不可变，而不是对象不可变，即只能指向初始时候的那个对象，而不关心指向对象内容的改变。
  ````
   public static void main(String[] args) {
  	final StringBuilder builder = new StringBuilder("Hello");
  	builder.append(" World");
  	System.out.println(builder);
    }````
    以上代码执行结果为`Hello World`。
    ````
    public static void main(String[] args) {
    	final StringBuilder builder = new StringBuilder("Hello");
    	builder = new StringBuilder("Hello world");
    }  ````
    以上代码在编译期间报错。
  - `volatile`:易失（共享）域修饰符。说明这个成员变量可能被几个线程所控制和修改。也就是说在程序运行过程中，这个成员变量有可能被其他的程序影响或改变其取值。因此，在使用中要注意这种成员变量取值的变化。通常用来修饰接受外部输入的域。什么意思呢？就是说在多线程访问中，临界区只有一个线程能访问，临界区的操作应该具有原子性，而这个过程中，任何变量的改变必须对外可见，而不是在这个操作完之后才对外可见，这个性质叫做“可见性”。`synchronized`能够保证原子性和可见性，而其取值。因此，在使用中要注意这种成员变量取值的变化。通常用来修饰接受外部输入的域。什么意思呢？就是说在多线程访问中，临界区只有一个线程能访问，临界区的操作应该具有原子性，而这个过程中，任何变量的改变必须对外可见，而不是在这个操作完之后才对外可见，这个性质叫做“可见性”。`synchronized`能够保证原子性和可见性，而`volatile`只能保证可见性，不能原子性（当然不能了，这个修饰符是用来修饰变量的，哪有什么原子性）。
  * `transient`：暂时性域修饰符。用来定义一个暂时性的变量。其特点是：用修饰符 transient 限定的暂时性变量，将指定 Java 虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。序列化的时候会忽略这些数据。

## 方法控制修饰符
### 可访问控制修饰符
  * `public`：公共访问控制符，任意类都能访问。
  * `protected`：保护访问控制符，只能被类本身、子类、同一个包内的类访问。
  * `default`：缺省访问控制符，只能包内访问。
  * `private`：私有访问控制修饰符，只能被类本身访问。

### 非可访问控制修饰符
  * `static`：静态方法控制修饰符。静态方法是属于整个类的方法，而不用static修饰限定的方法是属于某个具体对象的方法，有static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量。static一个重要的用途就是单例模式，即该类只能有一个实例。为了这个功能，必须隐藏类的构造函数，即将构造函数声明为private，并提供一个创建对象的方法，这种方法说就是将创建对象的方法声明为static。
  * `final`：最终方法控制符。最终方法是功能和内部语句不能更改的方法，即最终方法** 不能重写**。这样，就固定了这个方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性，所有被private修饰符限定为私有的方法，以及所有包含在final类（最终类）中的方法，都被认为是最终方法。当方法被声明为final时，直接将方法主体插入到调用处，而不是进行方法调用（类似于C++中的inline）
  * `abstract`：抽象方法控制修饰符。抽象方法是一种仅有方法头，没有方法体和操作实现的一种方法。
  * `native`：本地方法控制符。表明实现方法的程序设计语言不是Java。如Obejct中的clone()方法。
  * `synchronized`：同步方法控制符。多线程共存的程序中的协调和同步。
