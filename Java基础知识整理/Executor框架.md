# Executor框架

`Executor`是Java提供的有关于线程的框架，在JDK1.5中被提出。在此之前，线程即是工作单元也是执行机制。而`Executor`框架将线程的工作单元和执行机制相互分离，其中`Runnable`和`Callable`是工作单元，而`Executor`框架则提供了线程的执行机制。

`Executor`框架主要包含三个部分

| 部分 | 内容 |
| :------------- | :------------- |
| 任务 | 包括`Runnable`和`Callable`，其中`Runnable`可以表示一个异步执行的任务，而`Callable`表示一个会产生结果的任务 |
|任务的执行   |包括核心接口`Executor`及其子接口`ExecutorService`，有两个类——`ThreadPoolExecutor`和`ScheduledThreadPollExecutor`实现了`ExecutorService`接口  |
|异步计算的结果   |  包括接口`Future`及其实现了`FutureTask`|

### 线程池

首先我们要弄清楚为什么要用线程池？

之前我们用继承`Thread`类和继承`Runnable`接口的方法来创建线程，完全能够运作起来，没有什么不妥。但是试想这样一种情况：许多服务器应用程序都面向处理来自远程来源的大而小的任务，应用程序需要为每一个任务都创建一个线程，然后让线程执行完程序之后，再进行销毁，如此反复，导致造成这样一种局面：创建和销毁线程带来的开销远大于处理业务的开销。另外，只要线程活动着，它就会消耗资源。所以，如果系统创建了过多的线程，在一个JVM中创建了太多的线程将可能导致系统由于过度消耗内存而用完内存或“切换过度”。为了防止资源不足，应用程序需要一些办法来限制任何给定时刻处理的请求数目。

基于以上的考虑，线程池应运而生。它的基本原理是线程的重用：当请求到达时，由于线程已经存在，所以也就不用再创建线程，也不用等创建成功后再进行操作，既节省了资源空间，也提高了响应速度。另外，线程池的线程数目是有上线的，当一个任务到来但是已无线程可用的时候，需要强制使新到的任务等待，一直等到其获取线程为止，这样就可以避免资源不足的问题。

总的来说，以下原因促使线程池出现：
1. 创建/销毁线程伴随着系统的开销，过于频繁的创建/销毁线程将影响处理效率。
2. 线程并发量过多，抢占系统资源从而导致阻塞
3. 对线程进行一些简单的管理，比如延迟执行，定时循环执行等。

Java在JUC中提供了`Executor`框架，作为线程池的实现，涉及的重要的类有`ThreadPoolExecutor`、`E`
