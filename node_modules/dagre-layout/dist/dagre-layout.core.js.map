{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dagre-layout.core.js","webpack:///webpack/bootstrap fed9e374209623a47960","webpack:///external \"lodash\"","webpack:///./lib/util.js","webpack:///external \"graphlib\"","webpack:///./lib/rank/util.js","webpack:///./lib/rank/feasible-tree.js","webpack:///./index.js","webpack:///./lib/layout.js","webpack:///./lib/acyclic.js","webpack:///./lib/greedy-fas.js","webpack:///./lib/data/list.js","webpack:///./lib/normalize.js","webpack:///./lib/rank/index.js","webpack:///./lib/rank/network-simplex.js","webpack:///./lib/parent-dummy-chains.js","webpack:///./lib/nesting-graph.js","webpack:///./lib/add-border-segments.js","webpack:///./lib/coordinate-system.js","webpack:///./lib/order/index.js","webpack:///./lib/order/init-order.js","webpack:///./lib/order/cross-count.js","webpack:///./lib/order/sort-subgraph.js","webpack:///./lib/order/barycenter.js","webpack:///./lib/order/resolve-conflicts.js","webpack:///./lib/order/sort.js","webpack:///./lib/order/build-layer-graph.js","webpack:///./lib/order/add-subgraph-constraints.js","webpack:///./lib/position/index.js","webpack:///./lib/position/bk.js","webpack:///./lib/debug.js","webpack:///./package.json"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","require","addDummyNode","g","type","attrs","v","_lodash2","default","uniqueId","hasNode","dummy","setNode","simplify","simplified","_graphlib","Graph","setGraph","graph","forEach","nodes","node","edges","e","simpleLabel","edge","w","weight","minlen","label","setEdge","Math","max","asNonCompoundGraph","multigraph","isMultigraph","children","length","successorWeights","weightMap","map","sucs","outEdges","zipObject","predecessorWeights","preds","inEdges","intersectRect","rect","point","x","y","dx","dy","width","h","height","Error","sx","sy","abs","buildLayerMatrix","layering","range","maxRank","rank","isUndefined","order","normalizeRanks","min","has","removeEmptyRanks","offset","layers","push","delta","nodeRankFactor","vs","addBorderNode","prefix","arguments","partition","collection","fn","result","lhs","rhs","value","time","start","now","console","log","notime","_lodash","obj","longestPath","dfs","visited","sources","slack","feasibleTree","t","directed","size","nodeCount","tightTree","findMinSlackEdge","_util","shiftRanks","nodeEdges","edgeV","minBy","_interopRequireDefault","_graphlib2","_layout","_layout2","_debug","_debug2","_util2","_package","graphlib","layout","debug","util","version","opts","debugTiming","layoutGraph","buildLayoutGraph","runLayout","updateInputGraph","makeSpaceForEdgeLabels","removeSelfEdges","_acyclic2","run","_nestingGraph2","_rank2","injectEdgeLabelProxies","cleanup","assignRankMinMax","removeEdgeLabelProxies","_normalize2","_parentDummyChains2","_addBorderSegments2","_order2","insertSelfEdges","_coordinateSystem2","adjust","_position2","positionSelfEdges","removeBorderNodes","undo","fixupEdgeLabelCoords","translateGraph","assignNodeIntersects","reversePointsForReversedEdges","inputGraph","inputLabel","layoutLabel","points","compound","canonicalize","merge","graphDefaults","selectNumberAttrs","graphNumAttrs","pick","graphAttrs","defaults","nodeNumAttrs","nodeDefaults","setParent","parent","edgeDefaults","edgeNumAttrs","edgeAttrs","ranksep","labelpos","toLowerCase","rankdir","labeloffset","borderTop","minRank","borderBottom","labelRank","removeNode","getExtremes","minX","maxX","minY","maxY","Number","POSITIVE_INFINITY","graphLabel","marginX","marginx","marginY","marginy","nodeV","nodeW","p1","p2","unshift","reversed","reverse","b","last","borderLeft","r","borderRight","selfEdges","removeEdge","layer","orderShift","selfEdge","selfNode","mapValues","newAttrs","k","_acyclic","_normalize","_rank","_parentDummyChains","_nestingGraph","_addBorderSegments","_coordinateSystem","_order","_position","edgesep","nodesep","fas","acyclicer","_greedyFas2","dfsFAS","forwardName","stack","_greedyFas","greedyFAS","weightFn","state","buildState","DEFAULT_WEIGHT_FN","results","doGreedyFAS","buckets","zeroIdx","flatten","sinks","entry","dequeue","concat","collectPredecessors","undefined","uEntry","out","assignBucket","wEntry","fasGraph","maxIn","maxOut","in","prevWeight","edgeWeight","_list2","enqueue","_list","constant","List","sentinel","_next","_prev","_sentinel","unlink","filterOutLinks","toString","strs","curr","JSON","stringify","join","dummyChains","normalizeEdge","vRank","wRank","edgeLabel","edgeObj","origLabel","successors","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker","_feasibleTree2","_networkSimplex2","_feasibleTree","_networkSimplex","networkSimplex","initLowLimValues","initCutValues","f","leaveEdge","enterEdge","exchangeEdges","postorder","slice","assignCutValue","child","childLab","cutvalue","calcCutValue","childIsTail","graphEdge","cutValue","isOutEdge","other","pointsToHead","otherWeight","isTreeEdge","otherCutValue","tree","dfsAssignLowLim","nextLim","low","neighbors","lim","find","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","updateRanks","preorder","flipped","u","rootLabel","alg","parentDummyChains","postorderNums","pathData","findPath","path","lca","pathIdx","pathV","ascending","vPath","wPath","depths","treeDepths","values","nodeSep","nestingRoot","sumWeights","top","bottom","childNode","childTop","childBottom","thisWeight","nestingEdge","depth","reduce","acc","addBorderSegments","prop","sg","sgNode","borderType","prev","rankDir","swapWidthHeight","reverseY","swapXY","swapWidthHeightOne","reverseYOne","swapXYOne","downLayerGraphs","buildLayerGraphs","upLayerGraphs","_initOrder2","assignOrder","bestCC","best","lastBest","sweepLayerGraphs","cc","_crossCount2","cloneDeep","ranks","relationship","_buildLayerGraph2","layerGraphs","biasRight","cg","lg","sorted","_sortSubgraph2","_addSubgraphConstraints2","_initOrder","_crossCount","_sortSubgraph","_buildLayerGraph","_addSubgraphConstraints","initOrder","simpleNodes","orderedVs","sortBy","crossCount","twoLayerCrossCount","northLayer","southLayer","southPos","southEntries","chain","pos","firstIndex","treeSize","Array","index","weightSum","sortSubgraph","movable","bl","br","subgraphs","barycenters","_barycenter2","subgraphResult","mergeBarycenters","entries","_resolveConflicts2","expandSubgraphs","_sort2","predecessors","blPred","brPred","barycenter","target","_barycenter","_resolveConflicts","_sort","inV","nodeU","sum","resolveConflicts","mappedEntries","tmp","indegree","entryV","entryW","doResolveConflicts","sourceSet","pop","vEntry","merged","mergeEntries","source","sort","parts","sortable","unsortable","vsIndex","compareWithBias","consumeUnsortable","bias","buildLayerGraph","createRootNode","setDefaultNodeLabel","addSubgraphConstraints","rootPrev","prevChild","position","positionY","_bk","positionX","rankSep","prevY","maxHeight","findType1Conflicts","visitLayer","prevLayer","k0","scanPos","prevLayerLength","lastNode","findOtherInnerSegmentNode","k1","scanNode","uLabel","uPos","addConflict","conflicts","findType2Conflicts","scan","south","southEnd","prevNorthBorder","nextNorthBorder","uNode","north","prevNorthPos","nextNorthPos","southLookahead","conflictsV","hasConflict","verticalAlignment","neighborFn","align","prevIdx","ws","mp","floor","il","ceil","horizontalCompaction","reverseSep","pass1","xs","blockG","pass2","buildBlockGraph","blockGraph","sepFn","sep","vRoot","uRoot","prevMax","findSmallestWidthAlignment","xss","toPairs","pair","maxBy","alignCoordinates","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","xsVals","balance","ul","ignore","adjustedLayering","inner","bind","smallestWidth","edgeSep","debugOrdering","layerMatrix","layerV","style","description","author","main","keywords","scripts","lint","jest","karma","test","bench","build","build:watch","release","upgrade","prepush","prepublishOnly","dependencies","lodash","devDependencies","babel-core","babel-loader","babel-preset-env","benchmark","chai","coveralls","husky","karma-chrome-launcher","karma-firefox-launcher","karma-mocha","karma-safari-launcher","mocha","sprintf","standard","webpack","webpack-node-externals","yarn-upgrade-all","repository","url","license","files","testRegex","testPathIgnorePatterns"],"mappings":"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","file":"dagre-layout.core.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dagre\"] = factory();\n\telse\n\t\troot[\"dagre\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dagre\"] = factory();\n\telse\n\t\troot[\"dagre\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"lodash\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addDummyNode = addDummyNode;\nexports.simplify = simplify;\nexports.asNonCompoundGraph = asNonCompoundGraph;\nexports.successorWeights = successorWeights;\nexports.predecessorWeights = predecessorWeights;\nexports.intersectRect = intersectRect;\nexports.buildLayerMatrix = buildLayerMatrix;\nexports.normalizeRanks = normalizeRanks;\nexports.removeEmptyRanks = removeEmptyRanks;\nexports.addBorderNode = addBorderNode;\nexports.maxRank = maxRank;\nexports.partition = partition;\nexports.time = time;\nexports.notime = notime;\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v = void 0;\n  do {\n    v = _lodash2.default.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new _graphlib.Graph().setGraph(g.graph());\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    simplified.setNode(v, g.node(v));\n  });\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new _graphlib.Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _lodash2.default.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _lodash2.default.map(g.nodes(), function (v) {\n    var sucs = {};\n    _lodash2.default.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _lodash2.default.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _lodash2.default.map(g.nodes(), function (v) {\n    var preds = {};\n    _lodash2.default.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _lodash2.default.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle');\n  }\n\n  var sx = void 0;\n  var sy = void 0;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _lodash2.default.map(_lodash2.default.range(maxRank(g) + 1), function () {\n    return [];\n  });\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_lodash2.default.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _lodash2.default.min(_lodash2.default.map(g.nodes(), function (v) {\n    return g.node(v).rank;\n  }));\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (_lodash2.default.has(node, 'rank')) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _lodash2.default.min(_lodash2.default.map(g.nodes(), function (v) {\n    return g.node(v).rank;\n  }));\n\n  var layers = [];\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _lodash2.default.forEach(layers, function (vs, i) {\n    if (_lodash2.default.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _lodash2.default.forEach(vs, function (v) {\n        g.node(v).rank += delta;\n      });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, 'border', node, prefix);\n}\n\nfunction maxRank(g) {\n  return _lodash2.default.max(_lodash2.default.map(g.nodes(), function (v) {\n    var rank = g.node(v).rank;\n    if (!_lodash2.default.isUndefined(rank)) {\n      return rank;\n    }\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _lodash2.default.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _lodash2.default.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + ' time: ' + (_lodash2.default.now() - start) + 'ms');\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n\nexports.default = {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"graphlib\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.longestPath = longestPath;\nexports.slack = slack;\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (_lodash2.default.has(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _lodash2.default.min(_lodash2.default.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    })) || 0;\n\n    return label.rank = rank;\n  }\n\n  _lodash2.default.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n\nexports.default = {\n  longestPath: longestPath,\n  slack: slack\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _util = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree(g) {\n  var t = new _graphlib.Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n\n  var edge = void 0;\n  var delta = void 0;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, _util.slack)(g, edge) : -(0, _util.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree(t, g) {\n  function dfs(v) {\n    _lodash2.default.forEach(g.nodeEdges(v), function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !(0, _util.slack)(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  }\n\n  _lodash2.default.forEach(t.nodes(), dfs);\n  return t.nodeCount();\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge(t, g) {\n  return _lodash2.default.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return (0, _util.slack)(g, e);\n    }\n  });\n}\n\nfunction shiftRanks(t, g, delta) {\n  _lodash2.default.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta;\n  });\n}\n\nexports.default = feasibleTree;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _graphlib = __webpack_require__(2);\n\nvar _graphlib2 = _interopRequireDefault(_graphlib);\n\nvar _layout = __webpack_require__(6);\n\nvar _layout2 = _interopRequireDefault(_layout);\n\nvar _debug = __webpack_require__(28);\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _package = __webpack_require__(29);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  graphlib: _graphlib2.default,\n  layout: _layout2.default,\n  debug: _debug2.default,\n  util: {\n    time: _util2.default.time,\n    notime: _util2.default.notime\n  },\n  version: _package.version\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _acyclic = __webpack_require__(7);\n\nvar _acyclic2 = _interopRequireDefault(_acyclic);\n\nvar _normalize = __webpack_require__(10);\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _rank = __webpack_require__(11);\n\nvar _rank2 = _interopRequireDefault(_rank);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _parentDummyChains = __webpack_require__(13);\n\nvar _parentDummyChains2 = _interopRequireDefault(_parentDummyChains);\n\nvar _nestingGraph = __webpack_require__(14);\n\nvar _nestingGraph2 = _interopRequireDefault(_nestingGraph);\n\nvar _addBorderSegments = __webpack_require__(15);\n\nvar _addBorderSegments2 = _interopRequireDefault(_addBorderSegments);\n\nvar _coordinateSystem = __webpack_require__(16);\n\nvar _coordinateSystem2 = _interopRequireDefault(_coordinateSystem);\n\nvar _order = __webpack_require__(17);\n\nvar _order2 = _interopRequireDefault(_order);\n\nvar _position = __webpack_require__(26);\n\nvar _position2 = _interopRequireDefault(_position);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? _util2.default.time : _util2.default.notime;\n  time('layout', function () {\n    var layoutGraph = time('  buildLayoutGraph', function () {\n      return buildLayoutGraph(g);\n    });\n    time('  runLayout', function () {\n      runLayout(layoutGraph, time);\n    });\n    time('  updateInputGraph', function () {\n      updateInputGraph(g, layoutGraph);\n    });\n  });\n}\n\nfunction runLayout(g, time) {\n  time('    makeSpaceForEdgeLabels', function () {\n    makeSpaceForEdgeLabels(g);\n  });\n  time('    removeSelfEdges', function () {\n    removeSelfEdges(g);\n  });\n  time('    acyclic', function () {\n    _acyclic2.default.run(g);\n  });\n  time('    nestingGraph.run', function () {\n    _nestingGraph2.default.run(g);\n  });\n  time('    rank', function () {\n    (0, _rank2.default)(_util2.default.asNonCompoundGraph(g));\n  });\n  time('    injectEdgeLabelProxies', function () {\n    injectEdgeLabelProxies(g);\n  });\n  time('    removeEmptyRanks', function () {\n    (0, _util.removeEmptyRanks)(g);\n  });\n  time('    nestingGraph.cleanup', function () {\n    _nestingGraph2.default.cleanup(g);\n  });\n  time('    normalizeRanks', function () {\n    (0, _util.normalizeRanks)(g);\n  });\n  time('    assignRankMinMax', function () {\n    assignRankMinMax(g);\n  });\n  time('    removeEdgeLabelProxies', function () {\n    removeEdgeLabelProxies(g);\n  });\n  time('    normalize.run', function () {\n    _normalize2.default.run(g);\n  });\n  time('    parentDummyChains', function () {\n    (0, _parentDummyChains2.default)(g);\n  });\n  time('    addBorderSegments', function () {\n    (0, _addBorderSegments2.default)(g);\n  });\n  time('    order', function () {\n    (0, _order2.default)(g);\n  });\n  time('    insertSelfEdges', function () {\n    insertSelfEdges(g);\n  });\n  time('    adjustCoordinateSystem', function () {\n    _coordinateSystem2.default.adjust(g);\n  });\n  time('    position', function () {\n    (0, _position2.default)(g);\n  });\n  time('    positionSelfEdges', function () {\n    positionSelfEdges(g);\n  });\n  time('    removeBorderNodes', function () {\n    removeBorderNodes(g);\n  });\n  time('    normalize.undo', function () {\n    _normalize2.default.undo(g);\n  });\n  time('    fixupEdgeLabelCoords', function () {\n    fixupEdgeLabelCoords(g);\n  });\n  time('    undoCoordinateSystem', function () {\n    _coordinateSystem2.default.undo(g);\n  });\n  time('    translateGraph', function () {\n    translateGraph(g);\n  });\n  time('    assignNodeIntersects', function () {\n    assignNodeIntersects(g);\n  });\n  time('    reversePoints', function () {\n    reversePointsForReversedEdges(g);\n  });\n  time('    acyclic.undo', function () {\n    _acyclic2.default.undo(g);\n  });\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _lodash2.default.forEach(inputGraph.nodes(), function (v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _lodash2.default.forEach(inputGraph.edges(), function (e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (_lodash2.default.has(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' };\nvar graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align'];\nvar nodeNumAttrs = ['width', 'height'];\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset'];\nvar edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r'\n};\nvar edgeAttrs = ['labelpos'];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new _graphlib.Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(_lodash2.default.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _lodash2.default.pick(graph, graphAttrs)));\n\n  _lodash2.default.forEach(inputGraph.nodes(), function (v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _lodash2.default.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _lodash2.default.forEach(inputGraph.edges(), function (e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, _lodash2.default.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _lodash2.default.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      _util2.default.addDummyNode(g, 'edge-proxy', label, '_ep');\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = Math.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    getExtremes(g.node(v));\n  });\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (_lodash2.default.has(edge, 'x')) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _lodash2.default.forEach(edge.points, function (p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (_lodash2.default.has(edge, 'x')) {\n      edge.x -= minX;\n    }\n    if (_lodash2.default.has(edge, 'y')) {\n      edge.y -= minY;\n    }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1 = null;\n    var p2 = null;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(_util2.default.intersectRect(nodeV, p1));\n    edge.points.push(_util2.default.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (_lodash2.default.has(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n        case 'l':\n          edge.x -= edge.width / 2 + edge.labeloffset;break;\n        case 'r':\n          edge.x += edge.width / 2 + edge.labeloffset;break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_lodash2.default.last(node.borderLeft));\n      var r = g.node(_lodash2.default.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = _util2.default.buildLayerMatrix(g);\n  _lodash2.default.forEach(layers, function (layer) {\n    var orderShift = 0;\n    _lodash2.default.forEach(layer, function (v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _lodash2.default.forEach(node.selfEdges, function (selfEdge) {\n        _util2.default.addDummyNode(g, 'selfedge', {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + ++orderShift,\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, '_se');\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    if (node.dummy === 'selfedge') {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [{ x: x + 2 * dx / 3, y: y - dy }, { x: x + 5 * dx / 6, y: y - dy }, { x: x + dx, y: y }, { x: x + 5 * dx / 6, y: y + dy }, { x: x + 2 * dx / 3, y: y + dy }];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _lodash2.default.mapValues(_lodash2.default.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _lodash2.default.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n\nexports.default = layout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _greedyFas = __webpack_require__(8);\n\nvar _greedyFas2 = _interopRequireDefault(_greedyFas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction run(g) {\n  var fas = g.graph().acyclicer === 'greedy' ? (0, _greedyFas2.default)(g, weightFn(g)) : dfsFAS(g);\n  _lodash2.default.forEach(fas, function (e) {\n    var label = g.edge(e);\n    g.removeEdge(e);\n    label.forwardName = e.name;\n    label.reversed = true;\n    g.setEdge(e.w, e.v, label, _lodash2.default.uniqueId('rev'));\n  });\n\n  function weightFn(g) {\n    return function (e) {\n      return g.edge(e).weight;\n    };\n  }\n}\n\nfunction dfsFAS(g) {\n  var fas = [];\n  var stack = {};\n  var visited = {};\n\n  function dfs(v) {\n    if (_lodash2.default.has(visited, v)) {\n      return;\n    }\n    visited[v] = true;\n    stack[v] = true;\n    _lodash2.default.forEach(g.outEdges(v), function (e) {\n      if (_lodash2.default.has(stack, e.w)) {\n        fas.push(e);\n      } else {\n        dfs(e.w);\n      }\n    });\n    delete stack[v];\n  }\n\n  _lodash2.default.forEach(g.nodes(), dfs);\n  return fas;\n}\n\nfunction undo(g) {\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var label = g.edge(e);\n    if (label.reversed) {\n      g.removeEdge(e);\n\n      var forwardName = label.forwardName;\n      delete label.reversed;\n      delete label.forwardName;\n      g.setEdge(e.w, e.v, label, forwardName);\n    }\n  });\n}\n\nexports.default = {\n  run: run,\n  undo: undo\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _list = __webpack_require__(9);\n\nvar _list2 = _interopRequireDefault(_list);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\nvar DEFAULT_WEIGHT_FN = _lodash2.default.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _lodash2.default.flatten(_lodash2.default.map(results, function (e) {\n    return g.outEdges(e.v, e.w);\n  }), true);\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry = void 0;\n  while (g.nodeCount()) {\n    while (entry = sinks.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    while (entry = sources.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _lodash2.default.forEach(g.inEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _lodash2.default.forEach(g.outEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry['in'] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new _graphlib.Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, 'in': 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)['in'] += weight);\n  });\n\n  var buckets = _lodash2.default.range(maxOut + maxIn + 3).map(function () {\n    return new _list2.default();\n  });\n  var zeroIdx = maxIn + 1;\n\n  _lodash2.default.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry);\n  }\n}\n\nexports.default = greedyFAS;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nfunction List() {\n  var sentinel = {};\n  sentinel._next = sentinel._prev = sentinel;\n  this._sentinel = sentinel;\n}\n\nList.prototype.dequeue = function () {\n  var sentinel = this._sentinel;\n  var entry = sentinel._prev;\n  if (entry !== sentinel) {\n    unlink(entry);\n    return entry;\n  }\n};\n\nList.prototype.enqueue = function (entry) {\n  var sentinel = this._sentinel;\n  if (entry._prev && entry._next) {\n    unlink(entry);\n  }\n  entry._next = sentinel._next;\n  sentinel._next._prev = entry;\n  sentinel._next = entry;\n  entry._prev = sentinel;\n};\n\nList.prototype.toString = function () {\n  var strs = [];\n  var sentinel = this._sentinel;\n  var curr = sentinel._prev;\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks));\n    curr = curr._prev;\n  }\n  return '[' + strs.join(', ') + ']';\n};\n\nfunction unlink(entry) {\n  entry._prev._next = entry._next;\n  entry._next._prev = entry._prev;\n  delete entry._next;\n  delete entry._prev;\n}\n\nfunction filterOutLinks(k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v;\n  }\n}\n\nexports.default = List;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _lodash2.default.forEach(g.edges(), function (edge) {\n    normalizeEdge(g, edge);\n  });\n}\n\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  var dummy = void 0;\n  var attrs = void 0;\n  var i = void 0;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank\n    };\n    dummy = _util2.default.addDummyNode(g, 'edge', attrs, '_d');\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = 'edge-label';\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _lodash2.default.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w = null;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n\nexports.default = {\n  run: run,\n  undo: undo\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util = __webpack_require__(3);\n\nvar _feasibleTree = __webpack_require__(4);\n\nvar _feasibleTree2 = _interopRequireDefault(_feasibleTree);\n\nvar _networkSimplex = __webpack_require__(12);\n\nvar _networkSimplex2 = _interopRequireDefault(_networkSimplex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex':\n      networkSimplexRanker(g);break;\n    case 'tight-tree':\n      tightTreeRanker(g);break;\n    case 'longest-path':\n      longestPathRanker(g);break;\n    default:\n      networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = _util.longestPath;\n\nfunction tightTreeRanker(g) {\n  (0, _util.longestPath)(g);\n  (0, _feasibleTree2.default)(g);\n}\n\nfunction networkSimplexRanker(g) {\n  (0, _networkSimplex2.default)(g);\n}\n\nexports.default = rank;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _feasibleTree = __webpack_require__(4);\n\nvar _feasibleTree2 = _interopRequireDefault(_feasibleTree);\n\nvar _util = __webpack_require__(3);\n\nvar _util2 = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar preorder = _graphlib.alg.preorder,\n    postorder = _graphlib.alg.postorder;\n\n// Expose some internals for testing purposes\n\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = (0, _util2.simplify)(g);\n  (0, _util.longestPath)(g);\n  var t = (0, _feasibleTree2.default)(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e = void 0;\n  var f = void 0;\n  while (e = leaveEdge(t)) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _lodash2.default.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _lodash2.default.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child;\n    var other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail;\n      var otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _lodash2.default.forEach(tree.neighbors(v), function (w) {\n    if (!_lodash2.default.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _lodash2.default.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _lodash2.default.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _lodash2.default.minBy(candidates, function (edge) {\n    return (0, _util.slack)(g, edge);\n  });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _lodash2.default.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _lodash2.default.forEach(vs, function (v) {\n    var parent = t.node(v).parent;\n    var edge = g.edge(v, parent);\n    var flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n\nexports.default = networkSimplex;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _lodash2.default.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent = void 0;\n  var lca = void 0;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _lodash2.default.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _lodash2.default.forEach(g.children(), dfs);\n\n  return result;\n}\n\nexports.default = parentDummyChains;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = _util2.default.addDummyNode(g, 'root', {}, '_root');\n  var depths = treeDepths(g);\n  var height = _lodash2.default.max(_lodash2.default.values(depths)) - 1;\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _lodash2.default.forEach(g.edges(), function (e) {\n    g.edge(e).minlen *= nodeSep;\n  });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _lodash2.default.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = _util2.default.addBorderNode(g, '_bt');\n  var bottom = _util2.default.addBorderNode(g, '_bb');\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _lodash2.default.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _lodash2.default.forEach(children, function (child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _lodash2.default.forEach(g.children(), function (v) {\n    dfs(v, 1);\n  });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _lodash2.default.reduce(g.edges(), function (acc, e) {\n    return acc + g.edge(e).weight;\n  }, 0);\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n\nexports.default = {\n  run: run,\n  cleanup: cleanup\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    var children = g.children(v);\n    var node = g.node(v);\n    if (children.length) {\n      _lodash2.default.forEach(children, dfs);\n    }\n\n    if (_lodash2.default.has(node, 'minRank')) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank);\n        addBorderNode(g, 'borderRight', '_br', v, node, rank);\n      }\n    }\n  }\n\n  _lodash2.default.forEach(g.children(), dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  var label = { width: 0, height: 0, rank: rank, borderType: prop };\n  var prev = sgNode[prop][rank - 1];\n  var curr = _util2.default.addDummyNode(g, 'border', label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n\nexports.default = addBorderSegments;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction adjust(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g);\n  }\n}\n\nfunction undo(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g);\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g);\n    swapWidthHeight(g);\n  }\n}\n\nfunction swapWidthHeight(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    swapWidthHeightOne(g.node(v));\n  });\n  _lodash2.default.forEach(g.edges(), function (e) {\n    swapWidthHeightOne(g.edge(e));\n  });\n}\n\nfunction swapWidthHeightOne(attrs) {\n  var w = attrs.width;\n  attrs.width = attrs.height;\n  attrs.height = w;\n}\n\nfunction reverseY(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    reverseYOne(g.node(v));\n  });\n\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _lodash2.default.forEach(edge.points, reverseYOne);\n    if (_lodash2.default.has(edge, 'y')) {\n      reverseYOne(edge);\n    }\n  });\n}\n\nfunction reverseYOne(attrs) {\n  attrs.y = -attrs.y;\n}\n\nfunction swapXY(g) {\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    swapXYOne(g.node(v));\n  });\n\n  _lodash2.default.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    _lodash2.default.forEach(edge.points, swapXYOne);\n    if (_lodash2.default.has(edge, 'x')) {\n      swapXYOne(edge);\n    }\n  });\n}\n\nfunction swapXYOne(attrs) {\n  var x = attrs.x;\n  attrs.x = attrs.y;\n  attrs.y = x;\n}\n\nexports.default = {\n  adjust: adjust,\n  undo: undo\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _initOrder = __webpack_require__(18);\n\nvar _initOrder2 = _interopRequireDefault(_initOrder);\n\nvar _crossCount = __webpack_require__(19);\n\nvar _crossCount2 = _interopRequireDefault(_crossCount);\n\nvar _sortSubgraph = __webpack_require__(20);\n\nvar _sortSubgraph2 = _interopRequireDefault(_sortSubgraph);\n\nvar _buildLayerGraph = __webpack_require__(24);\n\nvar _buildLayerGraph2 = _interopRequireDefault(_buildLayerGraph);\n\nvar _addSubgraphConstraints = __webpack_require__(25);\n\nvar _addSubgraphConstraints2 = _interopRequireDefault(_addSubgraphConstraints);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = _util2.default.maxRank(g);\n  var downLayerGraphs = buildLayerGraphs(g, _lodash2.default.range(1, maxRank + 1), 'inEdges');\n  var upLayerGraphs = buildLayerGraphs(g, _lodash2.default.range(maxRank - 1, -1, -1), 'outEdges');\n\n  var layering = (0, _initOrder2.default)(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY;\n  var best = void 0;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = _util2.default.buildLayerMatrix(g);\n    var cc = (0, _crossCount2.default)(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _lodash2.default.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _lodash2.default.map(ranks, function (rank) {\n    return (0, _buildLayerGraph2.default)(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new _graphlib.Graph();\n  _lodash2.default.forEach(layerGraphs, function (lg) {\n    var root = lg.graph().root;\n    var sorted = (0, _sortSubgraph2.default)(lg, root, cg, biasRight);\n    _lodash2.default.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i;\n    });\n    (0, _addSubgraphConstraints2.default)(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _lodash2.default.forEach(layering, function (layer) {\n    _lodash2.default.forEach(layer, function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n\nexports.default = order;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder(g) {\n  var visited = {};\n  var simpleNodes = _lodash2.default.filter(g.nodes(), function (v) {\n    return !g.children(v).length;\n  });\n  var maxRank = _lodash2.default.max(_lodash2.default.map(simpleNodes, function (v) {\n    return g.node(v).rank;\n  }));\n  var layers = _lodash2.default.map(_lodash2.default.range(maxRank + 1), function () {\n    return [];\n  });\n\n  function dfs(v) {\n    if (_lodash2.default.has(visited, v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    layers[node.rank].push(v);\n    _lodash2.default.forEach(g.successors(v), dfs);\n  }\n\n  var orderedVs = _lodash2.default.sortBy(simpleNodes, function (v) {\n    return g.node(v).rank;\n  });\n  _lodash2.default.forEach(orderedVs, dfs);\n\n  return layers;\n}\n\nexports.default = initOrder;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _lodash2.default.zipObject(southLayer, _lodash2.default.map(southLayer, function (v, i) {\n    return i;\n  }));\n  var southEntries = _lodash2.default.flatten(_lodash2.default.map(northLayer, function (v) {\n    return _lodash2.default.chain(g.outEdges(v)).map(function (e) {\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\n    }).sortBy('pos').value();\n  }), true);\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1;\n  }\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _lodash2.default.map(new Array(treeSize), function () {\n    return 0;\n  });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _lodash2.default.forEach(southEntries.forEach(function (entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = index - 1 >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}\n\nexports.default = crossCount;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _barycenter = __webpack_require__(21);\n\nvar _barycenter2 = _interopRequireDefault(_barycenter);\n\nvar _resolveConflicts = __webpack_require__(22);\n\nvar _resolveConflicts2 = _interopRequireDefault(_resolveConflicts);\n\nvar _sort = __webpack_require__(23);\n\nvar _sort2 = _interopRequireDefault(_sort);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sortSubgraph(g, v, cg, biasRight) {\n  var movable = g.children(v);\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight : undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = _lodash2.default.filter(movable, function (w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = (0, _barycenter2.default)(g, movable);\n  _lodash2.default.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (_lodash2.default.has(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  var entries = (0, _resolveConflicts2.default)(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  var result = (0, _sort2.default)(entries, biasRight);\n\n  if (bl) {\n    result.vs = _lodash2.default.flatten([bl, result.vs, br], true);\n    if (g.predecessors(bl).length) {\n      var blPred = g.node(g.predecessors(bl)[0]);\n      var brPred = g.node(g.predecessors(br)[0]);\n      if (!_lodash2.default.has(result, 'barycenter')) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n}\n\nfunction expandSubgraphs(entries, subgraphs) {\n  _lodash2.default.forEach(entries, function (entry) {\n    entry.vs = _lodash2.default.flatten(entry.vs.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n      return v;\n    }), true);\n  });\n}\n\nfunction mergeBarycenters(target, other) {\n  if (!_lodash2.default.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n}\n\nexports.default = sortSubgraph;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction barycenter(g, movable) {\n  return _lodash2.default.map(movable, function (v) {\n    var inV = g.inEdges(v);\n    if (!inV.length) {\n      return { v: v };\n    } else {\n      var result = _lodash2.default.reduce(inV, function (acc, e) {\n        var edge = g.edge(e);\n        var nodeU = g.node(e.v);\n        return {\n          sum: acc.sum + edge.weight * nodeU.order,\n          weight: acc.weight + edge.weight\n        };\n      }, { sum: 0, weight: 0 });\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      };\n    }\n  });\n}\n\nexports.default = barycenter;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _lodash2.default.forEach(entries, function (entry, i) {\n    var tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      'in': [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (!_lodash2.default.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _lodash2.default.forEach(cg.edges(), function (e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_lodash2.default.isUndefined(entryV) && !_lodash2.default.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _lodash2.default.filter(mappedEntries, function (entry) {\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (_lodash2.default.isUndefined(uEntry.barycenter) || _lodash2.default.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _lodash2.default.forEach(entry['in'].reverse(), handleIn(entry));\n    _lodash2.default.forEach(entry.out, handleOut(entry));\n  }\n\n  return _lodash2.default.chain(entries).filter(function (entry) {\n    return !entry.merged;\n  }).map(function (entry) {\n    return _lodash2.default.pick(entry, ['vs', 'i', 'barycenter', 'weight']);\n  }).value();\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n\nexports.default = resolveConflicts;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sort(entries, biasRight) {\n  var parts = _util2.default.partition(entries, function (entry) {\n    return _lodash2.default.has(entry, 'barycenter');\n  });\n  var sortable = parts.lhs;\n  var unsortable = _lodash2.default.sortBy(parts.rhs, function (entry) {\n    return -entry.i;\n  });\n  var vs = [];\n  var sum = 0;\n  var weight = 0;\n  var vsIndex = 0;\n\n  sortable.sort(compareWithBias(!!biasRight));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  _lodash2.default.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  var result = { vs: _lodash2.default.flatten(vs, true) };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n}\n\nfunction consumeUnsortable(vs, unsortable, index) {\n  var last = void 0;\n  while (unsortable.length && (last = _lodash2.default.last(unsortable)).i <= index) {\n    unsortable.pop();\n    vs.push(last.vs);\n    index++;\n  }\n  return index;\n}\n\nfunction compareWithBias(bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n}\n\nexports.default = sort;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g);\n  var result = new _graphlib.Graph({ compound: true }).setGraph({ root: root }).setDefaultNodeLabel(function (v) {\n    return g.node(v);\n  });\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    var parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _lodash2.default.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v;\n        var edge = result.edge(u, v);\n        var weight = !_lodash2.default.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_lodash2.default.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v = void 0;\n  while (g.hasNode(v = _lodash2.default.uniqueId('_root'))) {}\n  return v;\n}\n\nexports.default = buildLayerGraph;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {};\n  var rootPrev = void 0;\n\n  _lodash2.default.forEach(vs, function (v) {\n    var child = g.parent(v);\n    var parent = void 0;\n    var prevChild = void 0;\n    while (child) {\n      parent = g.parent(child);\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n      child = parent;\n    }\n  });\n\n  /*\n  function dfs(v) {\n    const children = v ? g.children(v) : g.children();\n    if (children.length) {\n      const min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.forEach(children, function(child) {\n        const childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\nexports.default = addSubgraphConstraints;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _bk = __webpack_require__(27);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction position(g) {\n  g = _util2.default.asNonCompoundGraph(g);\n\n  positionY(g);\n  _lodash2.default.forEach((0, _bk.positionX)(g), function (x, v) {\n    g.node(v).x = x;\n  });\n}\n\nfunction positionY(g) {\n  var layering = _util2.default.buildLayerMatrix(g);\n  var rankSep = g.graph().ranksep;\n  var prevY = 0;\n  _lodash2.default.forEach(layering, function (layer) {\n    var maxHeight = _lodash2.default.max(_lodash2.default.map(layer, function (v) {\n      return g.node(v).height;\n    }));\n    _lodash2.default.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2;\n    });\n    prevY += maxHeight + rankSep;\n  });\n}\n\nexports.default = position;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.positionX = positionX;\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * This module provides coordinate assignment based on Brandes and Kpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    var k0 = 0;\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    var scanPos = 0;\n    var prevLayerLength = prevLayer.length;\n    var lastNode = _lodash2.default.last(layer);\n\n    _lodash2.default.forEach(layer, function (v, i) {\n      var w = findOtherInnerSegmentNode(g, v);\n      var k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _lodash2.default.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _lodash2.default.forEach(g.predecessors(scanNode), function (u) {\n            var uLabel = g.node(u);\n            var uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _lodash2.default.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v = void 0;\n    _lodash2.default.forEach(_lodash2.default.range(southPos, southEnd), function (i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _lodash2.default.forEach(g.predecessors(v), function (u) {\n          var uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1;\n    var nextNorthPos = void 0;\n    var southPos = 0;\n\n    _lodash2.default.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _lodash2.default.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _lodash2.default.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _lodash2.default.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {};\n  var align = {};\n  var pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _lodash2.default.forEach(layering, function (layer) {\n    _lodash2.default.forEach(layer, function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _lodash2.default.forEach(layering, function (layer) {\n    var prevIdx = -1;\n    _lodash2.default.forEach(layer, function (v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _lodash2.default.sortBy(ws, function (w) {\n          return pos[w];\n        });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {};\n  var blockG = buildBlockGraph(g, layering, root, reverseSep);\n\n  // First pass, assign smallest coordinates via DFS\n  var visited = {};\n  function pass1(v) {\n    if (!_lodash2.default.has(visited, v)) {\n      visited[v] = true;\n      xs[v] = _lodash2.default.reduce(blockG.inEdges(v), function (max, e) {\n        pass1(e.v);\n        return Math.max(max, xs[e.v] + blockG.edge(e));\n      }, 0);\n    }\n  }\n  _lodash2.default.forEach(blockG.nodes(), pass1);\n\n  var borderType = reverseSep ? 'borderLeft' : 'borderRight';\n  function pass2(v) {\n    if (visited[v] !== 2) {\n      visited[v]++;\n      var node = g.node(v);\n      var min = _lodash2.default.reduce(blockG.outEdges(v), function (min, e) {\n        pass2(e.w);\n        return Math.min(min, xs[e.w] - blockG.edge(e));\n      }, Number.POSITIVE_INFINITY);\n      if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n        xs[v] = Math.max(xs[v], min);\n      }\n    }\n  }\n  _lodash2.default.forEach(blockG.nodes(), pass2);\n\n  // Assign x coordinates to all nodes\n  _lodash2.default.forEach(align, function (v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new _graphlib.Graph();\n  var graphLabel = g.graph();\n  var sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _lodash2.default.forEach(layering, function (layer) {\n    var u = void 0;\n    _lodash2.default.forEach(layer, function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u];\n        var prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _lodash2.default.minBy(_lodash2.default.values(xss), function (xs) {\n    var min = (_lodash2.default.minBy(_lodash2.default.toPairs(xs), function (pair) {\n      return pair[1] - width(g, pair[0]) / 2;\n    }) || ['k', 0])[1];\n    var max = (_lodash2.default.maxBy(_lodash2.default.toPairs(xs), function (pair) {\n      return pair[1] + width(g, pair[0]) / 2;\n    }) || ['k', 0])[1];\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _lodash2.default.values(alignTo);\n  var alignToMin = _lodash2.default.min(alignToVals);\n  var alignToMax = _lodash2.default.max(alignToVals);\n\n  _lodash2.default.forEach(['u', 'd'], function (vert) {\n    _lodash2.default.forEach(['l', 'r'], function (horiz) {\n      var alignment = vert + horiz;\n      var xs = xss[alignment];\n      if (xs === alignTo) {\n        return;\n      }\n      var xsVals = _lodash2.default.values(xs);\n      var delta = horiz === 'l' ? alignToMin - _lodash2.default.min(xsVals) : alignToMax - _lodash2.default.max(xsVals);\n      if (delta) {\n        xss[alignment] = _lodash2.default.mapValues(xs, function (x) {\n          return x + delta;\n        });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _lodash2.default.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _lodash2.default.sortBy(_lodash2.default.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = _util2.default.buildLayerMatrix(g);\n  var conflicts = _lodash2.default.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering = void 0;\n  _lodash2.default.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _lodash2.default.values(layering).reverse();\n    _lodash2.default.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _lodash2.default.map(adjustedLayering, function (inner) {\n          return _lodash2.default.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = _lodash2.default.bind(vert === 'u' ? g.predecessors : g.successors, g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === 'r');\n      if (horiz === 'r') {\n        xs = _lodash2.default.mapValues(xs, function (x) {\n          return -x;\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta = void 0;\n\n    sum += vLabel.width / 2;\n    if (_lodash2.default.has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = -vLabel.width / 2;break;\n        case 'r':\n          delta = vLabel.width / 2;break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_lodash2.default.has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l':\n          delta = wLabel.width / 2;break;\n        case 'r':\n          delta = -wLabel.width / 2;break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n\nexports.default = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = __webpack_require__(0);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _graphlib = __webpack_require__(2);\n\nvar _util = __webpack_require__(1);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* istanbul ignore next */\nfunction debugOrdering(g) {\n  var layerMatrix = _util2.default.buildLayerMatrix(g);\n\n  var h = new _graphlib.Graph({ compound: true, multigraph: true }).setGraph({});\n\n  _lodash2.default.forEach(g.nodes(), function (v) {\n    h.setNode(v, { label: v });\n    h.setParent(v, 'layer' + g.node(v).rank);\n  });\n\n  _lodash2.default.forEach(g.edges(), function (e) {\n    h.setEdge(e.v, e.w, {}, e.name);\n  });\n\n  _lodash2.default.forEach(layerMatrix, function (layer, i) {\n    var layerV = 'layer' + i;\n    h.setNode(layerV, { rank: 'same' });\n    _lodash2.default.reduce(layer, function (u, v) {\n      h.setEdge(u, v, { style: 'invis' });\n      return v;\n    });\n  });\n\n  return h;\n}\n\nexports.default = {\n  debugOrdering: debugOrdering\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\"name\":\"dagre-layout\",\"version\":\"0.8.4\",\"description\":\"Graph layout for JavaScript\",\"author\":\"Tyler Long <tyler4long@gmail.com>\",\"main\":\"dist/dagre-layout.core.js\",\"keywords\":[\"graph\",\"layout\",\"dagre\"],\"scripts\":{\"lint\":\"standard\",\"jest\":\"jest --coverage\",\"karma\":\"node -r babel-register node_modules/.bin/karma start\",\"test\":\"yarn lint && yarn jest && yarn karma --single-run\",\"bench\":\"node -r babel-register src/bench.js\",\"build\":\"webpack --progress --colors\",\"build:watch\":\"yarn build --watch\",\"release\":\"yarn build -p\",\"upgrade\":\"yarn-upgrade-all\",\"prepush\":\"yarn test\",\"prepublishOnly\":\"yarn release\"},\"dependencies\":{\"graphlib\":\"^2.1.5\",\"lodash\":\"^4.17.5\"},\"devDependencies\":{\"babel-core\":\"^6.26.0\",\"babel-loader\":\"^7.1.2\",\"babel-preset-env\":\"^1.6.1\",\"benchmark\":\"^2.1.4\",\"chai\":\"^4.1.2\",\"coveralls\":\"^3.0.0\",\"husky\":\"^0.14.3\",\"jest\":\"^22.2.2\",\"karma\":\"^2.0.0\",\"karma-chrome-launcher\":\"^2.2.0\",\"karma-firefox-launcher\":\"^1.1.0\",\"karma-mocha\":\"^1.3.0\",\"karma-safari-launcher\":\"^1.0.0\",\"mocha\":\"^5.0.0\",\"sprintf\":\"^0.1.5\",\"standard\":\"^10.0.3\",\"webpack\":\"^3.11.0\",\"webpack-node-externals\":\"^1.6.0\",\"yarn-upgrade-all\":\"^0.3.0\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/tylingsoft/dagre-layout.git\"},\"license\":\"MIT\",\"files\":[\"dist/\",\"lib/\",\"index.js\"],\"standard\":{\"ignore\":[\"dist/**/*.js\",\"coverage/**/*.js\"]},\"jest\":{\"testRegex\":\"test/.+?-test\\\\.js\",\"testPathIgnorePatterns\":[\"test/bundle-test\\\\.js\"]}}\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// dagre-layout.core.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fed9e374209623a47960","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 0\n// module chunks = 0","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nexport function addDummyNode (g, type, attrs, name) {\n  let v\n  do {\n    v = _.uniqueId(name)\n  } while (g.hasNode(v))\n\n  attrs.dummy = type\n  g.setNode(v, attrs)\n  return v\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nexport function simplify (g) {\n  const simplified = new Graph().setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) { simplified.setNode(v, g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 }\n    const label = g.edge(e)\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    })\n  })\n  return simplified\n}\n\nexport function asNonCompoundGraph (g) {\n  const simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v))\n    }\n  })\n  _.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e))\n  })\n  return simplified\n}\n\nexport function successorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const sucs = {}\n    _.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight\n    })\n    return sucs\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\nexport function predecessorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const preds = {}\n    _.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight\n    })\n    return preds\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nexport function intersectRect (rect, point) {\n  const x = rect.x\n  const y = rect.y\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = point.x - x\n  const dy = point.y - y\n  let w = rect.width / 2\n  let h = rect.height / 2\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle')\n  }\n\n  let sx\n  let sy\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h\n    }\n    sx = h * dx / dy\n    sy = h\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w\n    }\n    sx = w\n    sy = w * dy / dx\n  }\n\n  return { x: x + sx, y: y + sy }\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nexport function buildLayerMatrix (g) {\n  const layering = _.map(_.range(maxRank(g) + 1), function () { return [] })\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const rank = node.rank\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v\n    }\n  })\n  return layering\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nexport function normalizeRanks (g) {\n  const min = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (_.has(node, 'rank')) {\n      node.rank -= min\n    }\n  })\n}\n\nexport function removeEmptyRanks (g) {\n  // Ranks may not start at 0, so we need to offset them\n  const offset = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n\n  const layers = []\n  _.forEach(g.nodes(), function (v) {\n    const rank = g.node(v).rank - offset\n    if (!layers[rank]) {\n      layers[rank] = []\n    }\n    layers[rank].push(v)\n  })\n\n  let delta = 0\n  const nodeRankFactor = g.graph().nodeRankFactor\n  _.forEach(layers, function (vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta\n    } else if (delta) {\n      _.forEach(vs, function (v) { g.node(v).rank += delta })\n    }\n  })\n}\n\nexport function addBorderNode (g, prefix, rank, order) {\n  const node = {\n    width: 0,\n    height: 0\n  }\n  if (arguments.length >= 4) {\n    node.rank = rank\n    node.order = order\n  }\n  return addDummyNode(g, 'border', node, prefix)\n}\n\nexport function maxRank (g) {\n  return _.max(_.map(g.nodes(), function (v) {\n    const rank = g.node(v).rank\n    if (!_.isUndefined(rank)) {\n      return rank\n    }\n  }))\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nexport function partition (collection, fn) {\n  const result = { lhs: [], rhs: [] }\n  _.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value)\n    } else {\n      result.rhs.push(value)\n    }\n  })\n  return result\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nexport function time (name, fn) {\n  const start = _.now()\n  try {\n    return fn()\n  } finally {\n    console.log(name + ' time: ' + (_.now() - start) + 'ms')\n  }\n}\n\nexport function notime (name, fn) {\n  return fn()\n}\n\nexport default {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/util.js","module.exports = require(\"graphlib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"graphlib\"\n// module id = 2\n// module chunks = 0","import _ from 'lodash'\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nexport function longestPath (g) {\n  const visited = {}\n\n  function dfs (v) {\n    const label = g.node(v)\n    if (_.has(visited, v)) {\n      return label.rank\n    }\n    visited[v] = true\n\n    const rank = _.min(_.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen\n    })) || 0\n\n    return (label.rank = rank)\n  }\n\n  _.forEach(g.sources(), dfs)\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nexport function slack (g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen\n}\n\nexport default {\n  longestPath: longestPath,\n  slack: slack\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/rank/util.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport { slack } from './util'\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree (g) {\n  const t = new Graph({ directed: false })\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0]\n  const size = g.nodeCount()\n  t.setNode(start, {})\n\n  let edge\n  let delta\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g)\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge)\n    shiftRanks(t, g, delta)\n  }\n\n  return t\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree (t, g) {\n  function dfs (v) {\n    _.forEach(g.nodeEdges(v), function (e) {\n      const edgeV = e.v\n      const w = (v === edgeV) ? e.w : edgeV\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {})\n        t.setEdge(v, w, {})\n        dfs(w)\n      }\n    })\n  }\n\n  _.forEach(t.nodes(), dfs)\n  return t.nodeCount()\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge (t, g) {\n  return _.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e)\n    }\n  })\n}\n\nfunction shiftRanks (t, g, delta) {\n  _.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta\n  })\n}\n\nexport default feasibleTree\n\n\n\n// WEBPACK FOOTER //\n// ./lib/rank/feasible-tree.js","import graphlib from 'graphlib'\n\nimport layout from './lib/layout'\nimport debug from './lib/debug'\nimport util from './lib/util'\nimport { version } from './package.json'\n\nexport default {\n  graphlib,\n  layout,\n  debug,\n  util: {\n    time: util.time,\n    notime: util.notime\n  },\n  version\n}\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport acyclic from './acyclic'\nimport normalize from './normalize'\nimport rank from './rank'\nimport util, { normalizeRanks, removeEmptyRanks } from './util'\nimport parentDummyChains from './parent-dummy-chains'\nimport nestingGraph from './nesting-graph'\nimport addBorderSegments from './add-border-segments'\nimport coordinateSystem from './coordinate-system'\nimport order from './order'\nimport position from './position'\n\nfunction layout (g, opts) {\n  const time = opts && opts.debugTiming ? util.time : util.notime\n  time('layout', function () {\n    const layoutGraph = time('  buildLayoutGraph',\n                               function () { return buildLayoutGraph(g) })\n    time('  runLayout', function () { runLayout(layoutGraph, time) })\n    time('  updateInputGraph', function () { updateInputGraph(g, layoutGraph) })\n  })\n}\n\nfunction runLayout (g, time) {\n  time('    makeSpaceForEdgeLabels', function () { makeSpaceForEdgeLabels(g) })\n  time('    removeSelfEdges', function () { removeSelfEdges(g) })\n  time('    acyclic', function () { acyclic.run(g) })\n  time('    nestingGraph.run', function () { nestingGraph.run(g) })\n  time('    rank', function () { rank(util.asNonCompoundGraph(g)) })\n  time('    injectEdgeLabelProxies', function () { injectEdgeLabelProxies(g) })\n  time('    removeEmptyRanks', function () { removeEmptyRanks(g) })\n  time('    nestingGraph.cleanup', function () { nestingGraph.cleanup(g) })\n  time('    normalizeRanks', function () { normalizeRanks(g) })\n  time('    assignRankMinMax', function () { assignRankMinMax(g) })\n  time('    removeEdgeLabelProxies', function () { removeEdgeLabelProxies(g) })\n  time('    normalize.run', function () { normalize.run(g) })\n  time('    parentDummyChains', function () { parentDummyChains(g) })\n  time('    addBorderSegments', function () { addBorderSegments(g) })\n  time('    order', function () { order(g) })\n  time('    insertSelfEdges', function () { insertSelfEdges(g) })\n  time('    adjustCoordinateSystem', function () { coordinateSystem.adjust(g) })\n  time('    position', function () { position(g) })\n  time('    positionSelfEdges', function () { positionSelfEdges(g) })\n  time('    removeBorderNodes', function () { removeBorderNodes(g) })\n  time('    normalize.undo', function () { normalize.undo(g) })\n  time('    fixupEdgeLabelCoords', function () { fixupEdgeLabelCoords(g) })\n  time('    undoCoordinateSystem', function () { coordinateSystem.undo(g) })\n  time('    translateGraph', function () { translateGraph(g) })\n  time('    assignNodeIntersects', function () { assignNodeIntersects(g) })\n  time('    reversePoints', function () { reversePointsForReversedEdges(g) })\n  time('    acyclic.undo', function () { acyclic.undo(g) })\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph (inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    const inputLabel = inputGraph.node(v)\n    const layoutLabel = layoutGraph.node(v)\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width\n        inputLabel.height = layoutLabel.height\n      }\n    }\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const inputLabel = inputGraph.edge(e)\n    const layoutLabel = layoutGraph.edge(e)\n\n    inputLabel.points = layoutLabel.points\n    if (_.has(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n    }\n  })\n\n  inputGraph.graph().width = layoutGraph.graph().width\n  inputGraph.graph().height = layoutGraph.graph().height\n}\n\nconst graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy']\nconst graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' }\nconst graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align']\nconst nodeNumAttrs = ['width', 'height']\nconst nodeDefaults = { width: 0, height: 0 }\nconst edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset']\nconst edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r'\n}\nconst edgeAttrs = ['labelpos']\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph (inputGraph) {\n  const g = new Graph({ multigraph: true, compound: true })\n  const graph = canonicalize(inputGraph.graph())\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)))\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    const node = canonicalize(inputGraph.node(v))\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults))\n    g.setParent(v, inputGraph.parent(v))\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const edge = canonicalize(inputGraph.edge(e))\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)))\n  })\n\n  return g\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels (g) {\n  const graph = g.graph()\n  graph.ranksep /= 2\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    edge.minlen *= 2\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset\n      } else {\n        edge.height += edge.labeloffset\n      }\n    }\n  })\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.width && edge.height) {\n      const v = g.node(e.v)\n      const w = g.node(e.w)\n      const label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e }\n      util.addDummyNode(g, 'edge-proxy', label, '_ep')\n    }\n  })\n}\n\nfunction assignRankMinMax (g) {\n  let maxRank = 0\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank\n      node.maxRank = g.node(node.borderBottom).rank\n      maxRank = Math.max(maxRank, node.maxRank)\n    }\n  })\n  g.graph().maxRank = maxRank\n}\n\nfunction removeEdgeLabelProxies (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction translateGraph (g) {\n  let minX = Number.POSITIVE_INFINITY\n  let maxX = 0\n  let minY = Number.POSITIVE_INFINITY\n  let maxY = 0\n  const graphLabel = g.graph()\n  const marginX = graphLabel.marginx || 0\n  const marginY = graphLabel.marginy || 0\n\n  function getExtremes (attrs) {\n    const x = attrs.x\n    const y = attrs.y\n    const w = attrs.width\n    const h = attrs.height\n    minX = Math.min(minX, x - w / 2)\n    maxX = Math.max(maxX, x + w / 2)\n    minY = Math.min(minY, y - h / 2)\n    maxY = Math.max(maxY, y + h / 2)\n  }\n\n  _.forEach(g.nodes(), function (v) { getExtremes(g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      getExtremes(edge)\n    }\n  })\n\n  minX -= marginX\n  minY -= marginY\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    node.x -= minX\n    node.y -= minY\n  })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, function (p) {\n      p.x -= minX\n      p.y -= minY\n    })\n    if (_.has(edge, 'x')) { edge.x -= minX }\n    if (_.has(edge, 'y')) { edge.y -= minY }\n  })\n\n  graphLabel.width = maxX - minX + marginX\n  graphLabel.height = maxY - minY + marginY\n}\n\nfunction assignNodeIntersects (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    const nodeV = g.node(e.v)\n    const nodeW = g.node(e.w)\n    let p1 = null\n    let p2 = null\n    if (!edge.points) {\n      edge.points = []\n      p1 = nodeW\n      p2 = nodeV\n    } else {\n      p1 = edge.points[0]\n      p2 = edge.points[edge.points.length - 1]\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1))\n    edge.points.push(util.intersectRect(nodeW, p2))\n  })\n}\n\nfunction fixupEdgeLabelCoords (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset\n      }\n      switch (edge.labelpos) {\n        case 'l': edge.x -= edge.width / 2 + edge.labeloffset; break\n        case 'r': edge.x += edge.width / 2 + edge.labeloffset; break\n      }\n    }\n  })\n}\n\nfunction reversePointsForReversedEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.reversed) {\n      edge.points.reverse()\n    }\n  })\n}\n\nfunction removeBorderNodes (g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      const node = g.node(v)\n      const t = g.node(node.borderTop)\n      const b = g.node(node.borderBottom)\n      const l = g.node(_.last(node.borderLeft))\n      const r = g.node(_.last(node.borderRight))\n\n      node.width = Math.abs(r.x - l.x)\n      node.height = Math.abs(b.y - t.y)\n      node.x = l.x + node.width / 2\n      node.y = t.y + node.height / 2\n    }\n  })\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction removeSelfEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      const node = g.node(e.v)\n      if (!node.selfEdges) {\n        node.selfEdges = []\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) })\n      g.removeEdge(e)\n    }\n  })\n}\n\nfunction insertSelfEdges (g) {\n  const layers = util.buildLayerMatrix(g)\n  _.forEach(layers, function (layer) {\n    let orderShift = 0\n    _.forEach(layer, function (v, i) {\n      const node = g.node(v)\n      node.order = i + orderShift\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(g, 'selfedge', {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, '_se')\n      })\n      delete node.selfEdges\n    })\n  })\n}\n\nfunction positionSelfEdges (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'selfedge') {\n      const selfNode = g.node(node.e.v)\n      const x = selfNode.x + selfNode.width / 2\n      const y = selfNode.y\n      const dx = node.x - x\n      const dy = selfNode.height / 2\n      g.setEdge(node.e, node.label)\n      g.removeNode(v)\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x + dx, y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ]\n      node.label.x = node.x\n      node.label.y = node.y\n    }\n  })\n}\n\nfunction selectNumberAttrs (obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number)\n}\n\nfunction canonicalize (attrs) {\n  const newAttrs = {}\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v\n  })\n  return newAttrs\n}\n\nexport default layout\n\n\n\n// WEBPACK FOOTER //\n// ./lib/layout.js","import _ from 'lodash'\n\nimport greedyFAS from './greedy-fas'\n\nfunction run (g) {\n  const fas = (g.graph().acyclicer === 'greedy'\n                ? greedyFAS(g, weightFn(g))\n                : dfsFAS(g))\n  _.forEach(fas, function (e) {\n    const label = g.edge(e)\n    g.removeEdge(e)\n    label.forwardName = e.name\n    label.reversed = true\n    g.setEdge(e.w, e.v, label, _.uniqueId('rev'))\n  })\n\n  function weightFn (g) {\n    return function (e) {\n      return g.edge(e).weight\n    }\n  }\n}\n\nfunction dfsFAS (g) {\n  const fas = []\n  const stack = {}\n  const visited = {}\n\n  function dfs (v) {\n    if (_.has(visited, v)) {\n      return\n    }\n    visited[v] = true\n    stack[v] = true\n    _.forEach(g.outEdges(v), function (e) {\n      if (_.has(stack, e.w)) {\n        fas.push(e)\n      } else {\n        dfs(e.w)\n      }\n    })\n    delete stack[v]\n  }\n\n  _.forEach(g.nodes(), dfs)\n  return fas\n}\n\nfunction undo (g) {\n  _.forEach(g.edges(), function (e) {\n    const label = g.edge(e)\n    if (label.reversed) {\n      g.removeEdge(e)\n\n      const forwardName = label.forwardName\n      delete label.reversed\n      delete label.forwardName\n      g.setEdge(e.w, e.v, label, forwardName)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/acyclic.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport List from './data/list'\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\nconst DEFAULT_WEIGHT_FN = _.constant(1)\n\nfunction greedyFAS (g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return []\n  }\n  const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN)\n  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx)\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function (e) {\n    return g.outEdges(e.v, e.w)\n  }), true)\n}\n\nfunction doGreedyFAS (g, buckets, zeroIdx) {\n  let results = []\n  const sources = buckets[buckets.length - 1]\n  const sinks = buckets[0]\n\n  let entry\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    if (g.nodeCount()) {\n      for (let i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue()\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true))\n          break\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nfunction removeNode (g, buckets, zeroIdx, entry, collectPredecessors) {\n  const results = collectPredecessors ? [] : undefined\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const uEntry = g.node(edge.v)\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w })\n    }\n\n    uEntry.out -= weight\n    assignBucket(buckets, zeroIdx, uEntry)\n  })\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const w = edge.w\n    const wEntry = g.node(w)\n    wEntry['in'] -= weight\n    assignBucket(buckets, zeroIdx, wEntry)\n  })\n\n  g.removeNode(entry.v)\n\n  return results\n}\n\nfunction buildState (g, weightFn) {\n  const fasGraph = new Graph()\n  let maxIn = 0\n  let maxOut = 0\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, 'in': 0, out: 0 })\n  })\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function (e) {\n    const prevWeight = fasGraph.edge(e.v, e.w) || 0\n    const weight = weightFn(e)\n    const edgeWeight = prevWeight + weight\n    fasGraph.setEdge(e.v, e.w, edgeWeight)\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight)\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)['in'] += weight)\n  })\n\n  const buckets = _.range(maxOut + maxIn + 3).map(function () { return new List() })\n  const zeroIdx = maxIn + 1\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v))\n  })\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx }\n}\n\nfunction assignBucket (buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry)\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry)\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry)\n  }\n}\n\nexport default greedyFAS\n\n\n\n// WEBPACK FOOTER //\n// ./lib/greedy-fas.js","/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nfunction List () {\n  const sentinel = {}\n  sentinel._next = sentinel._prev = sentinel\n  this._sentinel = sentinel\n}\n\nList.prototype.dequeue = function () {\n  const sentinel = this._sentinel\n  const entry = sentinel._prev\n  if (entry !== sentinel) {\n    unlink(entry)\n    return entry\n  }\n}\n\nList.prototype.enqueue = function (entry) {\n  const sentinel = this._sentinel\n  if (entry._prev && entry._next) {\n    unlink(entry)\n  }\n  entry._next = sentinel._next\n  sentinel._next._prev = entry\n  sentinel._next = entry\n  entry._prev = sentinel\n}\n\nList.prototype.toString = function () {\n  const strs = []\n  const sentinel = this._sentinel\n  let curr = sentinel._prev\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks))\n    curr = curr._prev\n  }\n  return '[' + strs.join(', ') + ']'\n}\n\nfunction unlink (entry) {\n  entry._prev._next = entry._next\n  entry._next._prev = entry._prev\n  delete entry._next\n  delete entry._prev\n}\n\nfunction filterOutLinks (k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v\n  }\n}\n\nexport default List\n\n\n\n// WEBPACK FOOTER //\n// ./lib/data/list.js","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run (g) {\n  g.graph().dummyChains = []\n  _.forEach(g.edges(), function (edge) { normalizeEdge(g, edge) })\n}\n\nfunction normalizeEdge (g, e) {\n  let v = e.v\n  let vRank = g.node(v).rank\n  const w = e.w\n  const wRank = g.node(w).rank\n  const name = e.name\n  const edgeLabel = g.edge(e)\n  const labelRank = edgeLabel.labelRank\n\n  if (wRank === vRank + 1) return\n\n  g.removeEdge(e)\n\n  let dummy\n  let attrs\n  let i\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = []\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank\n    }\n    dummy = util.addDummyNode(g, 'edge', attrs, '_d')\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width\n      attrs.height = edgeLabel.height\n      attrs.dummy = 'edge-label'\n      attrs.labelpos = edgeLabel.labelpos\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name)\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy)\n    }\n    v = dummy\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name)\n}\n\nfunction undo (g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const origLabel = node.edgeLabel\n    let w = null\n    g.setEdge(node.edgeObj, origLabel)\n    while (node.dummy) {\n      w = g.successors(v)[0]\n      g.removeNode(v)\n      origLabel.points.push({ x: node.x, y: node.y })\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x\n        origLabel.y = node.y\n        origLabel.width = node.width\n        origLabel.height = node.height\n      }\n      v = w\n      node = g.node(v)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/normalize.js","import { longestPath } from './util'\nimport feasibleTree from './feasible-tree'\nimport networkSimplex from './network-simplex'\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank (g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex': networkSimplexRanker(g); break\n    case 'tight-tree': tightTreeRanker(g); break\n    case 'longest-path': longestPathRanker(g); break\n    default: networkSimplexRanker(g)\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nconst longestPathRanker = longestPath\n\nfunction tightTreeRanker (g) {\n  longestPath(g)\n  feasibleTree(g)\n}\n\nfunction networkSimplexRanker (g) {\n  networkSimplex(g)\n}\n\nexport default rank\n\n\n\n// WEBPACK FOOTER //\n// ./lib/rank/index.js","import _ from 'lodash'\nimport { alg } from 'graphlib'\n\nimport feasibleTree from './feasible-tree'\nimport { slack, longestPath as initRank } from './util'\nimport { simplify } from '../util'\n\nconst { preorder, postorder } = alg\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues\nnetworkSimplex.initCutValues = initCutValues\nnetworkSimplex.calcCutValue = calcCutValue\nnetworkSimplex.leaveEdge = leaveEdge\nnetworkSimplex.enterEdge = enterEdge\nnetworkSimplex.exchangeEdges = exchangeEdges\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex (g) {\n  g = simplify(g)\n  initRank(g)\n  const t = feasibleTree(g)\n  initLowLimValues(t)\n  initCutValues(t, g)\n\n  let e\n  let f\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e)\n    exchangeEdges(t, g, e, f)\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues (t, g) {\n  let vs = postorder(t, t.nodes())\n  vs = vs.slice(0, vs.length - 1)\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v)\n  })\n}\n\nfunction assignCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child)\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n      // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true\n      // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.edge(child, parent)\n      // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0\n\n  if (!graphEdge) {\n    childIsTail = false\n    graphEdge = g.edge(parent, child)\n  }\n\n  cutValue = graphEdge.weight\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    const isOutEdge = e.v === child\n    const other = isOutEdge ? e.w : e.v\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail\n      const otherWeight = g.edge(e).weight\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edge(child, other).cutvalue\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue\n      }\n    }\n  })\n\n  return cutValue\n}\n\nfunction initLowLimValues (tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0]\n  }\n  dfsAssignLowLim(tree, {}, 1, root)\n}\n\nfunction dfsAssignLowLim (tree, visited, nextLim, v, parent) {\n  const low = nextLim\n  const label = tree.node(v)\n\n  visited[v] = true\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v)\n    }\n  })\n\n  label.low = low\n  label.lim = nextLim++\n  if (parent) {\n    label.parent = parent\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent\n  }\n\n  return nextLim\n}\n\nfunction leaveEdge (tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0\n  })\n}\n\nfunction enterEdge (t, g, edge) {\n  let v = edge.v\n  let w = edge.w\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w\n    w = edge.v\n  }\n\n  const vLabel = t.node(v)\n  const wLabel = t.node(w)\n  let tailLabel = vLabel\n  let flip = false\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel\n    flip = true\n  }\n\n  const candidates = _.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel)\n  })\n\n  return _.minBy(candidates, function (edge) { return slack(g, edge) })\n}\n\nfunction exchangeEdges (t, g, e, f) {\n  const v = e.v\n  const w = e.w\n  t.removeEdge(v, w)\n  t.setEdge(f.v, f.w, {})\n  initLowLimValues(t)\n  initCutValues(t, g)\n  updateRanks(t, g)\n}\n\nfunction updateRanks (t, g) {\n  const root = _.find(t.nodes(), function (v) { return !g.node(v).parent })\n  let vs = preorder(t, root)\n  vs = vs.slice(1)\n  _.forEach(vs, function (v) {\n    const parent = t.node(v).parent\n    let edge = g.edge(v, parent)\n    let flipped = false\n\n    if (!edge) {\n      edge = g.edge(parent, v)\n      flipped = true\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen)\n  })\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge (tree, u, v) {\n  return tree.hasEdge(u, v)\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim\n}\n\nexport default networkSimplex\n\n\n\n// WEBPACK FOOTER //\n// ./lib/rank/network-simplex.js","import _ from 'lodash'\n\nfunction parentDummyChains (g) {\n  const postorderNums = postorder(g)\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const edgeObj = node.edgeObj\n    const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w)\n    const path = pathData.path\n    const lca = pathData.lca\n    let pathIdx = 0\n    let pathV = path[pathIdx]\n    let ascending = true\n\n    while (v !== edgeObj.w) {\n      node = g.node(v)\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++\n        }\n\n        if (pathV === lca) {\n          ascending = false\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++\n        }\n        pathV = path[pathIdx]\n      }\n\n      g.setParent(v, pathV)\n      v = g.successors(v)[0]\n    }\n  })\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath (g, postorderNums, v, w) {\n  const vPath = []\n  const wPath = []\n  const low = Math.min(postorderNums[v].low, postorderNums[w].low)\n  const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim)\n  let parent\n  let lca\n\n  // Traverse up from v to find the LCA\n  parent = v\n  do {\n    parent = g.parent(parent)\n    vPath.push(parent)\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim))\n  lca = parent\n\n  // Traverse from w to LCA\n  parent = w\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent)\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca }\n}\n\nfunction postorder (g) {\n  const result = {}\n  let lim = 0\n\n  function dfs (v) {\n    const low = lim\n    _.forEach(g.children(v), dfs)\n    result[v] = { low: low, lim: lim++ }\n  }\n  _.forEach(g.children(), dfs)\n\n  return result\n}\n\nexport default parentDummyChains\n\n\n\n// WEBPACK FOOTER //\n// ./lib/parent-dummy-chains.js","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run (g) {\n  const root = util.addDummyNode(g, 'root', {}, '_root')\n  const depths = treeDepths(g)\n  const height = _.max(_.values(depths)) - 1\n  const nodeSep = 2 * height + 1\n\n  g.graph().nestingRoot = root\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function (e) { g.edge(e).minlen *= nodeSep })\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  const weight = sumWeights(g) + 1\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n  })\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep\n}\n\nfunction dfs (g, root, nodeSep, weight, height, depths, v) {\n  const children = g.children(v)\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep })\n    }\n    return\n  }\n\n  const top = util.addBorderNode(g, '_bt')\n  const bottom = util.addBorderNode(g, '_bb')\n  const label = g.node(v)\n\n  g.setParent(top, v)\n  label.borderTop = top\n  g.setParent(bottom, v)\n  label.borderBottom = bottom\n\n  _.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n\n    const childNode = g.node(child)\n    const childTop = childNode.borderTop ? childNode.borderTop : child\n    const childBottom = childNode.borderBottom ? childNode.borderBottom : child\n    const thisWeight = childNode.borderTop ? weight : 2 * weight\n    const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n  })\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] })\n  }\n}\n\nfunction treeDepths (g) {\n  const depths = {}\n  function dfs (v, depth) {\n    const children = g.children(v)\n    if (children && children.length) {\n      _.forEach(children, function (child) {\n        dfs(child, depth + 1)\n      })\n    }\n    depths[v] = depth\n  }\n  _.forEach(g.children(), function (v) { dfs(v, 1) })\n  return depths\n}\n\nfunction sumWeights (g) {\n  return _.reduce(g.edges(), function (acc, e) {\n    return acc + g.edge(e).weight\n  }, 0)\n}\n\nfunction cleanup (g) {\n  const graphLabel = g.graph()\n  g.removeNode(graphLabel.nestingRoot)\n  delete graphLabel.nestingRoot\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.nestingEdge) {\n      g.removeEdge(e)\n    }\n  })\n}\n\nexport default {\n  run,\n  cleanup\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/nesting-graph.js","import _ from 'lodash'\n\nimport util from './util'\n\nfunction addBorderSegments (g) {\n  function dfs (v) {\n    const children = g.children(v)\n    const node = g.node(v)\n    if (children.length) {\n      _.forEach(children, dfs)\n    }\n\n    if (_.has(node, 'minRank')) {\n      node.borderLeft = []\n      node.borderRight = []\n      for (let rank = node.minRank, maxRank = node.maxRank + 1;\n           rank < maxRank;\n           ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank)\n        addBorderNode(g, 'borderRight', '_br', v, node, rank)\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs)\n}\n\nfunction addBorderNode (g, prop, prefix, sg, sgNode, rank) {\n  const label = { width: 0, height: 0, rank: rank, borderType: prop }\n  const prev = sgNode[prop][rank - 1]\n  const curr = util.addDummyNode(g, 'border', label, prefix)\n  sgNode[prop][rank] = curr\n  g.setParent(curr, sg)\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 })\n  }\n}\n\nexport default addBorderSegments\n\n\n\n// WEBPACK FOOTER //\n// ./lib/add-border-segments.js","import _ from 'lodash'\n\nfunction adjust (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g)\n  }\n}\n\nfunction undo (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g)\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g)\n    swapWidthHeight(g)\n  }\n}\n\nfunction swapWidthHeight (g) {\n  _.forEach(g.nodes(), function (v) { swapWidthHeightOne(g.node(v)) })\n  _.forEach(g.edges(), function (e) { swapWidthHeightOne(g.edge(e)) })\n}\n\nfunction swapWidthHeightOne (attrs) {\n  const w = attrs.width\n  attrs.width = attrs.height\n  attrs.height = w\n}\n\nfunction reverseY (g) {\n  _.forEach(g.nodes(), function (v) { reverseYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, reverseYOne)\n    if (_.has(edge, 'y')) {\n      reverseYOne(edge)\n    }\n  })\n}\n\nfunction reverseYOne (attrs) {\n  attrs.y = -attrs.y\n}\n\nfunction swapXY (g) {\n  _.forEach(g.nodes(), function (v) { swapXYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, swapXYOne)\n    if (_.has(edge, 'x')) {\n      swapXYOne(edge)\n    }\n  })\n}\n\nfunction swapXYOne (attrs) {\n  const x = attrs.x\n  attrs.x = attrs.y\n  attrs.y = x\n}\n\nexport default {\n  adjust,\n  undo\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/coordinate-system.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport initOrder from './init-order'\nimport crossCount from './cross-count'\nimport sortSubgraph from './sort-subgraph'\nimport buildLayerGraph from './build-layer-graph'\nimport addSubgraphConstraints from './add-subgraph-constraints'\nimport util from '../util'\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order (g) {\n  const maxRank = util.maxRank(g)\n  const downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges')\n  const upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges')\n\n  let layering = initOrder(g)\n  assignOrder(g, layering)\n\n  let bestCC = Number.POSITIVE_INFINITY\n  let best\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2)\n\n    layering = util.buildLayerMatrix(g)\n    const cc = crossCount(g, layering)\n    if (cc < bestCC) {\n      lastBest = 0\n      best = _.cloneDeep(layering)\n      bestCC = cc\n    }\n  }\n\n  assignOrder(g, best)\n}\n\nfunction buildLayerGraphs (g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship)\n  })\n}\n\nfunction sweepLayerGraphs (layerGraphs, biasRight) {\n  const cg = new Graph()\n  _.forEach(layerGraphs, function (lg) {\n    const root = lg.graph().root\n    const sorted = sortSubgraph(lg, root, cg, biasRight)\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i\n    })\n    addSubgraphConstraints(lg, cg, sorted.vs)\n  })\n}\n\nfunction assignOrder (g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i\n    })\n  })\n}\n\nexport default order\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/index.js","import _ from 'lodash'\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder (g) {\n  const visited = {}\n  const simpleNodes = _.filter(g.nodes(), function (v) {\n    return !g.children(v).length\n  })\n  const maxRank = _.max(_.map(simpleNodes, function (v) { return g.node(v).rank }))\n  const layers = _.map(_.range(maxRank + 1), function () { return [] })\n\n  function dfs (v) {\n    if (_.has(visited, v)) return\n    visited[v] = true\n    const node = g.node(v)\n    layers[node.rank].push(v)\n    _.forEach(g.successors(v), dfs)\n  }\n\n  const orderedVs = _.sortBy(simpleNodes, function (v) { return g.node(v).rank })\n  _.forEach(orderedVs, dfs)\n\n  return layers\n}\n\nexport default initOrder\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/init-order.js","import _ from 'lodash'\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount (g, layering) {\n  let cc = 0\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i])\n  }\n  return cc\n}\n\nfunction twoLayerCrossCount (g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = _.zipObject(southLayer,\n                             _.map(southLayer, function (v, i) { return i }))\n  const southEntries = _.flatten(_.map(northLayer, function (v) {\n    return _.chain(g.outEdges(v))\n            .map(function (e) {\n              return { pos: southPos[e.w], weight: g.edge(e).weight }\n            })\n            .sortBy('pos')\n            .value()\n  }), true)\n\n  // Build the accumulator tree\n  let firstIndex = 1\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1\n  }\n  const treeSize = 2 * firstIndex - 1\n  firstIndex -= 1\n  const tree = _.map(new Array(treeSize), function () { return 0 })\n\n  // Calculate the weighted crossings\n  let cc = 0\n  _.forEach(southEntries.forEach(function (entry) {\n    let index = entry.pos + firstIndex\n    tree[index] += entry.weight\n    let weightSum = 0\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1]\n      }\n      index = (index - 1) >> 1\n      tree[index] += entry.weight\n    }\n    cc += entry.weight * weightSum\n  }))\n\n  return cc\n}\n\nexport default crossCount\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/cross-count.js","import _ from 'lodash'\n\nimport barycenter from './barycenter'\nimport resolveConflicts from './resolve-conflicts'\nimport sort from './sort'\n\nfunction sortSubgraph (g, v, cg, biasRight) {\n  let movable = g.children(v)\n  const node = g.node(v)\n  const bl = node ? node.borderLeft : undefined\n  const br = node ? node.borderRight : undefined\n  const subgraphs = {}\n\n  if (bl) {\n    movable = _.filter(movable, function (w) {\n      return w !== bl && w !== br\n    })\n  }\n\n  const barycenters = barycenter(g, movable)\n  _.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight)\n      subgraphs[entry.v] = subgraphResult\n      if (_.has(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult)\n      }\n    }\n  })\n\n  const entries = resolveConflicts(barycenters, cg)\n  expandSubgraphs(entries, subgraphs)\n\n  const result = sort(entries, biasRight)\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br], true)\n    if (g.predecessors(bl).length) {\n      const blPred = g.node(g.predecessors(bl)[0])\n      const brPred = g.node(g.predecessors(br)[0])\n      if (!_.has(result, 'barycenter')) {\n        result.barycenter = 0\n        result.weight = 0\n      }\n      result.barycenter = (result.barycenter * result.weight +\n                           blPred.order + brPred.order) / (result.weight + 2)\n      result.weight += 2\n    }\n  }\n\n  return result\n}\n\nfunction expandSubgraphs (entries, subgraphs) {\n  _.forEach(entries, function (entry) {\n    entry.vs = _.flatten(entry.vs.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs\n      }\n      return v\n    }), true)\n  })\n}\n\nfunction mergeBarycenters (target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight +\n                         other.barycenter * other.weight) /\n                        (target.weight + other.weight)\n    target.weight += other.weight\n  } else {\n    target.barycenter = other.barycenter\n    target.weight = other.weight\n  }\n}\n\nexport default sortSubgraph\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/sort-subgraph.js","import _ from 'lodash'\n\nfunction barycenter (g, movable) {\n  return _.map(movable, function (v) {\n    const inV = g.inEdges(v)\n    if (!inV.length) {\n      return { v: v }\n    } else {\n      const result = _.reduce(inV, function (acc, e) {\n        const edge = g.edge(e)\n        const nodeU = g.node(e.v)\n        return {\n          sum: acc.sum + (edge.weight * nodeU.order),\n          weight: acc.weight + edge.weight\n        }\n      }, { sum: 0, weight: 0 })\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      }\n    }\n  })\n}\n\nexport default barycenter\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/barycenter.js","import _ from 'lodash'\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts (entries, cg) {\n  const mappedEntries = {}\n  _.forEach(entries, function (entry, i) {\n    const tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      'in': [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    }\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter\n      tmp.weight = entry.weight\n    }\n  })\n\n  _.forEach(cg.edges(), function (e) {\n    const entryV = mappedEntries[e.v]\n    const entryW = mappedEntries[e.w]\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++\n      entryV.out.push(mappedEntries[e.w])\n    }\n  })\n\n  const sourceSet = _.filter(mappedEntries, function (entry) {\n    return !entry.indegree\n  })\n\n  return doResolveConflicts(sourceSet)\n}\n\nfunction doResolveConflicts (sourceSet) {\n  const entries = []\n\n  function handleIn (vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry)\n      }\n    }\n  }\n\n  function handleOut (vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry)\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry)\n      }\n    }\n  }\n\n  while (sourceSet.length) {\n    const entry = sourceSet.pop()\n    entries.push(entry)\n    _.forEach(entry['in'].reverse(), handleIn(entry))\n    _.forEach(entry.out, handleOut(entry))\n  }\n\n  return _.chain(entries)\n          .filter(function (entry) { return !entry.merged })\n          .map(function (entry) {\n            return _.pick(entry, ['vs', 'i', 'barycenter', 'weight'])\n          })\n          .value()\n}\n\nfunction mergeEntries (target, source) {\n  let sum = 0\n  let weight = 0\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight\n    weight += target.weight\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight\n    weight += source.weight\n  }\n\n  target.vs = source.vs.concat(target.vs)\n  target.barycenter = sum / weight\n  target.weight = weight\n  target.i = Math.min(source.i, target.i)\n  source.merged = true\n}\n\nexport default resolveConflicts\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/resolve-conflicts.js","import _ from 'lodash'\n\nimport util from '../util'\n\nfunction sort (entries, biasRight) {\n  const parts = util.partition(entries, function (entry) {\n    return _.has(entry, 'barycenter')\n  })\n  const sortable = parts.lhs\n  const unsortable = _.sortBy(parts.rhs, function (entry) { return -entry.i })\n  const vs = []\n  let sum = 0\n  let weight = 0\n  let vsIndex = 0\n\n  sortable.sort(compareWithBias(!!biasRight))\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length\n    vs.push(entry.vs)\n    sum += entry.barycenter * entry.weight\n    weight += entry.weight\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n  })\n\n  const result = { vs: _.flatten(vs, true) }\n  if (weight) {\n    result.barycenter = sum / weight\n    result.weight = weight\n  }\n  return result\n}\n\nfunction consumeUnsortable (vs, unsortable, index) {\n  let last\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop()\n    vs.push(last.vs)\n    index++\n  }\n  return index\n}\n\nfunction compareWithBias (bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i\n  }\n}\n\nexport default sort\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/sort.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph (g, rank, relationship) {\n  const root = createRootNode(g)\n  const result = new Graph({ compound: true }).setGraph({ root: root })\n                  .setDefaultNodeLabel(function (v) { return g.node(v) })\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const parent = g.parent(v)\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v)\n      result.setParent(v, parent || root)\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        const u = e.v === v ? e.w : e.v\n        const edge = result.edge(u, v)\n        const weight = !_.isUndefined(edge) ? edge.weight : 0\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight })\n      })\n\n      if (_.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        })\n      }\n    }\n  })\n\n  return result\n}\n\nfunction createRootNode (g) {\n  let v\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v\n}\n\nexport default buildLayerGraph\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/build-layer-graph.js","import _ from 'lodash'\n\nfunction addSubgraphConstraints (g, cg, vs) {\n  const prev = {}\n  let rootPrev\n\n  _.forEach(vs, function (v) {\n    let child = g.parent(v)\n    let parent\n    let prevChild\n    while (child) {\n      parent = g.parent(child)\n      if (parent) {\n        prevChild = prev[parent]\n        prev[parent] = child\n      } else {\n        prevChild = rootPrev\n        rootPrev = child\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child)\n        return\n      }\n      child = parent\n    }\n  })\n\n  /*\n  function dfs(v) {\n    const children = v ? g.children(v) : g.children();\n    if (children.length) {\n      const min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.forEach(children, function(child) {\n        const childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\nexport default addSubgraphConstraints\n\n\n\n// WEBPACK FOOTER //\n// ./lib/order/add-subgraph-constraints.js","import _ from 'lodash'\n\nimport util from '../util'\nimport { positionX } from './bk'\n\nfunction position (g) {\n  g = util.asNonCompoundGraph(g)\n\n  positionY(g)\n  _.forEach(positionX(g), function (x, v) {\n    g.node(v).x = x\n  })\n}\n\nfunction positionY (g) {\n  const layering = util.buildLayerMatrix(g)\n  const rankSep = g.graph().ranksep\n  let prevY = 0\n  _.forEach(layering, function (layer) {\n    const maxHeight = _.max(_.map(layer, function (v) { return g.node(v).height }))\n    _.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2\n    })\n    prevY += maxHeight + rankSep\n  })\n}\n\nexport default position\n\n\n\n// WEBPACK FOOTER //\n// ./lib/position/index.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport util from '../util'\n\n/*\n * This module provides coordinate assignment based on Brandes and Kpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts (g, layering) {\n  const conflicts = {}\n\n  function visitLayer (prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0\n    const prevLayerLength = prevLayer.length\n    const lastNode = _.last(layer)\n\n    _.forEach(layer, function (v, i) {\n      const w = findOtherInnerSegmentNode(g, v)\n      const k1 = w ? g.node(w).order : prevLayerLength\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            const uLabel = g.node(u)\n            const uPos = uLabel.order\n            if ((uPos < k0 || k1 < uPos) &&\n              !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode)\n            }\n          })\n        })\n        scanPos = i + 1\n        k0 = k1\n      }\n    })\n\n    return layer\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findType2Conflicts (g, layering) {\n  const conflicts = {}\n\n  function scan (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    let v\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i]\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          const uNode = g.node(u)\n          if (uNode.dummy &&\n            (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v)\n          }\n        })\n      }\n    })\n  }\n\n  function visitLayer (north, south) {\n    let prevNorthPos = -1\n    let nextNorthPos\n    let southPos = 0\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        const predecessors = g.predecessors(v)\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos)\n          southPos = southLookahead\n          prevNorthPos = nextNorthPos\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length)\n    })\n\n    return south\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findOtherInnerSegmentNode (g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy\n    })\n  }\n}\n\nfunction addConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n\n  let conflictsV = conflicts[v]\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {}\n  }\n  conflictsV[w] = true\n}\n\nfunction hasConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n  return _.has(conflicts[v], w)\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment (g, layering, conflicts, neighborFn) {\n  const root = {}\n  const align = {}\n  const pos = {}\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v\n      align[v] = v\n      pos[v] = order\n    })\n  })\n\n  _.forEach(layering, function (layer) {\n    let prevIdx = -1\n    _.forEach(layer, function (v) {\n      let ws = neighborFn(v)\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) { return pos[w] })\n        const mp = (ws.length - 1) / 2\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i]\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v\n            align[v] = root[v] = root[w]\n            prevIdx = pos[w]\n          }\n        }\n      }\n    })\n  })\n\n  return { root: root, align: align }\n}\n\nfunction horizontalCompaction (g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs = {}\n  const blockG = buildBlockGraph(g, layering, root, reverseSep)\n\n  // First pass, assign smallest coordinates via DFS\n  const visited = {}\n  function pass1 (v) {\n    if (!_.has(visited, v)) {\n      visited[v] = true\n      xs[v] = _.reduce(blockG.inEdges(v), function (max, e) {\n        pass1(e.v)\n        return Math.max(max, xs[e.v] + blockG.edge(e))\n      }, 0)\n    }\n  }\n  _.forEach(blockG.nodes(), pass1)\n\n  const borderType = reverseSep ? 'borderLeft' : 'borderRight'\n  function pass2 (v) {\n    if (visited[v] !== 2) {\n      visited[v]++\n      const node = g.node(v)\n      const min = _.reduce(blockG.outEdges(v), function (min, e) {\n        pass2(e.w)\n        return Math.min(min, xs[e.w] - blockG.edge(e))\n      }, Number.POSITIVE_INFINITY)\n      if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n        xs[v] = Math.max(xs[v], min)\n      }\n    }\n  }\n  _.forEach(blockG.nodes(), pass2)\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]]\n  })\n\n  return xs\n}\n\nfunction buildBlockGraph (g, layering, root, reverseSep) {\n  const blockGraph = new Graph()\n  const graphLabel = g.graph()\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep)\n\n  _.forEach(layering, function (layer) {\n    let u\n    _.forEach(layer, function (v) {\n      const vRoot = root[v]\n      blockGraph.setNode(vRoot)\n      if (u) {\n        const uRoot = root[u]\n        const prevMax = blockGraph.edge(uRoot, vRoot)\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0))\n      }\n      u = v\n    })\n  })\n\n  return blockGraph\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment (g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    const min = (_.minBy(_.toPairs(xs), (pair) => pair[1] - width(g, pair[0]) / 2) || ['k', 0])[1]\n    const max = (_.maxBy(_.toPairs(xs), (pair) => pair[1] + width(g, pair[0]) / 2) || ['k', 0])[1]\n    return max - min\n  })\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates (xss, alignTo) {\n  const alignToVals = _.values(alignTo)\n  const alignToMin = _.min(alignToVals)\n  const alignToMax = _.max(alignToVals)\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      const alignment = vert + horiz\n      const xs = xss[alignment]\n      if (xs === alignTo) {\n        return\n      }\n      const xsVals = _.values(xs)\n      const delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals)\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) { return x + delta })\n      }\n    })\n  })\n}\n\nfunction balance (xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v]\n    } else {\n      const xs = _.sortBy(_.map(xss, v))\n      return (xs[1] + xs[2]) / 2\n    }\n  })\n}\n\nexport function positionX (g) {\n  const layering = util.buildLayerMatrix(g)\n  const conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering))\n\n  const xss = {}\n  let adjustedLayering\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse()\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse()\n        })\n      }\n\n      const neighborFn = _.bind(vert === 'u' ? g.predecessors : g.successors, g)\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn)\n      let xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align,\n        horiz === 'r')\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) { return -x })\n      }\n      xss[vert + horiz] = xs\n    })\n  })\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss)\n  alignCoordinates(xss, smallestWidth)\n  return balance(xss, g.graph().align)\n}\n\nfunction sep (nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    const vLabel = g.node(v)\n    const wLabel = g.node(w)\n    let sum = 0\n    let delta\n\n    sum += vLabel.width / 2\n    if (_.has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l': delta = -vLabel.width / 2; break\n        case 'r': delta = vLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2\n\n    sum += wLabel.width / 2\n    if (_.has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l': delta = wLabel.width / 2; break\n        case 'r': delta = -wLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    return sum\n  }\n}\n\nfunction width (g, v) {\n  return g.node(v).width\n}\n\nexport default {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/position/bk.js","import _ from 'lodash'\nimport { Graph } from 'graphlib'\n\nimport util from './util'\n\n/* istanbul ignore next */\nfunction debugOrdering (g) {\n  const layerMatrix = util.buildLayerMatrix(g)\n\n  const h = new Graph({ compound: true, multigraph: true }).setGraph({})\n\n  _.forEach(g.nodes(), function (v) {\n    h.setNode(v, { label: v })\n    h.setParent(v, 'layer' + g.node(v).rank)\n  })\n\n  _.forEach(g.edges(), function (e) {\n    h.setEdge(e.v, e.w, {}, e.name)\n  })\n\n  _.forEach(layerMatrix, function (layer, i) {\n    const layerV = 'layer' + i\n    h.setNode(layerV, { rank: 'same' })\n    _.reduce(layer, function (u, v) {\n      h.setEdge(u, v, { style: 'invis' })\n      return v\n    })\n  })\n\n  return h\n}\n\nexport default {\n  debugOrdering\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/debug.js","module.exports = {\"name\":\"dagre-layout\",\"version\":\"0.8.4\",\"description\":\"Graph layout for JavaScript\",\"author\":\"Tyler Long <tyler4long@gmail.com>\",\"main\":\"dist/dagre-layout.core.js\",\"keywords\":[\"graph\",\"layout\",\"dagre\"],\"scripts\":{\"lint\":\"standard\",\"jest\":\"jest --coverage\",\"karma\":\"node -r babel-register node_modules/.bin/karma start\",\"test\":\"yarn lint && yarn jest && yarn karma --single-run\",\"bench\":\"node -r babel-register src/bench.js\",\"build\":\"webpack --progress --colors\",\"build:watch\":\"yarn build --watch\",\"release\":\"yarn build -p\",\"upgrade\":\"yarn-upgrade-all\",\"prepush\":\"yarn test\",\"prepublishOnly\":\"yarn release\"},\"dependencies\":{\"graphlib\":\"^2.1.5\",\"lodash\":\"^4.17.5\"},\"devDependencies\":{\"babel-core\":\"^6.26.0\",\"babel-loader\":\"^7.1.2\",\"babel-preset-env\":\"^1.6.1\",\"benchmark\":\"^2.1.4\",\"chai\":\"^4.1.2\",\"coveralls\":\"^3.0.0\",\"husky\":\"^0.14.3\",\"jest\":\"^22.2.2\",\"karma\":\"^2.0.0\",\"karma-chrome-launcher\":\"^2.2.0\",\"karma-firefox-launcher\":\"^1.1.0\",\"karma-mocha\":\"^1.3.0\",\"karma-safari-launcher\":\"^1.0.0\",\"mocha\":\"^5.0.0\",\"sprintf\":\"^0.1.5\",\"standard\":\"^10.0.3\",\"webpack\":\"^3.11.0\",\"webpack-node-externals\":\"^1.6.0\",\"yarn-upgrade-all\":\"^0.3.0\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/tylingsoft/dagre-layout.git\"},\"license\":\"MIT\",\"files\":[\"dist/\",\"lib/\",\"index.js\"],\"standard\":{\"ignore\":[\"dist/**/*.js\",\"coverage/**/*.js\"]},\"jest\":{\"testRegex\":\"test/.+?-test\\\\.js\",\"testPathIgnorePatterns\":[\"test/bundle-test\\\\.js\"]}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 29\n// module chunks = 0"],"sourceRoot":""}