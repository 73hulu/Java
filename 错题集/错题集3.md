
#### 下列程序，Test.main() 函数执行后的输出是（）
```java
public class Test{
    public static void main(String [] args){
        System.out.println(new B().getValue());
    }
    static class A{
        protected int value;
        public A(int v) {
            setValue(v);
        }
        public void setValue(int value){
            this.value = value;
        }
        public int getValue(){
            try{
                value++;
                return value;
            } catch(Exception e){
                System.out.println(e.toString());
            } finally {
                this.setValue(value);
                System.out.println(value);
            }
            return value;
        }
    }
    static class B extends A{
        public B() {
            super(5);
            setValue(getValue() - 3);
        }
        public void setValue(int value){
            super.setValue(2 * value);
        }
    }
}
```
A. 11 17 34

B. 22 74 74

C. 6 7 7

D. 22 34 17

**答案**： D

**题目来源**：

**解析**: 这题太厉害了，弄明白了可以把继承关系和try-catch-finally搞明白。脑子要非常清楚当前执行到哪一步了，当前的value是指什么。准备返回的是什么。

首先new一个B对象。

而B的构造函数中，首先调用了父类A的构造函数，参数是5。A的构造函数调用了setValue函数，注意，B在继承A的时候重写了这个方法，所以这个时候调用的是B重定义的setValue方法，这个重写的方法中调用了父类A的setValue方法，参数是10，在父类A的setValue方法中，成员便令value被赋值为10。到这个时候`suprt(5)`才真正执行结束。接下来执行setValue(getValue() - 3)语句，其中getValue调用的仍是父类A定义的方法，因为这个方法没有被重写。这个方法中，首先value变成11，然后这个值被保存下来，值是11，准备返回，注意，“保存”下来的意思是保存了一个副本，无论之后value这个值实际上怎么变化，都不会影响这个副本。接着执行finally块中的代码，首先`this.setValue(value);`this指向的是B的实例，此时setValue是被重写的犯方法，所以执行了`super.setValue(22)`，将value值变成22，但是这个值并不影响前面保存的副本。所以这里首先打印出"22"。接着会执行try-catch-finally块外的return语句么？不会，因为try中已经有了return语句，它最大的耐心就是等待finally块执行结束。所以这里返回的是11。11 - 3 = 8，作为参数传递给setValue方法，执行`super.setValue(16)`。然后父类A的setValue方法将value值设定为16。

到这个时候new B()才结束。然后再执行getValue方法。

此时value的值是16，加上1变成17，保存副本准备返回。执行finally块中的`this.setValue(17);`,实际上执行的是`  super.setValue(34)`，执行过后value变成34,打印出来，然后返回之前的副本17，在main中的主函数打印出来。

所以打印的最终结果是 22  34  17。这道题的调试过程可以参考 http://blog.csdn.net/zhumintao/article/details/53818972

#### 阅读以下程序并写出运行结果：
```java
public class ExceptionTest {
	static String a[]={"123","abc",null};
	public static void main (String args[]) {
		for (int i = 0; i < 3; i++) {
			try {
				int x = Integer.parseInt(a[i]);
				System.out.println(  "Result: " + x);
			}
			catch(NullPointerException e) {
				System.out.println("error null：");
			}
			catch (NumberFormatException e){
				System.out.println("error ：abc" );
			}
			finally{
				System.out.println ("In "+ i +"th loop\n");
			}
		}
	}
}
```
** 答案 **：
```java
Result: 123
In 0th loop

error : abc
In 1th loop

error null:
In 2th loop
```

** 题目来源**：

** 解析 **：看源码，`Integer.parseInt()`方法只会抛出`NumberFormatException`，就算参数是null的情况下。


#### 一个Java源程序文件中定义几个类和接口，则编译该文件后生成几个以.class为后缀的字节码文件。
A. 正确

B. 错误

** 答案 **： A

**题目来源**：https://www.nowcoder.com/profile/848042/myFollowings/detail/4074845

** 解析 **： 定义多少类（接口），就会生成多少.class文件，内部类除外
