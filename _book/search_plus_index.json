{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 复习的正确顺序： JDK Object -> Objects 基本数据类型 -> 八种包装类 -> 包装类源码 String 高效编程 -> String -> StringBuilder - > StringBuffer -> 正则Pattern -> Java编译技术 OOP -> 修饰符 -> 类、抽象类、内部类和接口 -> 设计模式 类编译、加载和执行 -> ClassLoader -> 反射Class -> reflect -> 虚拟机 防御式编程 -> 异常 -> 断言 集合框架 -> Collection| ArrayList |LinkedList | HashSet | LinkedHashSet | TreeSet | HashMap | LinkedHashMap| TreeMap | PriorityQueue| ConcurrentHashMap | Collections | Arrays-> 空间增长原则 -> 数据结构（数组、线性表、栈、队列、树） -> 算法 线程 -> Thread -> ThreadGroup -> ThreadPool -> concurrent包 需要注意的点： Object clone方法注意是protected、需要实现cloneable接口，返回值是Object equals -> hashcode Objects对object有哪些改进？ 包装类 Integer和Long中计算数字长度的方法 toString方法如何实现？ hashcode的计算方法 自动装箱和自动拆箱 Integer中的valueOf方法是如何实现的。 Integer中的parseInt方法是如何实现的？ String getCharts方法的返回值是void，需要将结果保存的字符数组作为参数传入。 equals方法和hashcode方法的写法 replace(char)方法是字符匹配，replace(String)方法是正则匹配 split第1个参数是正则式，第二个参数（正数、负数和0）的含义？ 学会用join方法 常用toCharArray方法 常用format方法，百分号转义？ 理解intem方法在1.7之前和之后的区别，深刻理解方法区常量池保存堆中的内存 StringBuilder 空间增长策略（2x + 2），最大值、初始化长度 applend(null)会追加\"null\" 线程不安全 StringBuffer 线程安全 OOP 面向对象三个重要的特性 9种修饰符的含义 内部类、抽象类、接口 类的编译、加载、执行过程 类加载器的双亲委托 三种loader的默认路径和自定义路径 自定义classloader需要重写findClass方法，在其中调用defineClass方法 defineClass方法被调用时生成class对象 ClassLoader工作过程：装载 | 链接（检查、准备、解析） | 初始化 类的初始化顺序 JVM运行时的内存分区 GC含义 判定一个对象是垃圾的方法（2种） 内存回收算法（4种），各自的特点是适合的对象 内存回收器（7种），各自适合什么对象，各自工作流程 内存溢出和内存泄漏的区别 内存调优 OOM日志查看 反射 反射的意义，为什么用反射？ 创建Class对象的三种办法 newInstance调用的是类的无参构造方法，且返回的是Object类型的对象 类实例化的三种方法 invoke方法返回值是Object方法 触发方法的两种方法 declare有无的区别 Field中操作属性的方法（get和set），在对private属性进行操作之前需要setAccessible(true) 基本数据类型和void也有class对象、数组也有class对象 Array创建数组和操作数组的方法。 Array不能实例化，newInstance方法返回值是Object 异常处理机制 异常和断言的区别 异常机制结构，常见的免检异常 finally的作用，return语句，资源释放顺序 try-with-resources语句的作用 1.7对于catch语句的改进 multi-catch 集合框架和算法 框架大概情况 iterable和iterator的区别 Iterator中remove方法的用法 迭代器的操作是否会影响原来的集合？ 实现自定义的迭代器类? 迭代器类需要实现Iterable接口，其中iterator方法中定义实现Iterator接口的内部类，返回一个接口实例。 ListIterator对Iterator做了哪些改进？ 线性表、栈、队列（peek | element | poll | remove | offer）的实现和方法 toArray方法写法 ArrayList和数组的相互转换 HashMap中三种视图和各自的迭代器 HashMap中的存储结构Node table HashMap默认初始化大小，默认装载因子、扩容策略 HashMap中对哈希值的重新定义 HashMap寻址和冲突解决办法 putVal map如何进行遍历 弄明白HashMap、LinkedList中数据结构的继承关系 数据结构中数组、线性表、栈、队列、树 数组存储地址的计算 三种特殊矩阵的压缩存储原理、稀疏矩阵的表示 线性表的顺序存储和链式存储的实现 栈的顺序存储和链式存储的实现 队列的顺序存储(循环队列)和链式存储的实现 二叉树定义、常用结论 二叉树的三种遍历方式的非递归实现（重要） BST、AVL、B-、B+、B*树之间的区别和联系，各自的查找、插入和删除实现过程 Collections中的算法实现：排序(sort)、反转(rotate)、二分查找（binarySearch）、混排(shuffle)、填充（fill）、拷贝(copy)、替代（replaceAll）、子串匹配(indexOfSubList和lastIndexOfSubList)、最大(max)、最小(min) Arrays中的算法实现 查找算法（7种）：顺序、二分、差值、斐波那契、树表（BST、AVL、B+、B-、B*、红黑树）、分块查找、哈希查找 及各自的效率 排序算法（5类8种）：插入排序（直接插入、希尔）、选择（简单选择、堆排序）、交换（冒泡、快排）、归并、基数排序 及各自的效率 多线程 背景：CPU、多核处理器、多处理器、多道程序设计、并行、并发 进程和线程的概念、区别 多核心处理器、内核线程、超线程技术 线程竞争状态：只有对共享区域的数据进行操作的时候才会有这样的问题，准确来说，是对方法区和堆区的数据进行操作的时候才有这个问题。对于局部变量啊这种的，不是共享的数据，不会有问题！！！！不能理解线程的原因在这里，清醒一点！！！ synchronized关键字获取对象锁和类锁，两者有什么区别？ 假设对象可能有很多方法，其中包括很多synchronied方法和非synchronized方法，那么同一时刻，只能有一个synchronized可能被访问，但是！其他非synchronized方法照样能被访问。 房间和钥匙的比喻！！！牢记 理解“synchronied是线程级的而不是方法级的”； “加锁的是对象而不是代码” “同步”和“互斥”有什么区别。同步是只等待同一个资源，使得有先有后，方法就是加同一把锁。互斥是指同一时刻只有一个线程能获得，方法是加锁。 synchronied叫做监视器锁，理解监视器的概念和实现 梳理JUC包都包含哪些类，尤其是locks子包中都有哪些重要的接口和类 AQS提供线程队列的操作，LockSupport提供线程唤醒和阻塞原语。 理解各种锁与AQS之间的关系，为什么说AQS提供了基本同步框架。 Lock接口中lock、tryLock、lockInterruptibly三种方法的用法和区别，以及各自的使用场景 ReentrantLock如何实现AQS和Lock。 什么是公平锁和非公平锁？ReenrantLock默认是什么锁。 线程同步的意思？ 阻断其他线程 ReentrantReadWriteLock性能？读锁和写锁如何工作?适用于什么场景。 三种线程同步辅助类Semaphore、CountDownLatch、CyclicBarrier的作用和使用场景。 创建线程的四种方法，哪种比较好。 Executor框架主要包含哪些东西？ 为什么要使用线程池。 Executor和Executors的区别和联系 创建线程的四种方式 线程池和线程组有什么区别和联系 线程的生命周期！！！！各种状态转化方法的区别 线程中断是什么意思？哪些可以中断，哪些不能中断？如何检测中断？ I/O I/O流的分类（字节字符、输入输出、目标媒介） 文件File Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 17:32:29 "},"资源整理.html":{"url":"资源整理.html","title":"资源整理","keywords":"","body":"资源整理 整理了一些Java软件工程师的基础知识点 Java程序员最常犯的错误盘点之Top 10 Java开发岗位面试题归类 2017最优秀的面试题 美团点评技术团队 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-13 22:47:54 "},"Java基础知识整理/JDK.html":{"url":"Java基础知识整理/JDK.html","title":"JDK","keywords":"","body":"JDK Java 体系结构如下图： JDK、JRE和JVM JDK（Java development Kit）组成： Java程序设计语言 + Java虚拟机 + Java API类库 JRE(Java Runtime Environment)组成： Java SE API子集 + Java 虚拟机，与JDK相比，它不包含开发工具——编译器、调试器和其他工具 JVM(Java Virtual Mechinal)： 虚拟出来的机器，有自己完善的硬件架构，如处理器、堆栈、寄存器和相应的指令系统。Java能跨平台运行，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成跨平台性。 JVM主要工作是解释自己的指令集（即字节码）并映射到本地的CPU的指令集或OS的系统调用。 根据Java技术关注的终点业务领域来划分，Java技术体系可分为4个平台： Java Card： 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。 Java ME(Micro Edition)：支持Java程序运行在移动终端上的平台， Java SE(Standard Edition)：支持面向桌面级应用的平台，提供完整的核心Java核心API，这个版本以前称为J2SE. Java EE(Enterprise Edition)：支持使用多层架构的企业应用的平台，除了提供Java SE API之外，还对其做了大量的扩充，并提供了相应的部署支持。这个版本以前称为J2EE. C++和Java的异同 相同：OOP 不同： Java是半编译半解释型语言（.java -(编译)-> .class -(JVM解释)->执行），C++是编译型语言。所以JAVA比C++要慢一点 Java跨平台，C++不跨平台 Java纯面向对象，不存在全局变量或全局函数，C++具有面向过程和面向对象，可以定义全局变量和全局函数 Java没有指针更加安全 Java不支持多重继承，但是有接口继承，C++可以有多重继承 Java提供垃圾回收器来实现垃圾的自动回收，C++需要开发人员自己管理内存 Java不支持运算符重载，C++支持 Java没有预处理器（但是提供import与预处理器相似），C++有预处理器 Java不支持goto，但是goto是保留字，C++支持goto。 Java不支持自动类型转换，必须由开发人员进行显示强制类型转换 Java没有结构和联合，C++支持，C++会导致安全问题 Java支持文档内建，C++不支持 Java提供标准库，如Servlet、JSP提供对web的支持，Socket、RMI可以用来开发分布式应用程序。C++依靠一些非标准、由其他厂商提供的库 java开发工具 命令 作用 javac 讲一个.java文件编译成.class文件 java 用来运行一个.class文件 javadoc 用来生成api文档 jar 用来生成jar包 jdb 调试工具 javaprof 剖析工具 javah 把java代码声明的JNI方法转化成C\\C++头文件，就是那些native方法 问： Java开发工具是Java语言写的？ 对，但是其底层是C++写的。 命令可以通过-help来查看用法，如javac -help: 【JDK 1.6 & 1.7】String.intern()方法 String.intern()是一个Native方法，其作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。 不同JDK对字符串常量池的实现不同，分界点是JDK1.7。 例如下面这段代码： public static void main(String[] args) { String str1 = new StringBuilder(\"计算机\").append(\"软件\").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); System.out.println(str2.intern() == str2); } 以上代码如果在JDK1.6中运行，会得到两个false，但是在JDK1.7之后，会得到一个true和false。 差异的原因在于： 在JDK1.6中，intern()方法会将首次遇到的字符实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而用StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。 在JDK1.7+中，intern()不再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串将是同一个。对于str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量中已经有其引用，不符合\"首次出现\"的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。 JDK版本 集合框架 @since 1.2 NIO @since 1.4 Lock @since 1.5 自动装箱 @since 1.5 Enum @since 1.5 Objects @since 1.7 Predicate @since 1.8 Iterable @since 1.5 try-with-resource @since 1.7 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-14 15:59:33 "},"Java基础知识整理/基本数据类型.html":{"url":"Java基础知识整理/基本数据类型.html","title":"基本数据类型","keywords":"","body":"基本数据类型 基本数据类型也称为原生类、内置类型。 基本数据类型等级 由低到高级分别为：(byte, short, char) -- int -- long -- float -- double Java默认的整型是int，浮点型是long。所以定义float的时候需要加上‘f’。判断下面的写法是不是正确的。 float f1 = 1.0;//错误。1.0默认是long类型，要么强制转化成float，要么在后面加上f double l1 = 1.0;//正确，浮点型默认为double类型 int i = 1;//正确，浮点型默认为int类型 long l = 1;//正确，1虽然是int类型，但是可以从int自动转为long类型 Float f = 1.0; //错误，1.0默认是long类型。自动装箱也不会用只能用long基本数值类型进行装箱 Double l = 1.0; //正确，1.0是long类型 Integer i = 1; //正确，1默认为int类型，自动装箱 Long l = 1; //错误，1默认是int类型，这时候不能进行自动类型转化，需要在后面加上L。 数据类型之间的转换可以分成这几种情况： 由低级到高级的自动类型转换(注意，自动转化只发生在基本数据类型之间，不会发生在基本数据类型和包装类型之间，看上面的例子) 有高级到低级的强制类型转换（会导致溢出或丢失精度） 基本类型向包装类型转换 基本类型向字符串转换 包装类型向字符串转换 基本数据类型之间的转换规则： 在一个双操作数以及位运算等算术运算式中，会根据操作数的类型将低级的数据类型自动转为高级的数据类型，分为以下几种情况： 只要两个操作数中有一个是double类型的，另一个将会被装换成double类型，并且结果也是double类型。 只要两个操作数中有一个是float类型的，另一个将会被转化成float类型，并且结果也是float类型。，并且结果也是float类型。 只要两个操作数中有一个是long类型，另一个将会被转化成long类型，并且结果也是long类型。结果也是long类型。 两个操作数（包括byte、short、int、 char） 都会被转化成int类型，并且结果也是int类型。并且结果也是int类型。 被fianl修饰的变量不会自动改变类型，当操作符的2个操作数都被final修饰时，结果会根据左边变量的类型而转化。 自动转换规则只针对基本数据类型，不针对包装类型，比如double d = 1；是对的，但是Double d = 1就不对了。 特别需要注意的是第四条规则，正是这样的规则，使得两个short类型变量的和是int型。如果要得到short型，需要强制转化。 例如short s1 = 1; s1 = s1 + 1;编译会报错，正确的写法是short s1 = 1; s1 = (short) (s1 + 1);。但是有一种情况特殊，“+=”为Java语言规定的运算语，Java编译器对其进行特殊处理，因此语句short s1 = 1; s1 += 1;编译成功。 如果低级类型为char类型，向高级类型（整型）转化的时，会转化为对应的ASCII码，再做其他类型的自动转化。 对于byte、short和char三种类型而言，他们是平级的，因此不能相互自动转化，但是可以强制转换。例如 short i = 99; char ch = (char)i; System.out.println(\"output: \" + ch); 另外注意倒数最后一条规则，下面是一道笔试题： 下列代码片段中，存在编辑错误的语句是（）？ byte b1 = 1, b2 = 2, b3, b6, b8; final byte b4 = 4,b5 = 6,b7; b3 = (b1 + b2); /*语句1*/ b6 = b4 + b5; /*语句2*/ b8 = (b1 + b4); /*语句3*/ b7 = (b2 + b5); /*语句4*/ System.out.println(b3 + b6); A. 语句1 B. 语句2 C. 语句3 D. 语句4 答案是 ACD，解析如下： 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 布尔值不能与任何数字类型之间强制转换。 不能级别的数据类型之间的强制转换，可能会导致溢出或精度的下降。 当byte类型参与运算的时候，Java会自动提升为int型。 参考： http://www.cnblogs.com/Chenshuai7/p/5047882.html Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 14:28:15 "},"Java基础知识整理/数值包装类型.html":{"url":"Java基础知识整理/数值包装类型.html","title":"数值包装类型","keywords":"","body":"基本数值包装类型 包装类出现的原因 Java是一个面向对象的语言，基本类型并不具有对象的性质。为了与其他对象“接轨”就出现了包装类型（如在使用集合类型Collection就一定要使用包装类型而非基本类型,范型不能是基本数据类型，还要常常与字符串进行相互转换)，它相当于将基本类型“包装起来”，使得它具有对象的性质，并且添加了属性和方法，丰富了基本类型的操作。 基本类型和包装类的区别 Java中有8种基本数据类型： byte、short、int、long、float、double、char、boolean， 分别对应了8种包装类：Byte、Short、Integer、Long、Float、Double、Character、Boolean。 两者的区别在于： 声明方式不同。基本类型不适用new关键字，而包装类型需要使用new关键字在堆中分配存储空间。 存储方式及位置不同。 基本类型是直接将变量值存储在堆栈中，而包装类型是将对象放在堆中，然后通过引用来使用。 初始值不同。作为类的成员变量，基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null。 使用方式不同。基本类型直接赋值直接使用，而包装类型在集合如Collection、Map时会使用到。 8种包装类的继承关系如下： 根据各包装类的“近亲”关系，我们按照以下四类进行分析： 整型数值包装类（Byte & Short & Integer & Long） 浮点型数值包装类(Float & Double) 布尔型包装类（Boolean） 字符型包装类（Character） serialVersionUID 在查看源码的时候，发现每个类都有一个名叫‘serialVersionUID’的值： Byte : private static final long serialVersionUID = -7183698231559129828L; Short : private static final long serialVersionUID = 7515723908773894738L; Integer : @Native private static final long serialVersionUID = 1360826667806852920L; Long : @Native private static final long serialVersionUID = 4290774380558885855L; Float : private static final long serialVersionUID = -2671257302660747028L; Double : private static final long serialVersionUID = -9172774392245257468L; Boolean : private static final long serialVersionUID = -3665804199014368530L; Character : private static final long serialVersionUID = 3786198910865385080L; serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性。在进行反序列化的时候，JVM会把传来的字节流中的serialVersionUID与本地实体类的serialVersionUID进行比较，如果相同就是认为一致的，可以进行反序列化，否则就会出现版本不一致的异常，即InvalidCastException。如果类实现了Serializable接口，就最好定义一个这个类的serialVersionUID。 范围 每个包装类都明确制定了该包装类的位数，字节数，能表示的最大数和最小数。以Integer包装类为例： @Native public static final int SIZE = 32; public static final int BYTES = SIZE / Byte.SIZE; @Native public static final int MAX_VALUE = 0x7fffffff; @Native public static final int MIN_VALUE = 0x80000000; 相应地，Byte占8位，Short占16位，Integer占32位，Long占64位，Float占32位，Double占64位，Boolean没有指定位数，character占16位。实际上，只要所占位数知道，其他特性就能推断出来。 反射 每个包装类都有与其对应的基本数据类型，它们是如何取得联系的？靠的是这句话： @SuppressWarnings(\"unchecked\") public static final Class TYPE = (Class) Class.getPrimitiveClass(\"int\"); 注意到这句话上面的这个注释@SuppressWarnings，这是Java三大内置注解，表达的意思是忽略类型转化的警告。这句话利用反射机制，在该包装类初始化之初，获得对应基本数据类型的字节码，作为其包装类的TYPE静态私有属性。 Java注解可以参考另一篇博文《Java注解》 创建包装类实例 每个包装类都提供了基本的构造函数，用new操作符来创建实例对象。然而，我们更多的时候，是直接以字面量的方式创建对象，如Integer u = 100。这种写法在JDK1.5之前会编译报错，但是JDK1.5开始，由于“自动装箱”和“自动拆箱”的功能，使得类似的语句能成功编译。那么，什么是自动装箱和自动拆箱呢？ 自动装箱是指将基本类型变量赋值给包装类，如Integer i = 5;。通过调用包装器的ValueOf方法实现。 自动拆箱是指将包装类赋值给基本类型变量，如int j = i;。通过调用包装器的xxxValue方法实现。 所以，我们要想弄明白底层功能的实现，就要去查看源码中valueOf方法和xxxValue方法。 valueOf方法 看过源码的都知道，valueOf方法在每个类中的实现都不一样。我们由浅入深，看看都是如何实现的。 首先我们从最简单的整型数值包装类Byte开始，它的valueOf方法实现如下： public static Byte valueOf(byte b) { final int offset = 128; return ByteCache.cache[(int)b + offset]; } 可以看到，当valueOf方法被触发后，这个方法返回的是一个ByteCache类的静态数组中的值，ByteCache的类声明如下： private static class ByteCache { private ByteCache(){} static final Byte cache[] = new Byte[-(-128) + 127 + 1]; static { for(int i = 0; i ByteCache类为Byte类的私有静态内部类，也就是说，Byte被加载进来的时候，ByteCache还没有加载；当Byte类的valueOf方法第一次被调用的，ByteCache类被加载，同时初始化了其中的静态数组，数组的范围正好等于Byte能表示的范围。由于被final修饰，所以之后数组中元素的引用都是不变的，那么每次通过valueOf方法创建的Byte对象，只要值相同，得到的对象引用都是指向同一个内存地址！ Short类同样采取了同样的缓存类的实现机制，实现如下： public static Short valueOf(short s) { final int offset = 128; int sAsInt = s; if (sAsInt >= -128 && sAsInt 与Byte不同的是，Short类的缓存范围只定义在[-128, 127]之间，与其所能表示的范围（-2^15, -2^15-1）并不相符。所以在valueOf方法被触发后，先判断基本数据类型的值是不是在缓存范围之内，如果是，则返回缓存数组中对应元素的值，否则重新new一个对象并返回。 而Integer类则有更复杂的实现，其复杂性体现在缓存数组的初始化上，如下： public static Integer valueOf(int i) { if (i >= IntegerCache.low && i = 127; } private IntegerCache() {} } 可以清楚看到，Integer的限定了缓存数组的下界是-128，并没有限定上界的取值。上界的最终取值综合考虑了127、VM参数IntegerCache.high和Integer的表示范围。当然，一般情况下，没有人会去设置VM参数，这时候缓存数组的范围还是[-128, 127]。 Long类型虽然能表示更大范围的整数，但是明显可以感觉到设计者并没有将重心放到这个类上，其valueOf方法实现简单明了： public static Long valueOf(long l) { final int offset = 128; if (l >= -128 && l 连常量都懒得取了，直接在代码中了缓存范围是[-128, 127]。 上面都是整型数值包装类，可以看到它们全都采用缓存的方法，大部分情况下其缓存范围都是[-128, 127]。然而两种浮点型数值包装类Float和Double却不存在内部缓存类(这当然了，浮点型又没有什么规律可循，淡然不好创建缓存数组)，其valueOf方法都是直接new一个新对象并且返回。以Double类为例： public static Float valueOf(float f) { return new Float(f); } 而Boolean类本身很简单，只有两种值：false和true，Boolean类将其作为私有静态常量（对象），在调用valueOf方法时候直接返回这个对象： public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } 所以，Boolean类的valueOf方法和Byte类的valueOf方法一样：只要值相同，自动装箱得到的对象就是同一个。 Character类创建了内部静态缓存类，缓存范围为[0,127]，当valueOf方法被触发时，该范围的值会复用缓存数组中的对象，而超出这个范围的组会用new操作符创建一个新对象返回。 public static Character valueOf(char c) { if (c 总结 1. Byte, Short, Integer, Long, Boolean, Character在自动装箱时候采取缓存机制，而Float, Double没有缓存机制。 2. 一般情况下，Byte, Short, Integer, Long类的缓存范围[-128,127]，Character的缓存范围是[0,127]，Boolean的缓存覆盖false和true的取值。当valueOf方法被调动的时候，如果基本类型的值在缓存范围内，则复用缓存中的对象，否则就new一个新对象返回。 3. 注意Integer i = new Integer(xxx)；和Integer i = xxx；这两种创建实例方法的区别：前者不会触发自动装箱过程，而后者会，即会调用valueOf方法，这时候要注意缓存问题。另外，在执行效率和资源占用上，第二种方式的执行效率和资源占用在一般情况下要优于第一种。 xxxValue方法 包装类实例转化为其对应的基本数据类型都是通过xxxValue方法实现的，很简单，返回类的属性value值即可。例如Byte类的byteValue方法: public byte byteValue() { return value; } equals方法和\"==\"运算符 包装类的equals方法实现基本相同，以Integer包装类为例： public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } 该方法对obj不会进行类型转化，而是直接比较操作数的类型再进行自动拆箱，即调用xxxValue方法，比较数值大小。 而\"==”运算符与equals方法不一样的是：当两个操作书都是包装类对象时，比较的是两个引用是否指向同一个地址；如果其中一个操作数是表达式（即包含算数运算），则会触发 自动拆箱过程，之后比较数值是否一致。 有了以上的知识储备，那么问题来了！下面这段代码的输出结果是什么？ public static void main(String[] args) { short s1 = 100; Short s2 = new Short(s1); Short s3 = new Short(s2); Short s4 = Short.valueOf(s1); Short s5 = Short.valueOf(s1); System.out.println(s1 == s2); System.out.println(s2 == s3); System.out.println(s3 == s4); System.out.println(s4 == s5); System.out.println(s1 == s5); } 结果是： true false false true true 逐条分析： s2是通过new方式创建的，没有触发自动装箱过程，所以分配到堆区空间。执行System.out.println(s1 == s2);时，s1是基本数值类型，s2是包装类型，s2会自动拆箱，“==”比较数值大小，所以打印true； 在s3的创建过程中，先将s2自动拆箱，再以new方式创建，没有触发自动装箱过程，分配堆区空间，执行System.out.println(s2 == s3);时，比较的是两个对象的引用是不是指向同一个地址，所以输出false; 在s4的创建过程中，直接调用valueOf方法，由于100属于[-128,127]，所以s4直接指向缓存中的地址。在执行System.out.println(s3 == s4);时，“==”比较两个引用的指向地址，当然返回false； 在s5的创建过程中，直接调用valueOf方法，同样s5会执行缓存中的地址，与s4的指向一样，所以执行System.out.println(s3 == s4);打印true； 执行System.out.println(s1 == s5);s1是基本数值类型，s5是包装类型，\"==\"会触发自动拆箱，所以比较的是s1和s5的数值，打印true; 变式：s1 = 200；其他不变 则打印出 true false false false true 在创建s4和s5的时候，由于200超出[-128,127]的范围，所以都是重新new了一个对象，所以s4 != s5，执行System.out.println(s1 == s5);时候打印fasle；其他分析都一样。 一个更复杂的例子如下: Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c == d); System.out.println(e == f); System.out.println(c == (a + b)); System.out.println(c.equals(a + b)); System.out.println(g == (a + b)); System.out.println(g.equals(a + b)); System.out.println(g.equals(a + h)); 输出结果是: true false true true true false true 分析： 注意第三条，a+b先分别进行拆箱，得到int型的结果，再与Integer型变量c进行比较，C自动拆箱，比较数值，打印true。 第四条，a+b分别拆箱后得到int型结果，再自动装箱成Integer型，此时指向的是缓存中的地址，执行equal时，先比较类型再比较数值，打印true。 第五条，a+b分别拆箱后得到int型结果，g自动拆箱成long型结果，a+b的结果自动提升成long，比较数值相等打印true。 第六条，同样过程，但是a+b是Integer型，而g是Long类，不符，打印false； 第七条，算数运算时，a先自动拆箱，再隐式类型转换，h自动拆箱，两者之和自动装箱，与g的类型相同，再比较数值，打印true； toString方法 包装类的toString方法实现都不太一样。 首先是Byte和Short类，都是直接调用了Integer类的静态toString方法，以Short类为例： public static String toString(short s) { return Integer.toString((int)s, 10); } 而作为整型数值包装类的核心Integer类，其toString方法的实现可以说很巧妙了。Integer重载多种toString方法，最核心的是下面这种： public static String toString(int i) { if (i == Integer.MIN_VALUE) return \"-2147483648\"; int size = (i 首先，看i值是不是Integer能表示的最小值，是的话直接返回字符串，省去了后续的步骤。 变量size值表示i值对应的字符串长度。这一步骤中，先判断i是不是负数，如果是则转为相反数，利用stringSize方法取得值 后加上1（这个“1”当然表示负号占据了一位），否则直接取得stringSize方法的返回值。那么stringSize方法是如何实现的呢？如下： // Requires positive x static int stringSize(int x) { for (int i=0; ; i++) if (x 这里实现读取非负数x的位数的方法就比较巧妙了，借助一个数组下标与数组元素存在某种关系的特殊数组sizeTable，什么关系呢？“下标为i的数组元素就是位数为i+1所能表示的最大十进制数”，比如下标为2的数组元素，即sizeTable[2] = 999，而999是3（= 2 + 1）位数中最大的数。通过非负数与x的比较，可以轻松找到x的位数。【这是不是一个启发呢？！】 好了，找到了size的值，下面就构造的size长度的空字符数组，很好理解，这个数组将来就是放将来要返回的字符串的，果然，下一步getChars方法就是在填充这个数组。其实现如下： static void getChars(int i, int index, char[] buf) { int q, r; int charPos = index; char sign = 0; if (i = 65536) { q = i / 100; // really: r = i - (q * 100); r = i - ((q >> (16+3); r = i - ((q 这个方法到while循环之前都很好理解，那么while循环在做什么呢？ 官方的注释写的很清楚，当i值大于65535的时，每次都都取得这个数的后两位，即为r。怎么取得呢？就是这句话了r = i - ((q 这里的移位运算相当于q * 100，为什么是100？因为2^6 + 2^5 + 2^2 = 100，那为什么这样的写法就可以实现q * 100，不懂得话还是去补点移位运算的基础，这里不讲了。 取得后两位之后,重点来了，分别取得这两位数的个位和十位数并填充进字符数组。这里利用了两个设计巧妙的字符数组DigitOnes和DigitTens，我们暂且先不看这两个数组的内容，就根据buf [--charPos] = DigitOnes[r];这句话，这个DigitOnes应该是什么样的？ 分析如下： r表示的是两位数，其取值为0~99,那么DigitOnes的长度应该是100。假设r = 65，个位是5，那么DigitOnes[65] = 5, 假设r = 15, 那么DigitOnes[15] = 5...依次类推，DigitOnes下标为05，15，25...95的元素都应该是5，同理，下标为01，11...91的元素都应该是1...综上，DigitOnes的结构就很明了了：0~9循环重复10次，数组长度为100。同理可以推理出DigitTens的构成：0~9的数字依次重复10次，数组长度为100。查看源码中的两个数组，果不其然，其设计如下： final static char [] DigitOnes = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', } ; final static char [] DigitTens = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '5', '5', '5', '5', '5', '5', '5', '5', '5', '5', '6', '6', '6', '6', '6', '6', '6', '6', '6', '6', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '8', '8', '8', '8', '8', '8', '8', '8', '8', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', } ; 下面这个for循环的实现和上面差不多，这是这里每次都去一位数，借助的是digits数组，实现原理相似，digits数组设计如下： final static char[] digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' }; 也许你会觉得很奇怪，为什么会有a~z的字母，因为i中不可能会出现字母啊。那是因为这个数组不仅为getchars方法提供服务，而且为后面的进制转换提供服务，进制的范围是2~36。 这个for循环中，q = (i * 52429) >>> (16+3);难以理解，我在网上找到了对这句话的解释： 因为2>>(16+3) = i52429/524288 = 52429.0/524288=0.1000003814697...... 6位的精度已经足够多了，所以就是i0.1。 还是没有能看懂，但是隐约知道是设计者在确定精度。 最后，如果这个数是负数，就将数组第一位置为‘-’。 Integer类的toString方法设计的很巧妙，所以Long类的toString方法沿用了这种方法，甚至直接调用了Integer中的数组，略。 hashCode方法 8基本数值类型包装类都重写了hashCode方法，但是实现的方法个不一样，总结如下： Wrapper Class hashCode() implements Note Boolean return 1231 or 1237; 1231 和1237 是相对较大的的质数，请看这里：http://stackoverflow.com/questions/3912303/boolean-hashcode Character return the character ascii code 返回的是字符的ascii码 Byte return the byte value ranging from -128 to 127 Byte类型只有8位，covert之后成了int型，信息存在低8位中，所以直接返回value值即可 Short return the short value Short类型只有16位，covert之后成int型，信息存在低16位，所以直接返回value值即可 Integer return the int value covert成int型之后返回value值即可 Long return (int)(value ^ (value >>> 32)); 由于最后的hashCode的类型是int, 而int只有32位，所以64位的Long值，要砍掉一半。为了不失去一半的信息，这个expression的意思是，会值的高32位和低32位的值进行exclusive OR的结果，这样就保证结果均会受前后32位的影响，不会丢失信息。如果直接把Long转成int, 那就会丢掉高32位的信息，这就不是好的implementation Float return floatToIntBits(value); 把float 转成bits, 具体的implementation是我不是太懂，大概是把32位的float 直接当成int输出来，不管那些位置信息，例如本来第31位是符号位，第23到30位代表的是指数，但转成int值后，这些值代表的意义都不存在了，仅仅作为普通的int数位 Double bits = doubleToLongBits(value); return (int)(bits ^ (bits >>> 32)); 第一段code与 floatToIntBits(value) 一样。第二段code是与Long.hashCode()一样 String s[0]31^(n-1) + s[1]31^(n-2) + ... + s[n-1] s[i] is the ith character of the string; why use 31? http://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier 这个公式保证String里的第一个character都对最后产生的 hashcode 有所影响 表格内容参考 http://blog.csdn.net/kevin_ut/article/details/8177783 基本数据类型、包装类和String之间的相互转化 下面是一个测试程序： public class WrapperCovertTest { public static void main(String[] args) { /** * 基本数据类型 -----> 包装类 */ int i = 12; System.out.println(i); Integer integer0 = new Integer(i); System.out.println(integer0.toString()); /** * java.lang.NumberFormatException */ /*Integer integer1 = new Integer(\"12abc\"); System.out.println(integer1);*/ Float f = new Float(\"12.0F\"); System.out.println(f); /** * 对于Boolean来说，当形参是\"true\"时，返回\"true\"，除此之外，返回\"false\" */ Boolean b0 = new Boolean(\"true\"); System.out.println(b0);//true b0 = new Boolean(\"abv\"); System.out.println(b0);//false /** * Boolean为引用类型，默认初始化为null */ Order o = new Order(); System.out.println(o.b);//null /** * 包装类 -----> 基本数据类型 * * 调用包装类Xxx的xxxValue()方法 */ int i2 = integer0.intValue(); System.out.println(i2); float f2 = f.floatValue(); System.out.println(f2); boolean b2 = b0.booleanValue(); System.out.println(b2); /** * JDK5.0以后新特性：自动装箱和自动拆箱 */ int ii = 199; /** * 自动装箱 */ Integer i3 = ii; Integer i4 = 200; Boolean b3 = false; /** * 自动拆箱 */ int i5 = i3; boolean b4 = b3; /** * 基本数据类型、包装类 -----> String类:调用String类的静态的重载的valueOf(Xxx x)方法 */ /** * 由于自动装箱，在需要Integer对象类型的参数时，填入int类型的参数会自动装箱为Integer类型; * 由于自动拆箱，在需要int类型的参数时，填入Integer对象的参数会自动拆箱为int类型。 */ int i1 = 1000; Integer integer1 = 888; //方法一： String str1 = i1 + \"\"; String str11 = integer1 + \"\"; System.out.println(str1+\"\\t\"+str11); //方法二： String str2 = String.valueOf(i1); String str22 = String.valueOf(integer1); System.out.println(str2+\"\\t\"+str22); String str3 = String.valueOf(true); System.out.println(str3); /** * String类 -----> 基本数据类型、包装类:调用包装类的parseXxx(String str)方法 */ int temp = Integer.parseInt(str1); System.out.println(temp); boolean b1 = Boolean.parseBoolean(str3); System.out.println(b1); } } class Order { Boolean b; } 参考 http://blog.csdn.net/u013453970/article/details/47414553 启发 jdk中的类都是使用过程中最基础的类，会被频繁使用，所以设计者需要格外注重基础类的方法的效率问题。在读源码的过程中，能很直接的觉察到设计者对效率和资源占用的考量，比如底层实现中，会用移位运算代替乘除，用适当的缓存来减少资源占用，用设计巧妙的直接寻址方式读取值，基于使用概率的考虑合理考量方法和变量复用，还有考虑到计算精度等问题，这些都是设计者设计思想的体现，能给我们在自己设计类时一些启发。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-22 15:27:32 "},"Java基础知识整理/String高效编程.html":{"url":"Java基础知识整理/String高效编程.html","title":"String高效编程","keywords":"","body":"String高效编程 编译器对String的优化 字符串在程序中被频繁使用，所以Java专门针对String类做了很多的性能优化，比如字符串常量池，还有一个措施是编译器对String操作的优化，看下面这段程序： public static void main(String[] arge) { //1 String str1 = new String(\"1234\"); String str2 = new String(\"1234\"); System.out.println(\"new String()==：\" + (str1 == str2)); //2 String str3 = \"1234\"; String str4 = \"1234\"; System.out.println(\"常量字符串==：\" + (str3 == str4)); //3 String str5 = \"1234\"; String str6 = \"12\" + \"34\"; System.out.println(\"常量表达式==：\" + (str5 == str6)); //4 String str7 = \"1234\"; String str8 = \"12\" + 34; System.out.println(\"字符串和数字相加的表达式==：\" + (str7 == str8)); //5 String str9 = \"12true\"; String str10 = \"12\" + true; System.out.println(\"字符串和Boolen相加表达式==：\" + (str9 == str10)); //6 final String val = \"34\"; String str11 = \"1234\"; String str12 = \"12\" + val; System.out.println(\"字符串和常量相加的表达式==：\" + (str11 == str12)); //7 String str13 = \"1234\"; String str14 = \"12\" + getVal(); System.out.println(\"字符串和函数得来的常量相加表达式==：\" + (str13 == str14)); } private static String getVal() { return \"34\"; } 运行结果为： new String()==：false 常量字符串==：true 常量表达式==：true 字符串和数字相加的表达式==：true 字符串和Boolen相加表达式==：true 字符串和常量相加的表达式==：true 字符串和函数得来的常量相加表达式==：false 有了字符串的基础了解，很好理解第一条打印结果和第二句。但是后面几条的结果为什么是这样的呢。看第三句子，编译时编译器发现能够计算出\"12\"+\"34\"的值，它是个常量，就按照第二个例子一样处理，最终str5和str6都指向了同一个内存地址。所以==比较结果为true；第四至第六条打印语句也是这个道理。最后一句，译器发现str14值是要调用函数才能计算出来的，是要在运行时才能确定结果的，所以编译器就设置为运行时执行到String str14=\"12\" + getVal();时 要重新分配内存空间，导致str13和str1是指向两个不同的内存地址，所以==比较结果为false。 少用语法糖，用StringBuilder拼接字符串 Java最甜的语法糖莫过于String类的\"+\"运算了，常用来拼接字符串，但是如果在大量的拼接需求下，还是建议使用StringBuilder来拼接字符串。实际上，“+”的底层实现也是利用了StringBuilder(至少在JDK1.6之后是这样的)。看下面这个例子： public class Test { public void test() { String str = \"\"; for (int i = 0; i 使用命令javap -v Test进行反编译，编译得到下面的字节码： public void test(); Code: Stack=3, Locals=3, Args_size=1 0: ldc #15; //String 2: astore_1 3: iconst_0 4: istore_2 5: goto 30 8: new #17; //class java/lang/StringBuilder 11: dup 12: aload_1 13: invokestatic #19; //Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String; 16: invokespecial #25; //Method java/lang/StringBuilder.\"\":(Ljava/lang/String;)V 19: iload_2 20: invokevirtual #28; //Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 23: invokevirtual #32; //Method java/lang/StringBuilder.toString:()Ljava/lang/String; 26: astore_1 27: iinc 2, 1 30: iload_2 31: sipush 1000 34: if_icmplt 8 37: return LineNumberTable: line 15: 0 line 17: 3 line 18: 8 line 17: 27 line 20: 37 LocalVariableTable: Start Length Slot Name Signature 0 38 0 this LTest; 3 35 1 str Ljava/lang/String; 5 32 2 i I } 从上面代码的注释部分可以看出确实是用StringBuilder实现的，虽然编译器帮我们做了这些事，但是在实际编码的时候，建议还是使用StringBuilder，毕竟这样可以加深你对性能的理解，而且不依赖特定的编译器优化。 String为什么要设计成不可变的 String是不可变类(immutable)，因为被final。但是，final只能让指向不可变，但是并不能保证内容不可变，所以我们还是有办法改变final对象的内容的，能用这种办法改变String的内容么？ 不能，因为String并未提供对内容修改的公共方法，外部根本无法对内部进行修改。 明白了不可变的实现原理，现在来想一想原因，为什么要将String设计成不可变的。这个问题在知乎https://www.zhihu.com/question/31345592 进行了讨论。 不可变的好处，首先是安全。安全可以体现在很多方面。 String是常用的类，我们可能经常用于HashMap和HashSet，作为键值。如果是可变的，我们任意去修改值，破坏了HashSet键值的唯一性。所以千万不要用可变类型做HashMap和HashSet键值。 在并发场景下，多个线程同时读一个资源，是不会引发竞态条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以线程安全。 String是几乎每个类都会使用的类，特别是作为Hashmap之类的集合的key值时候，mutable的String有非常大的风险。而且一旦发生，非常难发现。 参考 String高效编程优化（Java） Java编程优化之旅（二） String类型知多少 Java编译器对String的优化 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-16 14:57:02 "},"Java基础知识整理/正则表达式.html":{"url":"Java基础知识整理/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 表达式集合 表达式全集 正则表达式 - 元字符 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符——需要转义 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 限定符——出现多少次 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从\"贪心\"表达式转换为\"非贪心\"表达式或者最小匹配。比如对于字符串“Chapter 1 - 介绍正则表达式”。 //匹配从开始小于符号 () 之间的所有内容。 //和//只匹配 。 定位符 不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 选择 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中?:是非捕获元之一，还有两个非捕获元是?=和 ?!。 ?=为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，?!为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 正则表达式原理 正则表达式的底层原理是有限状态自动机，详细内容参考 深入入门正则表达式（java） - 匹配原理 - 1 - 引擎分类与普适原则 深入入门正则表达式（java） - 匹配原理 - 2 - 回溯 一些需要注意的地方 捕获组 捕获组就是将正则表达式中子表达式匹配的内容，保存在内存中以数字编号或者显式命名的组里，方便后面引用。 捕获组具有两种形式： 普通捕获组 (Expression) 对于普通捕获组来说，捕获组按照“出现的顺序，从做到右，0表示整个全部匹配内容从1开始”的规则进行编号。例如正则表达式为:(\\d{4})-(\\d{2}-(\\d\\d))，用来匹配格式为yyyy-MM-dd的日期，比如2018-07-15，则匹配结果为： 编号 命名 捕获组 匹配内容 0 (\\d{4})-(\\d{2}-(\\d\\d)) 2018-07-15 1 (\\d{4}) 2018 2 (\\d{2}-(\\d\\d)) 07-15 3 (\\d\\d) 15 命名捕获组（?Expression) 命名捕获组的获取更加可控，例如正则表达式(?\\d{4})-(?\\d{2}-(?\\d\\d))用来匹配字符串2018-07-15，结果是： 编号 命名 捕获组 匹配内容 0 (?\\d{4})-(?\\d{2}-(?\\d\\d)) 2018-07-15 1 year (?\\d{4}) 2018 2 date (?\\d{2}-(?\\d\\d)) 07-15 3 day (?\\d\\d) 15 demo演示可以参考https://blog.csdn.net/yin380697242/article/details/52097679 String text = \"John writes about this, and John Doe writes about that,\" + \" and John Wayne writes about everything.\"; String patternString1 = \"(John) (.+?) \"; Pattern pattern = Pattern.compile(patternString1); Matcher matcher = pattern.matcher(text); matcher.find();//匹配字符串,匹配到的字符串可以在任何位置 int start = matcher.start();//返回当前匹配到的字符串在原目标字符串中的位置 System.out.println(start);//0 int end = matcher.end();//返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置 System.out.println(end);//12 start = matcher.start(1);//第一个分组匹配的内容,也就是John开始的索引位置,0 System.out.println(start);//0 start = matcher.start(2);//第一个分组匹配的内容,也就是writes开始的索引位置,5 System.out.println(start);//5 end = matcher.end(1);//第一个分组匹配的内容,也就是John结束的索引位置,4 System.out.println(end);//4 end = matcher.end(2);//第二个分组匹配的内容,也就是writes开始的索引位置,12 System.out.println(end);//12 start = matcher.start(3);//Exception in thread \"main\" java.lang.IndexOutOfBoundsException: No group 3 Java中使用正则 查看是否包含： public static void main(String[] args) { // 要验证的字符串 String str = \"baike.xsoftlab.net\"; // 正则表达式规则 String regEx = \"baike.*\"; // 编译正则表达式 Pattern pattern = Pattern.compile(regEx); // 忽略大小写的写法 // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); // 查找字符串中是否有匹配正则表达式的字符/字符串 boolean rs = matcher.find(); System.out.println(rs); } 获取组： public class MatchTest { public static void main(String[] args) { String regex = \"[0-9]{5,12}\"; String input = \"QQ120282458，QQ120282458 QQ125826\"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); ArrayList al=new ArrayList(); while (m.find()) { al.add(m.group(0)); } System.out.println(\"去除重复值前\"); for (int i=0;i 使用捕获结果，放到MatcheResult中保存： String sr = \"dada ada adad adsda ad asdda adr3 fas daf fas fdsf 234 adda\"; Pattern pet = Pattern.compile(\"\\\\b(\\\\w{3}) *(\\\\w{4})\\\\b\"); Matcher match = pet.matcher(sr); MatchResult ms = null; while (match.find()) { ms = match.toMatchResult(); System.out.print(\"匹配对象的组结果：\"); for (int i = 0; i 参考 Java原理实现 深入入门正则表达式（java） - 匹配原理 - 2 - 回溯 正则表达式之基本原理 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 14:31:43 "},"Java基础知识整理/OOP.html":{"url":"Java基础知识整理/OOP.html","title":"OOP","keywords":"","body":"OOP 面向对象的三大特征是: 封装：解决了数据的安全性问题 继承：解决了代码的重用问题 多态：解决了程序扩展问题 三种特征要牢记！ 封装 封装性，从字面来看就是把一些信息包装起来，专业一点讲，封装是指利用抽象数据类型将数据和基本数据的操作都封装到一起，使其构成一个不可分割的独立实体。这个独立的实体被叫做“类”。 Java中一个.java文件中可以有多个类，但是只能有一个用public文件修饰的类，并且需要与文件名同名。一个类中可以包含另外一个类，这就是所谓的内部类和外部类。Java是纯面向对象的语言，即没有全局变量和全局方法，所有方法和变量都在类中。 封装的目的在于隐藏。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。 注意上面高亮的这句话，其中“内部细节”，我们指的是“属性”，而“对外接口”是指方法。我们需要保证“属性”的隐秘性和“方法”的开放性。那么，怎么保证呢？用可访问性修饰符。Java中有四种可访问性修饰符：public、protected、（default）和private，访问权限依次减少。这四个修饰符都可以用来修饰属性和方法。一般地，我们将属性都设置为private，那么外部对象如何访问这个属性？每个属性都有get和set方法，而这些方法都是开放的。 属性，有时候也叫做变量，可以有三种分类：实例变量、类变量和局部变量。它们分别有不同的生命周期和作用范围。其中实例变量属于一个对象。什么是对象？对象就是一个类的实例化。比如“人类”是一个类，而“Bob”这个人就是这个类的一个实例。外部访问实例变量必须基于特定的实例。如何得到这个实例？使用构造函数。 构造函数是特殊的方法。特殊在哪里？ ①方法名必须和类名相同 ②无返回值，void也不行。如果有返回值，虽然同名，那么它也只是一个普通的方法而不是一个构造函数。 ③总是伴随着new操作一起调用，在实例化的时候被（系统）自动调用，且只运行一次，而普通方法是在程序执行的时候被（开发人员)调用，且可以被调用很多次。 ④不能被继承，因此不能被覆盖，但是能够被重载。重载的构造函数之间的调用关键字是this。 ⑤如果开发人员没有显式地给出一个构造函数（无论有没有参数），系统会自动生成一个无参构造函数（可访问性修饰符与类的可访问性修饰符一样）。但是！！！如果定义了一个构造函数（无论又没有参数），系统不会生成一个构造函数。所以开发人员最好每次都指定一个无参的构造函数，以免造成严重后果。比如说，在我们使用Class对象的newInstance方法时，即采取反射来得到一个类的对象，由于这个newInstance调用的是该类的无参构造方法，所以如果没有无参数的构造方法，将会抛出异常。 ⑥继承关系中，子类可以通过super来调用父类的构造方法。注意，当父类没有提供无参构造函数时，子类的构造函数就必须显式调用父类的构造函数。如果父类提供了无参构造函数，那么此时子类就不必要显式调用构造函数（此时系统默认调用了）。初始化时，先调用父类的构造函数，然后再调用子类的构造函数。 对于类的实例化，先大致这么多。 继承 继承是指从已经有的类中派生出新的类，关键字是extends。子类继承了父类，子类就可以继承父类的属性和方法。 但是远远没有那么简单，继承是有条件的。 首先，不是什么类都可以被继承的。如果类A对类B没有可见性，或者类A是终类，即被final修饰，那么B就不能继承A。 再者，并不是所有的属性和方法都可以被继承的。子类只能继承父类非私有，即public和protected。另外，构造方法是万万不能继承的。（final的方法可以继承，但是不能重写！） 最后，经过上面两个条件的筛选之后，得到的属性和方法不一定能被继承。为什么呢？因为存在隐藏和方法覆盖。 方法覆盖 方法覆盖也就是我们所说的“重写”。这里的方法是指：可能被继承（还记得能被继承的条件么）的实例方法，注意，不包含静态方法！！！什么情况下能构成重写呢？子类定义的方法需要满足“两同一大一小”原则： ①方法名相同，参数类型相同，即方法签名相同。注意，方法签名是指方法名和参数表，不包含返回值类型。 ②子类访问权限应该大于父类方法的访问权限。比如父类方法的可见性是protected，那么子类必须是public。如果父类是public，那么子类必须是public。 ③子类抛出的异常应该小于父类方法抛出的异常。 如果子类中的某个方法符合上面两个条件，那么子类的方法将会覆盖父类中的方法，而不会继承这个方法。但是如果不满足的话，那个子类和父类中的两个方法是完全没有关系的两个方法，子类可以继承父类方法。 例如B继承了A，A的实例方法test()在B中被重写了。C是B的子类，那么C就无法通过super().super().test()来访问A的test()方法，因为已经被覆盖了。 例如下面这段程序的执行结果是什么？ public class Test { static class Super{ public int f(){ return 1; } } public static class SubSuper extends Super{ public float f(){ return 2f; } } public static void main(String[] args) { Super s = new SubSuper(); s.f(); } } 这段程序会产生编译错误。因为首先SubSuper继承自Super类，其中SubSuper的f方法签名与父类的f方法签名不一致，所以不能覆盖，SubSuper类将集成父类的f方法，这时候两者共存，但是不能构成重载（因为参数列表一直，不能将返回值作为依据），所以这时候会有编译错误。 方法签名是指方法名和返回类型，不包含返回类型。方法签名能唯一确定一个方法 注意“重写”和“重载”的区别：重写要求方法签名完全一致，重载要求方法名一样，但是参数列表不一样。 隐藏 “隐藏”针对的对象是能够被继承的数据域（包括实例变量和类变量 和静态方法)。如果子类中存在同名的数据域或静态方法，那么父类中的数据域或静态方法将被隐藏。 所以隐藏和覆盖有什么区别呢？当然有区别！“覆盖”是原来的没了，消失了，不能访问了。而隐藏说明其实还存在，还有方法可以访问到，怎么访问？可以通过super()调用或者父类类型的引用变量来访问。 诶，记住“父类类型的引用可以用来范围被隐藏的变量和静态方法”，记住这句话。这时候经典的考题来了。看看下面这个例子: //Animal.java public class Animal { public String news = \"Animal's news\"; public static String message = \"Animal's message\"; public static String smile() { return \"smile from Animal\"; } public String getNews() { return news; } public String getMessage(){ return message; } } //Tiger.java public class Tiger extends Animal{ public String news = \"Tiger's news\"; public static String message = \"Tiger's message\"; public String somethingNew = \"Something new from tiger\"; public static String smile() { return \"smile form Tiger\"; } public String getNews() { return news; } public String print(){ return \"The news is \" + news + \" and the message is \" + message; } } //Test.java public class Test { public static void main(String[] args) { Animal x = new Tiger(); System.out.println(\"(1) x.news is \" + x.news); //(1) x.news is Animal's news System.out.println(\"(2) x.message is \" + x.message); //(2) x.message is Animal's message // System.out.println(\"(3) x.somethingNew is \" + x.somethingNews); System.out.println(\"(3)x.smile() is \" + x.smile()); //(3)x.smile() is smile from Animal System.out.println(\"(4)((Tiger)x).smile() is \" + ((Tiger)x).smile()); //(4)((Tiger)x).smile() is smile form Tiger System.out.println(\"(5) x.getNews() is \" + x.getNews()); //(5) x.getNews() is Tiger's news System.out.println(\"(6) x.getMessage() is \" + x.getMessage());//(6) x.getMessage() is Animal's message // System.out.println(\"(7) x.print() is \" + x.print()); } } 程序运行结果已经标注在上面，为什么会是这样的结果。来分析一下。 首先x是一个引用，Animal类型的引用，而实际的类是Tiger，所以它被声明为父类引用，实际运行的类型是子类。前面我们说到方法覆盖和隐藏，这里考的就是这个知识点。 首先news属性是父类Animal的实例属性，而子类中有同名属性，符合继承条件，所以子类隐藏了父类的这个实例属性，但是x是父类类型的引用，所以x.news访问的是父类的实例变量。 接着message是父类的静态属性，而子类中有同名属性，符合继承条件，所以子类隐藏了父类的这个静态属性，没有被继承，但是x是父类类型的引用，所以x.message访问的是父类的类变量。 接着smile是父类的静态方法，而子类中有同名的静态方法，符合继承条件，所以子类隐藏了父类的这个静态方法，没有被继承，但是x是父类类型的引用，所以x.smile访问的是父类的静态方法。 接着getNews是父类的实例方法， 符合继承条件，而子类中有同名的静态方法， 所以子类的方法覆盖了父类的方法，注意是覆盖，父类中该方法已经不能被访问了，所以这时候x.getNews方法的是子类的实例方法。 最后getMessage是父类的实例方法，符合继承条件，而子类中不具有同名方法，所以这个方法是实打实的被继承了，这时候x.getMessage访问的是父类的实例方法，而其中访问的是父类的message类变量。 实际上，上面这个例子就是一个多态的实现。当我们看到类似于Animal x = new Tiger()这种初始化方式的时候，即声明类型和运行类型不一样的时候，要特别小心，记住以下结论： 使用父类类型的引用来访问实例方法的时候，要注意方法覆盖的可能性，变量所引用对象的是实际类在运行时决定使用该方法的哪种实现。 使用父类类型的引用来访问数据域或静态方法的时候，引用变量所声明的类型在编译的时候就决定使用哪个数据域或静态方法。 话题重新回到继承。Java不支持多继承，但是可以用接口和内部类来实现多继承的“效果”，这种方式叫做组合。使用接口与组合的方式比采用继承的方式具有更好的可扩展性，这一点在设计模式中最能体现。两种方式的不同在这里就不多说了。 在继承关系中，经常考察this和super关键字的区别。 this指代当前类的实例对象（注意是对象，这也就是为什么类方法中不能有this关键字的原因），super指代的是父类的实例对象。this可以用来访问本类中的实例变量，而多个重载的构造函数之间的调用是通过this()的形式进行的。子类可以通过super()形式对父类的构造方法进行调用，当存在隐藏和方法覆盖的情况时，可以通过super关键字进行调用，类似于this。 特别注意的是，子类的构造方法可能会由系统隐式调用父类的构造方法，如果开发人员自己显式调用，即用super调用，那么super()必须要放在构造方法的第一句，否则编译报错。 多态 多态是OOP中重要的性质，表示的是同一个操作作用于不同的对象时，会有不同的表现，比如同样是执行“+”操作，对两个整数来说就是数字加和，对于字符串就是字符串连接。在Java中，多态主要有两种表现方式： 方法重载——编译时多态 即overload。在同一个类中有很多同名但参数列表不同的方法。该使用那个方法是在编译的时候就决定了的，是一种编译时的多态，可以看做是同一个类的方法的多态性。 方法覆盖——运行时多态 即Override。Java语言具有下面这个特点： 为父类对象设计的任何代码可应用于子类。“每一个子类的实例都是父类的实例，反之不成立”。 所以一个基类的引用变量不仅可以指向基类的实例对象，也可以指向子类的实例对象（就像上面例子中的Animal类型引用变量）。它所调用的方法在运行期间才动态绑定（绑定是指将一个方法调用和一个方法主题连接到一起），就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。因为是运行时才决定的，所以也叫做运行时多态。 注意方法才有多态的概念，变量是没有多态的概念的。 OOP的题目除了上面的知识点之外，还经常和初始化顺序一起考察。例如： public class Baset { private String baseName = \"base\"; public static String baseMessage = \"baseMessage\"; //构造方法 public Baset() { // TODO Auto-generated constructor stub callName(); } //成员方法 public void callName() { System.out.println(\"baseName : \" + baseName); System.out.println(\"baseMessage : \" + baseMessage); } //内部静态类 static class Sub extends Baset{ //静态字段 private String subName = \"sub\"; public static String subMessage = \"subMessage\"; public Sub(){ callName(); } public void callName() { System.out.println(\"subName：\" + subName); System.out.println(\"subMessage：\" + subMessage); } } public static void main(String[] args) { Baset base = new Sub(); } } 上面程序的输出结果是： subName：null subMessage：subMessage subName：sub subMessage：subMessage 让我们来分析一下这个过程。 首先，当Baset这个类被编译通知后，会在相应目录下生成两个.class文件，一个是Baset.class，另一个是Baset$Sub.class文件，这时候类加载器将这个两个.class文件加载到内存。 接着，main方法中执行 Baset base = new Sub()方法，发现Sub继承了Baset，类，所以会先初始化其静态成员，此题中只有baseMessage这个静态变量，然后执行子类的静态成员初始化，同样是subMessage，注意，此时子类的静态是隐藏了父类的静态变量，这种隐藏是编译的时候就决定了的。然后执行Sub的构造函数，构造函数实际上是省略了对父类构造方法的调用，实际上Sub的完整的构造方式应该是这样的： public Sub(){ super();//调用父类的构造方法 subName = \"sub\"; //子类实例属性的初始化 callName(); } 而父类的构造方法实际上是这样的： public Baset() { // TODO Auto-generated constructor stub baseName = \"base\";// 父类实例变量的输出化 callName(); } 所以在调用Sub构造函数的时候，首先调用的Baset的构造函数，初始化了baseName这个实例变量，然后执行callName方法，注意了，此时调用的是子类的callName方法， 因为存在方法覆盖。而子类的callName方法中将打印subName和subMessage。此时，subName还是默认值null，而subMessage已经被初始化为subMessage。之后回到Sub类的构造函数，进行实例变量subName初始化，接着调用callName方法，此时可以打印出subName和subMessage的值。 有一道题目是如何取得父类的类名。 我们知道利用反射可以取得类名，方法是getClass().getName()，那么是不是可以利用super.getClass().getName()来取得父类的类名呢？就像下面这样： //A.java class A{} //Test.java public class Test extends A { public void test(){ System.out.println(super.getClass().getName()); } public static void main(String[] args) { new Test().test(); //Test } } 打印的结果是Test，为什么不是A。原因在于getClass这个方法在Object中被定义成final和native，子类无法重写，而所有类都是Object的子类，而Object的getClass方法的解释是返回运行时候的类，所以上面的程序中getClass会一直返回运行的类，即Test，所以得不到其父类A的类名。那么有其他办法么？有，通过反射机制getSuperclass。 public class Test extends A { public void test(){ System.out.println(super.getClass().getSuperclass().getName()); } public static void main(String[] args) { new Test().test(); //A } } 下一步就要好好学习反射了。 OOP这部分要好好理解，有很多题目要刷才能查漏补缺 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 15:21:53 "},"Java基础知识整理/修饰符.html":{"url":"Java基础知识整理/修饰符.html","title":"修饰符","keywords":"","body":"修饰符 按照修饰对象的不同，Java修饰符可以分为三类：类修饰符、数据域修饰符和方法修饰符； 按照修饰作用的不同，Java修饰符又可以分为两类：可访问控制修饰符和非可访问控制修饰符。 其中访问控制修饰符是指public、protected、default、private四种，其各自的访问限制范围如下图所示： 现在我们以前者为主要分类标准，后者为辅进行整理。 类修饰符 可访问控制修饰符 public：表示公共类，任意的其他类都能访问该类。 default：缺省，该类只能包内访问 非可访问控制修饰符 abstract：表示抽象类。 final：表示最终类，不能被继承。最终类通常是一些有固定作用、用来完成某种标准功能的类，如StringBuffer、StringBuider。 一个类不能既被声明为abstract，又被声明为final。 当类为内部类的时候，这时候可以将内部类当做一个特殊的成员变量，此时类能够被其他数据域或方法域修饰符修饰。 数据域修饰符 可访问控制修饰符 public：公共访问控制符，任意类都能访问。 protected：保护访问控制符，只能被类本身、子类、同一个包内的类访问。 default：缺省访问控制符，只能包内访问。 private：私有访问控制修饰符，只能被类本身访问。 非可访问控制修饰符 static：静态修饰符。用static修饰的成员变量仅属于 类的变量，而不属于任何一个具体的对象。静态成员变量的值保存于类内存区域的公共存储单元，而不保存在某一个对象的内存区间。任何一个类的对象访问它时取到的都是相同的数据。任何一个类的对象修改它时，也都是对同一个内存单元进行操作。 Java没有全局变量的概念，但是用静态变量可以在一定程度上达到全局的效果。 在Java中，不能在成员函数的内部定义static变量，以下程序编译失败。 public class Test { public static int testStatic() { static final int i = 0; System.out.println(i); } public static void main(String[] args) { Test test = new Test(); test.testStatic(); } final：最终域修饰符，定义常量符号。用来修饰对象的时候，对象引用不可用。 注意，是引用不可变，而不是对象不可变，即只能指向初始时候的那个对象，而不关心指向对象内容的改变。public static void main(String[] args) { final StringBuilder builder = new StringBuilder(\"Hello\"); builder.append(\" World\"); System.out.println(builder); } 以上代码执行结果为Hello World。public static void main(String[] args) { final StringBuilder builder = new StringBuilder(\"Hello\"); builder = new StringBuilder(\"Hello world\"); } 以上代码在编译期间报错。 volatile:易失（共享）域修饰符。说明这个成员变量可能被几个线程所控制和修改。也就是说在程序运行过程中，这个成员变量有可能被其他的程序影响或改变其取值。因此，在使用中要注意这种成员变量取值的变化。通常用来修饰接受外部输入的域。什么意思呢？就是说在多线程访问中，临界区只有一个线程能访问，临界区的操作应该具有原子性，而这个过程中，任何变量的改变必须对外可见，而不是在这个操作完之后才对外可见，这个性质叫做“可见性”。synchronized能够保证原子性和可见性，而其取值。因此，在使用中要注意这种成员变量取值的变化。通常用来修饰接受外部输入的域。什么意思呢？就是说在多线程访问中，临界区只有一个线程能访问，临界区的操作应该具有原子性，而这个过程中，任何变量的改变必须对外可见，而不是在这个操作完之后才对外可见，这个性质叫做“可见性”。synchronized能够保证原子性和可见性，而volatile只能保证可见性，不能原子性（当然不能了，这个修饰符是用来修饰变量的，哪有什么原子性）。 transient：暂时性域修饰符。用来定义一个暂时性的变量。其特点是：用修饰符 transient 限定的暂时性变量，将指定 Java 虚拟机认定该暂时性变量不属于永久状态，以实现不同对象的存档功能。否则，类中所有变量都是对象的永久状态的一部分，存储对象时必须同时保存这些变量。序列化的时候会忽略这些数据。 方法控制修饰符 可访问控制修饰符 public：公共访问控制符，任意类都能访问。 protected：保护访问控制符，只能被类本身、子类、同一个包内的类访问。 default：缺省访问控制符，只能包内访问。 private：私有访问控制修饰符，只能被类本身访问。 非可访问控制修饰符 static：静态方法控制修饰符。静态方法是属于整个类的方法，而不用static修饰限定的方法是属于某个具体对象的方法，有static方法是属于整个类的，所以它不能操纵和处理属于某个对象的成员变量，而只能处理属于整个类的成员变量。static一个重要的用途就是单例模式，即该类只能有一个实例。为了这个功能，必须隐藏类的构造函数，即将构造函数声明为private，并提供一个创建对象的方法，这种方法说就是将创建对象的方法声明为static。 final：最终方法控制符。最终方法是功能和内部语句不能更改的方法，即最终方法 不能重写（注意，final方法不能重写，但是可以继承）。使用final方法的原因有二。一是锁定了这个方法所具有的功能和操作，防止当前类的子类对父类关键方法的错误定义，保证了程序的安全性和正确性，所有被private修饰符限定为私有的方法，以及所有包含在final类（最终类）中的方法，都被认为是最终方法。二是为了效率，早期Java会将final方法转为内嵌调用，即直接将方法主体插入到调用处，而不是进行方法调用（类似于C++中的inline），但是现在已经不需要这种方式了。 abstract：抽象方法控制修饰符。抽象方法是一种仅有方法头，没有方法体和操作实现的一种方法。 native：本地方法控制符。表明实现方法的程序设计语言不是Java。如Obejct中的clone()方法。 synchronized：同步方法控制符。多线程共存的程序中的协调和同步。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-02 23:27:58 "},"Java基础知识整理/类、抽象类、内部类、接口.html":{"url":"Java基础知识整理/类、抽象类、内部类、接口.html","title":"类、抽象类、内部类、接口","keywords":"","body":"内部类、抽象类、接口 经常碰到类、内部类、抽象类、接口的一些概念辨析，找个机会总结一下。 内部类 定义在类内部的类，叫做“内部类”（inner class），与之相对应的叫\"外部类\"(outer class)。内部类是一种编译现象，与JVM无关，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。根据“内部类”和”外部类”是否为成员关系，内部类还可以进一步划分： 成员内部类 成员内部类可以直接使用外部类的所有成员和方法，即使是private的。同时外部类要访问内部类的所有成员变量/方法，则需要通过内部类的对象来获取。 成员内部类不能含有static的变量和方法。因为成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。了解这一点，就可以明白更多事情，在此省略更多的细节了。 在成员内部类要引用外部类对象时，使用Outer.this来表示外部类引用；类似于this，所以这是一个对象引用。 创建内部类的对象，可以使用Outer.Inner obj = outerobj.new inner();这种方法来创建。但是最好创建方式是在Outer中定义一个方法返回一个Inner实例。比如以下这种： class Outer { private String outLable; private static final String str = \"hello world\"; private static void outerStaticMethod(){ System.out.println(\"This is from Outer Class\"); } private Inner inner; public Outer(String outLable) { this.outLable = outLable; } public String getOutLable() { return outLable; } public void setOutLable(String outLable) { this.outLable = outLable; } class Inner{ private String label; Inner(String label){ this.label = label; } public String getLabel() { return label; } void visitInner(){ System.out.println(this.label); } //Outer.this表示外部类对象引用，在局部内部类中可以任意访问外部域的私有域 void visitOuter(){ System.out.println(\"visit Out； \" + Outer.this.outLable); Outer.this.setOutLable(\"Outer2\"); System.out.println(\"After set : \" + Outer.this.outLable + \"\\n\"); //访问外部类中的类变量 System.out.println(\"outer static member: \" + Outer.this.str); //访问外部类中的类方法 Outer.outerStaticMethod(); } } //返回内部类Inner引用 Inner getInnerClass(String innerLabel){ \b if(inner == null){ inner = new Inner(innerLabel); } return inner; } } public class InnerClassTest{ public static void main(String[] args) { //创建成员内部类的方法1： 由外部类内部创建内部类对象 Outer.Inner testInner1 = (new Outer(\"outer1\")）.getInnerClass(\"inner1\"); //创建成员内部类的方法2： 外部类外部创建成员内部类对象 Outer.Inner testInner2 = new Outer(\"outer3\").new Inner(\"inner3\"); testInner1.visitOuter(); testInner2.visitOuter(); } } 上面的例子可以看到，Inner是Outer中的成员内部类，在Inner中可以通过Outer.this来访问外部类中的任意域变量，完全忽视属性（包括可访问性，是成员变量还是类变量）。同时外部类提供了一个内部创建Inner的方法。所以在测试方法中可以看到有两种方式来创建一个内部类对象，建议使用第一种。 以上程序的输出结果为： visit Out； outer1 After set : Outer2 outer static member: hello world This is from Outer Class visit Out； outer3 After set : Outer2 outer static member: hello world This is from Outer Class 上面的例子中，如果要在Outer中使用Inner的成员方法getLabel，该怎么做？ 内部类可以肆无忌惮地访问外部类的域，但是外部域访问内部类的域必须通过新建一个内部类的对象才行。所以应该在Outer中创建这样的一个方法: public String getInnerClassMethod(){ return this.inner.getLabel(); } 其中this.inner是一个内部类的对象实例。在上面这中写法中，如果没有首先给外部类中的成员变量inner初始化，上面这种写法会抛空指针异常。改成return new Inner(\"inner\").getLabel(); 实际上，不用Outer.this，直接写外部类域的名字也是可以访问的。当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。因此，最好是使用Outer.this这种方法取得外部域。 静态内部类 相对于成员内部类，静态内部类多了一个static修饰词。静态内部类是不需要依附外部类的，可以将其看做是类的静态变量，并且它不能使用外部类的非static成员变量或方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类非static成员就会产生矛盾，因为外部类的非static成员必须依附具体的对象。 public class StaticInnerClassTest { public static void main(String[] args) { //创建静态内部类的对象不需要依附于外部类的对象 Outter.Inner inner = new Outter.Inner(); } } class Outter{ private String label; private static String name = \"outter class static member\"; public Outter() { } public String getLabel() { return label; } static class Inner{ public Inner() { } public void visitOuter(){ System.out.println(label); // 这句编译报错，不能访问外部类的成员变量 System.out.println(Outter.this.name); //这句编译报错，不能取得外部类的引用 System.out.println(name); } } } 上面的测试程序展示了静态内部类的创建方法和在内部访问外部类类变量和成员变量的情况。 局部内部类 局部内部类与成员内部类的区别在于：成员内部类定义在类中，而局部内部类定义在方法中，所以局部局部内部类的访问权限仅限于方法内或者该作用域内。 class People{ } class Man{ public Man() { } public People getWoman(){ class Woman extends People{ //这是一个局部内部类 int age = 0; public int getAge() { return age; } } return new Woman(); } } 局部内部类可以看成是一个方法里面的局部变量，所以不能有public、static这种修饰符的。 这里有一个问题，如果获取到局部内部类的对象的属性值呢？比如上面例子中的age。需要给People添加一个getAge方法，然后用getWoman得到的People实例调用这个getAge方法。 匿名内部类 匿名内部类就是没有名字的内部类，通常用来创建只是用一次的类，可以用来简化代码。例如 public class AnonymousInnerClassTest { public static void main(String[] args) { Person p = new Child(); p.eat(); } } abstract class Person{ public abstract void eat(); } class Child extends Person{ @Override public void eat() { System.out.println(\"eat something\"); } } 上面这段代码运行结果是eat something，其中Child继承了Person类，然后实现了Child的一个实例，向上转化成Person类的引用。但是，此时Child只是用了一次，为其单独编写一个类有点浪费。是用匿名内部类可以达到同样的效果。如下： public class AnonymousInnerClassTest { public static void main(String[] args) { Person p = new Person() { @Override public void eat() { System.out.println(\"eat something\"); } }; p.eat(); } } abstract class Person{ public abstract void eat(); } 执行结果同样为eat something，可以看到程序直接将抽象类的方法写到了大括号中，这样就省略了一个类的书写。需要记住，使用匿名内部类必须有一个前提，必须继承一个父类或实现一个接口。上面是一个继承父类的例子，下面是一个实现接口的例子： public class AnonymousInnerClassTest { public static void main(String[] args) { Person p = new Person() { @Override public void eat() { System.out.println(\"eat something\"); } }; p.eat(); } } interface Person{ void eat(); } 匿名内部类常常用于多线程的实现，因为实现多线程必须要继承Thread类或者继承Runnable接口，例如 //继承Thread类 public class ThreadDemo { public static void main(String[] args) { Thread t = new Thread(){ @Override public void run() { for (int i = 0 ; i 打印出： 0 1 2 3 4 5 //实现Runnable接口 public class RunnableDemo { public static void main(String[] args) { Runnable r = new Runnable() { @Override public void run() { for (int i = 0; i 打印出： 0 1 2 3 4 5 局部内部类和匿名内部类都有一个特点，在JDK1.8之前只能访问final修饰的变量（为什么），在JDK1.8中去掉了这个限制，也就是说可以不用final修饰了，但是！变量的值不能改变，这个加上final修饰符是一样的效果，测试如下： public class RunnableDemo { public static void main(String[] args) { test(1); } public static void test(int b) { //这里去掉final限制，下面第二个打印句子编译仍旧可以成功；但是如果在打印之前改变取值，编译不通过 int a = 10; a = 11; //如果在这里改变了a的值，那么下面匿名函数中第一个打印的句子编译不通过， new Thread(){ public void run() { System.out.println(a); //编译报错 System.out.println(b); }; }.start(); } } 上面四种内部类，可以总结一下了： 成员内部类：依附于外部类对象；不能有静态成员和静态方法；无条件访问外部类的一切变量和方法（为什么）；创建时必须通过外部类实例来创建。类比于类成员变量。编译之后会产生Outer$Inner.class的字节码文件 静态内部类：不依附于外部类对象；可以有静态成员和静态方法；不能访问外部类的成员变量和成员方法；可直接通过外部类本身来创建内部类实例（为什么）。类比于类变量。编译之后会产生Outer$Inner.class的字节码文件 局部内部类：不能有修饰词；只能访问值不变的变量。类比于方法局部变量。编译之后会产生Outerx.class的字节码文件，其中x为整数。 匿名内部类：只能访问值不变的变量；必须继承一个父类或实现一个接口。编译之后会产生Outerx.class的字节码文件，其中x为整数。 成员内部类和静态内部类可以看做是一个域，所以用public/protected/default/private/static/final/abstract来修饰【即能修饰域变量的都能修饰内部类，但是final和abstract不能同时出现，不能用transient和volatile来修饰内部类】，而外部类【顶级】类和文件名相同，只能用public/default/final/abstract，final和abstract不能同时出现。 使用内部类的场景及好处 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 方便编写事件驱动程序 方便编写线程代码 第一点最重要！Java不能实现多重继承，但是通过接口或者内部类都实现间接的多重继承，例如下面这个例子： public class MainExample { class Test1 extends Example1{ public String getName(){ return super.getName(); } } class Test2 extends Example2{ public String getAge() { return super.getAge(); } } public String showName(){ return new Test1().getName(); } public String showAge(){ return new Test2().getAge(); } public static void main(String[] args) { MainExample example = new MainExample(); System.out.println(\"姓名:\" + example.showName()); System.out.println(\"年龄:\" + example.showAge()); } } class Example1{ public String getName(){ return \"John\"; } } class Example2{ public String getAge(){ return \"22\"; } } 主类MainExample中定义了两个内部类，分别继承了Example1和Example2，这样我们的MainExample就拥有了Example1和 Example2的方法和属性，也就间接地实现了多继承。 内部类继承问题 内部类很好作为父类被继承，如果要用内部类作为父类继承，要注意两点： 成员内部类的引用方式必须为Outer.Inner。 构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 class WithInner { class Inner{ } } class InheritInner extends WithInner.Inner { // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) { wi.super(); //必须有这句调用 } public static void main(String[] args) { WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); } } 牛客网上有一道题目https://www.nowcoder.com/test/question/done?tid=8408400&qid=5120#summary 用到的内部类的知识点比较多，底下的总结也不错可以看看。 抽象类 如果一个类没有足够的信息来描述一个具体的对象，可以将这个类声明为抽象类。抽象类是一种特殊的类，特殊的地方在于什么地方呢？ 抽象类比一般的类仅多一点的抽象：行为层面的抽象。抽象类可以包含抽象方法。也就是说，一个被abstract修饰的类是抽象类，它既可以包含抽象方法，也可以不包含抽象方法，除此之外，抽象类中可以包含的内容与一般的类没有什么不同（即可以有构造函数、成员变量、成员方法、类变量、类方法等，其中构造方法其实没有什么用，因为无法实例化，成员变量和成员方法也是为了被子类继承，类变量和类方法能用类名直接访问）。但是如果一个类中包含了抽象方法，那么这个类一定得是抽象类。 抽象类类修饰符可以是public abstract或者(default) abstract(默认)，其余任何修饰符（比如final）都不行，为什么？因为抽象类创建的根本目的是什么？是为了让子类继承，那么用final，private，都没有意义了，那么为什么不能用protected来修饰呢？因为protected的作用域是包和包外的子类，而抽象类的设计目的就是为了被继承，所以这样一来protected和public有什么区别呢，所以没必要，同理接口也不能用protected来修饰。 抽象类只能被继承，不能实例化（不管这个抽象类中有没有抽象方法）。而继承抽象类的子类必须实现父抽象类中的抽象方法，否则子类也只能是抽象类。 抽象类中的抽象方法的默认修饰符是(default)abstract。 抽象方法是一种特殊的方法，用abstract关键词修饰，并且没有实现。声明格式是:abstract void fun();注意分号。 抽象方法不能被private/static和abstract同时修饰。 接口 接口是一种行为契约，是对行为的抽象。 接口只能被public、(default)和abstract。默认是default abstract，即包内访问。 接口中可以包含变量和方法。但是要注意！“变量”会被隐式地指定为 public static final变量，并且只能是public static final变量，而且 public static final可省，即默认就是public static final的，即常量。 而“方法”会被隐式地指定为 public abstract方法。在JDK1.8之前，接口中的抽象方法的修饰符只能是public abstract修饰符，方法必须是抽象方法。但是JDK1.8对接口中允许的方法做了更改，如下： interface InterfaceTest { void fun1 (); void fun2(); static void fun3(){ System.out.println(\"java 8 新特性\"); } default void fun4(){ System.out.println(\"java 8 新特性\"); } } 可以看到接口中的方法默认是public abstract，还可以被static和default修饰，此时需要方法体，同时这两种情况下，默认访问修饰符号为public，不能同时出现abstract，而且static和default也不能同时出现。 如果一个非抽象类实现了某个接口，那么它就需要实现该接口中的所有抽象方法；但是如果是一个抽象类实现了某个接口，它可以不实现抽象方法。 有一个有意思的问题，接口到底有没有继承Object类。答案是没有，因为Java中从一个类中派生的必然是另一个类，如果接口继承了Object，那么它必然是一个类，而一个普通类可以继承一个父类，又可以实现多个接口，这就违背了单一继承的原则。另外可以做一个实验，打印一下接口中的方法，比如 public class InterfaceClassTest { public static void main(String[] args) { Set result = new HashSet(); for (Method m : Set.class.getMethods()) result.add(m.getName()); System.out.print(result); } } 结果是 [add, spliterator, forEach, containsAll, clear, isEmpty, remove, removeIf, contains, iterator, removeAll, size, addAll, stream, hashCode, equals, toArray, parallelStream, retainAll] 确实确实不包含Object中的public类型方法，比如toString、wait等。但是问题在于在上述程序中如果加上System.out.println(result.toString());又是正确的。这是因为接口隐含定义了一套与Object类中的方法签名完全相同的方法，所以，我们在程序中调用接口的那些与Object中具有相同签名的方法时，编译器不会报错! 接口和抽象类的区别 接口和抽象类经常被拿来比较，下面做个总结 比较项目 抽象类 接口 默认的修饰符(可省略不写) (default) (default) abstract 可以允许的修饰符 (default)、public、abstract (default)、 abstract、public 是否可以包含构造器 是 否 是否可包含成员变量 是，与一般Java中的变量无差别 是，但是这个变量只能是常量 变量修饰符可允许的组合 无默认 public static final ，默认且唯一 是否可以包含类变量 是 是，且是静态常量 是否可以包含普通成员方法 是 否 是否可以包含static方法 是 是，此时需要方法体，可通过接口名直接访问，不推荐使用 是否可以包含default方法 否 是，此时需要方法体，Java8引入用于最终能顺畅使用Lambda表达式；子类不必强制重写default方法，子类内部通过interfaceName.super.defaultMethodName()调用 方法修饰符可以允许的组合 无默认，能修饰普通类方法都OK （默认）public abstract、static、default 是否可以包含抽象方法 是，但不是必须 是，且必须 是否可以创建实例 否 否 是否可以多继承/实现 否，单继承，extends关键字 是，多实现，implements关键字 设计层面上的区别： 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。类继承是一个 “是不是”的关系，而接口实现则是 “有没有”的关系。 抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范(契约)，它可以跨越不同的类，是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说 对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 网上有一个例子可以解释在设计层面，抽象类和接口的区别： 门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： //抽象类 abstract class Door { public abstract void open(); public abstract void close(); } 或者 //接口 interface Door { public abstract void open(); public abstract void close(); } 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出， Door的open()、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。 interface Alram { void alarm(); } abstract class Door { void open(); void close(); } class AlarmDoor extends Door implements Alarm { void oepn() { //.... } void close() { //.... } void alarm() { //.... } } 内部类编译不会生成字节码文件，但是接口会生成对应的字节码文件。 在学习集合框架的时候发现了一个有趣的问题。Set接口的接口声明是这样的：public interface Set extends Collection，Set是一个接口，Collection是一个接口，他们之间的关键词居然是extends而不是implements。所以我就做了一些实验。 public interface interface implements interface1 {} //这种写法是错误，在implements上面报错 public interface interface extends interface1, interface2{} //这种写法是对的 所以可以得到结论，类只能继承一个父类，用extends关键词，实现多个接口，用implements关键词。接口能继承多个接口，用extends关键词。 参考： Java 的抽象特性：抽象类与接口深度解析 Java内部类详解 java中的匿名内部类总结 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 16:02:25 "},"Java基础知识整理/类编译、加载和执行.html":{"url":"Java基础知识整理/类编译、加载和执行.html","title":"类编译、加载和执行","keywords":"","body":"类编译、加载和执行 一直分不清Java类的整个生命周期的过程，特此整理一下。 JVM 其实重要的就分为两个部分：①编译、加载和执行 ②内存管理和垃圾回收 首先要知道Java文件有三种存在形态。一是.java文件，这是我们开发人员所写的源文件(Source)，是我们用Java程序语言所写的文件。二是.class文件，这是Java特有的字节码（ByteCode）文件，人也能读，但是可读性就没有源文件那么高，专门给JVM读的文件，JVM的存在也就是Java语言跨平台的奥秘所在。三是机器码(Native code)，字节码经由JVM解释运行，所以Java程序的运行要同时经过编译和解释，所以Java是“半解释型语言”。 编译 编译就是编译器帮你把源代码翻译成机器能识别的代码，对于Java来说，这个机器指的是JVM，而JVM能识别的语言是字节码(ByteCode)，另外编译过程还涉及到链接器、汇编器等，我们就统称为编译器。 我们编写源文件，例如test.java文件，使用命令javac test.java，就可以编译该文件。 编译的过程主要有三步骤： 词法分析和输入到符号表 注解处理 语义分析和生成字节码 详细的过程如下： 源代码文件*.java -> 词法分析器 -> tokens流 -> 语法分析器 -> 语法树/抽象语法树 -> 语义分析器 -> 注解抽象语法树 -> 字节码生成器 -> JVM字节码文件*.class 最后生成了字节码文件，即.class文件，使用命令javap -c test可以查看test.class的字节码信息，主要包含三项内容： 结构信息：class文件的相关信息 元数据：Java源码中的声明和常量信息 方法信息：Java源码语句和表达式对应的字节码 一些涉及常量的计算、方法重载、泛型检查和类型擦除都是在这个阶段做的。这时候的检查也叫做静态类型检查。 编译阶段不存在内存分配 加载 开始跑程序了，类就开始被加载了。加载工具是类加载器。 类加载器一共有三个，分别是根类加载器（Bootstrap Class Loader）、扩展加载器（Extension Class Loader）和系统应用加载器（App Class Loader）。其给作用和路径如下： Java程序在执行之前需要检查类是否已经被加载了，这个检查的过程按照“双亲委托”机制来进行。 但是要注意，类并不是一开始就被加载的，只有在除此使用的时候才被加载进来，而且只加载一次。什么时候会加载呢，参见下面类的初始化过程。 加载器的加载过程可以阅读下一篇博文 类在被加载之后，接下来进行连接、初始化，然后才是使用，最后是卸载。 连接 连接（linking）包括三个部分： 验证(verfying)：验证类是否符合Java规范和JVM规范，这个编译阶段的语法分析不同。 准备(preparing)：为类的静态变量分配内存，初始化为系统的初始值（不初始化静态代码块）。对于final static修饰的变量，直接赋值为用户的定义值。 解析(resolving)：将符号引用（字面量描述）转为直接引用（对象和实例的地址指针、实例变量和方法的偏移量） 类初始化 初始化类的静态能量和静态代码块为用户自定义的值。非静态类在实例化类，在Java堆中创建对象的时候，才会进行初始化。初始化的顺序，和Java源码的从上到下顺序一致。注意：什么时候触发初始化？在类被Java程序“第一次主动使用”的时候，才会触发初始化操作（如果还没有加载，则会顺势触发类的加载过程）。 类的初始化顺序参考另外一篇博文\"Java初始化顺序\"。 执行 启动JVM后，操作系统就会给JVM分配内存空间，JVM自己把得到的内容分为八块。 JVM是基于栈结构的体系来执行class字节码的。当一个线程被创建之后，Java栈和PC寄存器就会被创建。Java栈由栈帧组成，调用一个方法，就会生成一个栈帧（可以理解为表示调用一个方法），栈帧又由局部变量表、操作数栈和常量池组成。 执行的时候，每个线程都有一个Java栈，当前执行的栈称为“当前栈”，一个Java栈调用多个方法，就会push进去多个帧，当前活动的帧称为当前栈帧。当前栈帧执行完毕之后，会把执行结果（如果有）压入调用它的那个栈帧的操作数栈中，作为上一个栈帧的一个中间处理结果被调用，然后就会pop出去，当所有调用的方法执行结束后，栈帧也就都pop调用。 例如执行代码： 具体的执行 由执行引擎Execute Engine来完成，将字节码转为机器码，操作系统才能真正执行代码。 执行引擎通过Java字节码解释器（一行一行解释字节码）和JIT(Just in Time，即时编译器)对热代码整段编译来完成机器码的翻译工作。 JIT的工作流程是 JVM字节码 -> 机器无关优化 -> 中间代码 -> 机器相关优化 -> 中间代码 -> 寄存器分配器 -> 中间代码 -> 目标机器码生成器 -> 目标机器码 运行阶段就是保存在磁盘中的代码被装载到了内存中，这样代码才会变成活的。而运行时类型检查和编译时期简单的扫描不一样了，而是在内存中做一些操作，做些判断。比如数组越界，在编译的时候是不会有报错的，运行了之后会出现RuntimeException。 卸载 即GC过程，具体内容查看JVM相关内容。 参考 Java类编译、加载、和执行机制 java编译时与运行时概念与实例详解 Java 面试题问与答：编译时与运行时 JAVA类加载和反射介绍 深入理解Java反射 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 11:07:11 "},"Java基础知识整理/ClassLoader加载机制.html":{"url":"Java基础知识整理/ClassLoader加载机制.html","title":"ClassLoader加载机制","keywords":"","body":"ClassLoader加载机制 从看Class开始，就感觉Java的学习境界更上一层楼了，ClassLoader应该比较接近 JVM了。虽然我不是什么框架开发者，一般来说用不到，但是理解classLoader的加载机制，也有利于我们编写出更高效的代码。尝试看看吧。 什么是ClassLoader 翻译过来就是\"加载器\"，加载什么呢?加载class文件。当我们编写的源文件经过编译后，产生字节码文件，即所谓的class文件，ClassLoader的作用就是讲class文件加载到JVM中，然后程序就可以正确运行了，但是JVM启动的时候，并不会一次加载所有的class文件【那当然了，那么多的class文件，都加载了内存岂不是要爆炸】，而是根据程序的需要，通过类加载机制（ClassLoader)来动态加载某个class文件到内存当中去，只要class文件被载入到了内存之后，才能被其他class所引用。 那么Java的类加载流程是怎样的呢？ 在学习之前先来回顾一下Java环境变量。回忆下，在mac或linux环境下不用配置，但是在windows环境下是需要配置三个环境变量的： JAVA_HOME： 指向JDK的安装位置，一般默认安装在C盘，比如C:\\Program Files\\Java\\jdk1.8.0_91 PATH：将程序路径包含在PATH当中，在命令行窗口就可以直接键入它的名字而不需要键入全路径， 一般的 PATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;%PATH%; 可以看到这里%JAVA_HOME%就是上面提到的JDK的安装位置，%JAVA_HOME%\\bin只的是JDK目录下的bin目录，%JAVA_HOME%\\jre\\bin指的是JDK目录下的jre目录的bin。 CLASSPATH：CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar, 注意前面.;，.代表当前目录，可以看到CLASSPATH指向了jar包路径。 为什么要回顾环境变量呢，因为它和类加载流程关系密切。 Java语言系统自带了三个类加载器： Bootstrap ClassLoader ：称为启动类加载器，用C++语言写的，在JVM启动后初始化的，Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，%JRE_HOME%\\jre\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动JVM时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。 Extention ClassLoader: 扩展的类加载器，Bootstrap ClassLoader加载Extention ClassLoader，并且将Extention ClassLoader的父加载器设置为Bootstrap ClassLoader。Extention ClassLoader是用Java写的，具体来说就是sun.misc.Launcher$ExtClassLoader，Extention ClassLoader主要加载%JAVA_HOME%/jre/lib/ext此路径下的所有classes目录以及java.ext.dirs系统变量指定的路径中类库。 App ClassLoader：Bootstrap ClassLoader加载完Extention ClassLoader后，就会加载App ClassLoader，并且将App ClassLoader的父加载器指定为 Extention ClassLoader。App ClassLoader也是用Java写成的，它的实现类是sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个getSystemClassLoader方法，此方法返回的正是AppclassLoader.AppClassLoader主要负责加载classpath所指定的位置的类或者是jar文档，它也是Java程序默认的类加载器。 这三个是默认的类加载器，当然我们可以根据自己的需要定义自己的ClassLoader，这些类（包括Extension ClassLoader和AppClassLoader都继承java.lang.ClassLoader，而Bootstrap ClassLoader不继承，因为它是用C++写的）。 所以，JVM启动时，三个类加载器组成的初始类加载器层次结构是这样的： 为了更好理解我们进入sun.misc.Launcher类，这是Java虚拟机入口应用： public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); } /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() { return loader; } /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader {} /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader {} 源码有精简，可看出个大概： Launcher初始化了ExtClassLoader和AppClassLoader。 Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty(\"sun.boot.class.path\")得到了字符串bootClassPath，这个应该就是BootstrapClassLoader加载的jar包路径。 用代码检测这个路径是什么内容： System.out.println(System.getProperty(\"sun.boot.class.path\"));，打印输出： /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/resources.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/rt.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/sunrsasign.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/jsse.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/jce.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/charsets.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/jfr.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/classes 这些都是jre目录下的jar包或者class文件。 对于Extension classLoader，我们之前说过可以通过-D java.ext.dirs来添加或改变加载路径，用System.out.println(System.getProperty(\"java.ext.dirs\"));测试后打印输出如下内容： /Users/baoxiaofang/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/ext: /Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java 对于App ClassLoader，加载路径是java.class.path，我们同样打印一下System.out.println(System.getProperty(\"java.class.path\"));,输出： /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/charsets.jar: /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/deploy.jar: .... 打印的实在是太多了就不粘贴过来了。 现在知道了，三个类加载器是通过查阅相应的环境属性：sun.boot.class.path、java.ext.dirs和java.class.path来加载资源文件的。 回想一下，在学习Class类的时，有一个getClassLoader方法用来获取该类的加载器，下面是测试程序 public class ClassLoaderTest { public static void main(String[] args) { ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader.toString()); //sun.misc.Launcher$AppClassLoader@18b4aac2 } } 可见，这个自己写的类的类加载器是AppClassLoader。那么是不是可以尝试打印int或者String这种类型的类加载器呢，进行下面的尝试： public class ClassLoaderTest { public static void main(String[] args) { ClassLoader clsl1 = int.class.getClassLoader(); System.out.println(clsl1.toString()); } } 运行之后抛出java.lang.NullPointerException，用String类尝试也是抛出异常。难道这个类没有加载器，不可能啊，他们使用BootstrapClassLoader加载的。 要解决一个问题，首先要明确一个概念：每个类加载器都有一个父加载器，如下： public class ClassLoaderTest { public static void main(String[] args) { ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(\"ClassLoaderTest类的类加载器是： \" + classLoader.toString()); //sun.misc.Launcher$AppClassLoader@18b4aac2 ClassLoader parentClassLoader = classLoader.getParent(); System.out.println(\"ClassLoaderTest类的类加载器的父类加载器是 ： \" + parentClassLoader.toString()); ClassLoader topParentClassLoader = parentClassLoader.getParent(); System.out.println(\"在往上一层的父加载器是： \" + topParentClassLoader.toString()); } } 打印结果是： Exception in thread \"main\" ClassLoaderTest类的类加载器是： sun.misc.Launcher$AppClassLoader@18b4aac2 ClassLoaderTest类的类加载器的父类加载器是sun.misc.Launcher$ExtClassLoader@610455d6 java.lang.NullPointerException at JavaLangJarTest.ClassLoaderTest.main(ClassLoaderTest.java:22) 可知AppClassLoader的父类加载器是ExtClassLoader，而当打印ExtClassLoader的父加载器的时候抛出了空指针异常。诶？不是说每个加载器都有一个父加载器么？ 实际上，从源码看: ClassLoader之间的继承关系是这样的： getParent()这个方法定义在ClassLoader类中，是这样定义的： public final ClassLoader getParent() { if (parent == null) return null; return parent; } 可以看到，返回的是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两种情况 由外部类创建ClassLoader时直接指定一个ClassLoader为parent。 由getSystemClassLoader()方法生成，也就是在sun.misc.Laucher通过getClassLoader()获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 我们所关注的AppClassLoader和ExtClassLoader都和Launcher类相关，之前贴过代码，需要注意的是下面这几句话： ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader(); loader = AppClassLoader.getAppClassLoader(extcl); 这说明AppClassLoader的parent是ExtClassLoader。 ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数： public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); } 对应到URLClassLoader中的代码是： public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) { super(parent); } 所以，ExtClassLoader的parent是null。 讲到这里明白了：AppClassLoader的父加载器是ExtClassLoader，而ExtClassLoader的父加载器是null。但是我们在开头加载器加载顺序的时候说过，BootstrapClassLoader可以作为ExtClassLoader的父加载器，这又是怎么回事。 之前说过BootstrapClassLoader是由C++写的，是JVM的一部分，但是不是java类，所以无法再java代码中取得它的引用。JVM启动是首先启动BootstrapClassLoader加载器，像int.class、String.class这种都是由它加载的，这也就是为什么之前用getParent对int.class取得父加载器抛出异常的原因。之后，JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例，将BootstrapClassLoader设置为Extension ClassLoader的父加载器，将Extension ClassLoader设置为AppClassLoader的父加载器，这也就是为什么说BootstrapClassLoader是ExtClassLoader的父加载器的原因。 双亲委托机制 一个类加载器查找class和resource时候，采用双亲委托机制？什么意思？ 首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 参考下面这个图 一步步讲： 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 递归，重复第1步的操作。 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。 Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。 可以看出，委托和查询的方向是相反的。 这时候又有一个问题了，JVM是如何判断类相同？有两个标准，一个是类的全称（类加载器实例+包名+类名）;另一个是类加载器。 为什么是这样的顺序，需要从源码中找答案，loadClass是类加载时候执行的方法，这个方法通过指定的全限定类名加载class，定义如下： protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检测是否已经加载 Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //调用resolveClass() resolveClass(c); } return c; } } 可以看到，在加载的时候先用findLoadedClass()查看了缓存，缓存没有的话如果父加载器来执行，否则的话就用JVM内置加载器 BootstrapClassLoader来执行，这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。 如果向上委托父加载器没有加载成功，则通过findClass(String)查找。如果class在上面的步骤中找到了，参数resolve又是true的话，那么又会调用resolveClass(Class)这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。 这段源码体现的就是“双亲委托”机制。 自定义ClassLoader 经过前面的学习发现系统默认的ClassLoader都是通过路径来获取资源，那么我能不能自定义资源路径，再写一个自定义的ClassLoader来获取这些自定义的资源呢。可以，按照下面的步骤。 编写一个类继承自ClassLoader抽象类。 复写它的findClass()方法。 这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。 在findClass()方法中调用defineClass()。 别忘记了，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。这样就能够保证它能访问系统内置加载器加载成功的class文件。 先将下面的.java文件编译成.class，然后放到指定目录下，如D:\\lib, package com.frank.test; public class Test { public void say(){ System.out.println(\"Say Hello\"); } } 然后自定义ClassLoader的示例： public class DiskClassLoader extends ClassLoader { private String mLibPath; public DiskClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } //获取要加载 的class文件名 private String getFileName(String name) { // TODO Auto-generated method stub int index = name.lastIndexOf('.'); if(index == -1){ return name+\".class\"; }else{ return name.substring(index)+\".class\"; } } } 这里有个疑问，为什么父类这么多的方法，偏偏只用重写findClass方法呢？因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法。当在loadClass方法中没有找到类的时候，就会调动findClass方法，所以我们只需要调用这个方法而已，如果没有特殊要求，一般不建议重写loadClass搜索类的方法。 我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。 写一个测试程序： public class ClassLoaderTest { public static void main(String[] args) { // TODO Auto-generated method stub //创建自定义classloader对象。 DiskClassLoader diskLoader = new DiskClassLoader(\"D:\\\\lib\"); try { //加载class文件 Class c = diskLoader.loadClass(\"com.frank.test.Test\"); if(c != null){ try { Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); //通过反射调用Test类的say方法 method.invoke(obj, null); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 运行，会答应出Say Hello。 本文大量参考 http://blog.csdn.net/briblue/article/details/54973413 这篇博客真的写的很好 为什么要使用这种双亲委托模式呢？ 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。 考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患【试想如果一个人写了一个恶意的基础类（如java.lang.String）并加载到JVM将会引起严重的后果】，而双亲委托的方式，java.lang.String永远是由根装载器来装载，避免以上情况发生。因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的ClassLoader。 思考：假如我们自己写了一个java.lang.String的类，我们是否可以替换调JDK本身的类？ 答案是否定的。我们不能实现。为什么呢？我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.*开头的类，JVM的实现中已经保证了必须由bootstrap来加载。 一个完整的ClassLoader工作过程是： 1、装载：查找和导入Class文件 2、链接：其中解析步骤是可以选择的 检查：检查载入的class文件数据的正确性 准备：给类的静态变量分配存储空间 解析：将符号引用转成直接引用 3、初始化：对静态变量，静态代码块执行初始化工作 装载解析之后接下来怎么走？在JVM中都有一个对应的java.lang.Class对象，提供了类结构信息的描述。数组，枚举及基本数据类型，甚至void都拥有对应的Class对象。Class类没有public的构造方法，Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 至于如何初始化，也是有顺序的，看下面一篇博文。 线程上下文类加载器 英文名叫Context ClassLoader，从 JDK 1.2 开始引入，并不是真实存在的，只是一个概念，出现在java.lang.Thread中， public class Thread implements Runnable { /* The context ClassLoader for this thread */ private ClassLoader contextClassLoader; public void setContextClassLoader(ClassLoader cl) { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(\"setContextClassLoader\")); } contextClassLoader = cl; } public ClassLoader getContextClassLoader() { if (contextClassLoader == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { ClassLoader.checkClassLoaderPermission(contextClassLoader, Reflection.getCallerClass()); } return contextClassLoader; } } 发现contextClassLoader只是一个成员变量，通过setContextClassLoader方法设置，通过getContextClassLoader获得。 如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 　　前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。 线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。 参考 http://www.cnblogs.com/doit8791/p/5820037.html 参考： 深入分析Java ClassLoader原理 java classLoader体系结构使用详解 Java ClassLoader机制 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 13:43:11 "},"Java基础知识整理/Java初始化顺序.html":{"url":"Java基础知识整理/Java初始化顺序.html","title":"Java初始化顺序","keywords":"","body":"Java初始化加载顺序 之前学了ClassLoader之后，知道经过委托、加载过程之后，类就开始初始化了，一个类中有那么多的变量方法，再加上继承关系，总得有个顺序吧，这篇博文就是来初始化时候的加载顺序了。 在此之前，先要有些概念要弄明白。 Java三种变量类型 之前我一股脑的把所有的变量都叫“成员变量”，好吧，概念不清楚闹了很多笑话。今天来明确下，下次遇到的时候要说的准确。 Java是纯面向对象的语言，所有的变量方法都需要在某个类的范畴内，这样一来就没有什么全局变量的概念了，而变量在类中的不同位置决定了它属于什么变量 比如下面这个实例： public class Test { //类变量（静态变量） private static int count = 0; //成员变量（实例变量） private int i = 1; public static void main(String[] args) { //局部变量 int j = 1; } } Java有三种变量：类变量、成员变量和局部变量，当然它们各自可能都有别名，你怎么习惯怎么叫，但是要区分开。它们最显著的区别就是位置和修饰符的区别啊，真是位置决定人生，人生有什么大不同呢，下面来总结一下： 类变量（静态变量） 类变量也叫静态变量，在类中用关键字static声明，但是必须在构造方法和语句块之外。 无论一类创建了多少个对象，类只拥有类变量的一份拷贝。那也就是说，类变量被类的所有实例共享了。咦，在某种程序上来说，这是不是就是全局变量的意思了。 静态变量除了被声明为常量之外很少被使用。常量是指声明为public/private，final和static类型的变量。常量，顾名思义，一旦初始化时候就不能改变了。 静态变量被存储在静态存储区，在JVM中称为”方法区”的地方，这是线程不隔离的地方。经常被声明为常量，很少单独使用static声明变量。 静态变量在程序开始的时候创建，在结束的时候销毁。注意了，生命周期是“程序”！ 与实例变量具有相似的可见性，但是为了对类的使用者可见，大多数静态变量声明为public类型。 默认值与实例变量相同，数值型的默认为0，布尔型默认为false，引用型默认为null。变量的值可以在声明时候就定义，也可以在构造方法中指定，还可以在静态语句块中初始化（因为类变量比静态语句块先初始化，所以在静态语句块中可以取到该变量而不会抛出NP） 静态变量可以通过: ClassName.VariableName的方式访问【其实也可以通过对象访问，但是这样做没有意义，并且会抛出警告】 类变量被声明为public static final类型时，类名称必须使用大写字母。如果静态变量不是public和final类型，其命名方法与实例变量以及局部变量的命名方式一致。 静态变量不能被非静态方法使用 成员变量（实例变量） 实例变量声明在一个类中，但在方法、构造方法和语句块之外。 当一个对象被实例化之后，每个实例变量的值就跟着定了。 实例变量在对象创建，在对象销毁的时候销毁。注意，成员变量的生命周期是对象。 实例变量是跟随对象分配在堆上的。 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。 实例变量可以声明在使用前或者使用后。【？没看懂这句话的意思】 访问修饰符可以修饰实例变量。 实例变量对类中的方法、构造方法或语句块是可见的，但一般情况下应该把实例变量设为private，通过set和get方法来进行对实例变量的操作。 实例变量具有默认值，数值型的默认为0，布尔型的默认为false，引用型的默认为null。变量的值可以在声明时候指定，也可以在构造方法中指定。 实例变量可以直接通过变量名访问。但是一般用get方法得到，因为通常将实例变量设置为了private。 局部变量 局部变量声明在方法、构造方法或者语句块中 局部变量在方法、构造方法、或者语句块被执行的时候被创建，当他们执行完之后，变量将被销毁。注意，生命周期是方法或语句块。 访问修饰符不能修饰局部变量 局部变量是分配在栈上的。 局部变量没有默认值，所以局部变量被声明后，只有初始化后才可以使用。 静态代码块和非静态代码块 代码块分为静态和非静态的，写法分别是static{}和{}，前者会在类加载的时执行且只被执行一次，一般用来初始化静态变量和调用静态方法。为什么只有一次，因为类加载在虚拟机的生命周期中类只被加载一次，类加载的原则是延迟加载，即能少加载就少加载，因为虚拟机的空间有限。 下面是一个测试程序： public class Test{ public static void main(String[] args) { try { Class.forName(\"JavaLangJarTest.TestClass\"); Class.forName(\"JavaLangJarTest.TestClass\"); System.out.println(TestClass.x); }catch (Exception e){ e.getStackTrace(); } } } class TestClass { public static int x = 100; public final static int y = 200; public TestClass() { System.out.println(\"Test的构造函数执行\"); } static { System.out.println(\"static语句块执行\"); } public static void display(){ System.out.println(\"静态方法被执行\"); } public void display_1(){ System.out.println(\"实例方法被执行\"); } } 发现只打印出一条static语句块执行，说明类只被加载了一次，无论你new了多少个实例。 除此之外，静态代码块还在哪些时机被加载【其实就是为类的加载时机】： 显示加载的时候，比如用Class.forName()， 或ClassName className; 实例化一个对象的时候，比如将上面main方法中内容改成TestClass testClass = new TestClass();或TestClass testClass = Class.forName(\"JavaLangJarTest.TestClass\").newInstance();。 调用类的静态方法的时候，比如将上面main方法中内容改成TestClass.display(); 调用类的静态变量的时候，比如将上面main方法中内容改成System.out.println(TestClass.x); 但是在这个例子中需要注意两点： 调用了类的静态常量的时候，是不会加载了类的，也就不会执行静态代码块了。比如讲上面的main内容改成System.out.println(TestClass.y);，发现只打印出了200。这是JVM的规定，当访问类的静态变量时，如果编译器能计算就不会加载类，算不出来的时候会加载了类。 在用Class.forName()的时候我们也可以选择不要加载类，比如将Class.forName(\"Test\")改成Class.forName(\"Test\",false,StaticBlockTest.class.getClassLoader())，会发现没有任何输出，即类没有被加载，静态代码块也没有被执行。 类加载的时机有哪些呢？ 第一次创建对象的时要加载类。 调用静态方法时候要加载类，访问静态属性时候会加载类。 加载子类的时候会加载父类。 创建对象引用不会加载类。 子类调动父类的静态方法时： 当子类没有覆盖父类的静态方法时，只加载父类，不加载子类。 当子类有覆盖父类的静态方法时，既加载父类，也加载子类。 访问静态变量，如果编译器可以计算出常量的值，则不会加载类，例如public static final int a = 123；否则会加载类，例如public static final int a = Math.PI; 构造函数 初始化顺序 首先我们看下在非继承关系中，即单个类中，各种变量、方法和代码块的执行顺序，这种例子在网上有很多写的很好的例子，这里直接用下别人的例子： public class InitialOrderTest { // 静态变量 public static String staticField = \"静态变量\"; // 变量 public String field = \"成员变量\"; // 静态初始化块 static { System.out.println(staticField); System.out.println(\"静态初始化块\"); } // 初始化块 { System.out.println(field); System.out.println(\"非静态初始化块\"); } // 构造器 public InitialOrderTest() { System.out.println(\"构造器\"); } public static void main(String[] args) { new InitialOrderTest(); } } 结果输出： 静态变量 静态初始化块 成员变量 非静态初始化块 构造器 如果存在继承关系，那么加载顺序又是怎样的，下面是一个测试例子： class Parent { // 静态变量 public static String p_StaticField = \"父类--静态变量\"; // 变量 public String p_Field = \"父类--变量\"; // 静态初始化块 static { System.out.println(p_StaticField); System.out.println(\"父类--静态初始化块\"); } // 初始化块 { System.out.println(p_Field); System.out.println(\"父类--初始化块\"); } // 构造器 public Parent() { System.out.println(\"父类--构造器\"); } } public class SubClass extends Parent { // 静态变量 public static String s_StaticField = \"子类--静态变量\"; // 变量 public String s_Field = \"子类--变量\"; // 静态初始化块 static { System.out.println(s_StaticField); System.out.println(\"子类--静态初始化块\"); } // 初始化块 { System.out.println(s_Field); System.out.println(\"子类--初始化块\"); } // 构造器 public SubClass() { System.out.println(\"子类--构造器\"); } // 程序入口 public static void main(String[] args) { new SubClass(); } } 结果打印出： 父类--静态变量 父类--静态初始化块 子类--静态变量 子类--静态初始化块 父类--变量 父类--初始化块 父类--构造器 子类--变量 子类--初始化块 子类--构造器 注意到，在实例化一个子类之前，需要将父类和子类全部加载进来，所谓加载进来就是要给给静态变量分配空间并执行静态代码块，然后才开始实例化，因为存在继承关系，所以先实例化父这时候给父类变量分配空间并执行父类的非静态初始化块，然后调用父类的构造函数实例化出一个父类对象，接着才是子类一系列的事情。。。 到了这里，实际上还有一个问题，类加载的时候，静态变量是不是永远都在静态代码块之前呢？成员变量是不是永远都在非静态初始块之前呢？下面是一个测试程序： public class TestOrder { // 静态变量 public static TestA a = new TestA(); // 静态初始化块 static { System.out.println(\"静态初始化块\"); } // 静态变量 public static TestB b = new TestB(); public static void main(String[] args) { new TestOrder(); } } class TestA { public TestA() { System.out.println(\"Test--A\"); } } class TestB { public TestB() { System.out.println(\"Test--B\"); } } 打印结果是： Test--A 静态初始化块 Test--B 可见，静态变量和静态代码块，成员变量和非静态代码块，他们之间的执行顺序决定于谁先声明谁先声明。 总结 到了这里可以总结一下了，Java程序的初始化一般遵循3个原则（优先级依次递减）： 静态对象（变量）优于非静态对象（变量）初始化。其中，静态对象（变量）只初始化一次，而非静态对象（变量）可能会多次初始化。 父类优先于子类进行初始化。 按照变量的定义顺序进行初始化，即使变量定义散布于方法之中，他们依然在任何方法（包括构造方法）被调用之前被初始化。 参考 : Java 变量类型 Java static作用及加载顺序 java中static{}语句块详解 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 13:50:05 "},"Java基础知识整理/反射机制.html":{"url":"Java基础知识整理/反射机制.html","title":"反射机制","keywords":"","body":"反射机制 反射机制非常重要，这关系到Java的语言特性，还和用到的各种Java框架息息相关。 网络上很多教程都是按部就班地告诉你怎么利用反射去做事，但是没有告诉我为什么会有反射这个东西，所以这篇博文搜集各方材料，尽量从原理到实现，层层递进，希望写完这篇博文之后能对反射有所理解吧。 什么是反射 反射允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。 Java反射框架主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法 为什么要用反射 我们为什么要用到反射？在写程序的时候，我们难道不是直接new一个对象，然后用操作对象完成一系列操作的么？但是对于一些写好框架，比如Spring，它的内部处理并不知道用户要写哪些类，这些都是由用框架的人来定的，这时候你还能在Spring内部去new对象呢？当然不能，这时候用户需要去配置文件中去配置路径，这就是一个经典的反射的例子。 反射是在运行的过程中去取得对象的实例的。这里涉及到两个概念：静态编译和动态编译。 静态编译就是在编译的时候把你所有的模块都编译进执行文件，当你启动执行文件的时候，所有的模块都加载进来了。而动态编译就不一样的，在静态编译时候，这些部分还没有编译进去，这样在启动程序（初始化）的手这些模块就不会被加载，而是在运行的时候，用到哪个模块用哪个模块。 例如，写一个阅读器，支持text、pdf和udm三种格式，暂时把读txt、读pdf和读udm定义为三种功能模块。使用静态编译：我想看个txt，点击应用程序图标之后三个功能都加载进来了，然后进行格式判断，使用txt模式，这样的话，另外两个模块的作用就是占用资源。如果使用动态编译，那么我想看个txt，点击应用程序，判断格式，只加载txt模块，使用它读txt模块。 所以很显然，动态编译速度快，节省资源，而且有利于今后拓展。 反射的原理 反射既然这么好，能实现么？为什么能实现？ 能实现！至于为什么，需要从类的加载说起。 JVM内存分区，不多说。具体的分区就是下面这张图。 比如写了Object obj = new Object()，JVM启动之后，这个代码会编译成字节码文件，然后被类加载如内存，放到哪里呢？方法区，这个地方保存了类的一些特性，然后在堆区域创建了Object类的Class对象，注意，这个不是new出来的对象，而一个类的类型对象。每一个类只有一个class对象，作为方法区类的数据结构的接口。之后，JVM创建对象之前，都会先检查类是否加载，寻找类对应的class对象，如果加载好了，就会为你的对象分配内存，初始化也就是代码new Object()。 \"反\"是相对于“正”而言的。一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类去产生实例化对象，但是”反”是通过对象找到类。 这一过程类似于下图 通过上面的图，可以总结出反射的实质是：根据class对象反向获取到到Student对象的各种信息。 所以接下来我们需要了解下Class这个类的作用了。 Class类 Class这个类是对所有类的抽象，比如类是不是接口啊，是不是类啊，类的名字是什么啊，类有哪些公有方法啊，类的加载器是什么啊等等等等。总之是对某一个类本身的一个概括。 每一个类对应了唯一的一个类对象实例（Class对象），这个类对象实例是不能人为去new出来的，那么怎么得到的呢？是类本身被类加载器加载入内存的时候，JVM帮我们创建出来的，这时候，这个class对象就帮我们给这个类做了个登记：谁把它带进来的（类加载器）、名字叫什么（类的全部路径）、是什么身份（是类还是接口）、都有什么功能（实现了什么接口、继承了谁、有多少方法、有多少注解等），相当于有了一个花名册，这个花名册放到哪里呢？放在当前线程的堆中的区域。以后遇到一个类的时候，判断这个类来没来啊（是不是被加载进来了），就要去花名册看看，有的话就找到这个类，然后实例化一个类对象，没有的话就通知类加载器：这人没来，帮我找找然后来我这边登记。 就是这么一个过程啊。 如果我们拿到了花名册，是不是可以用等级的信息为所欲为了呢。完全可以啊。这里的“为所欲为”说的是打破封装原则，拿到这个类的所有属性和方法，比如原来不能通过类的实例访问私有属性，现在通过这个“花名册”中的记录，我们能做任何事情了。 那么问题来了：花名册好办，就是Class这个类，我们怎么取得上面的特定的记录呢？比如我想要拿到叫”Student“这个名字的花名册记录？有三种方法： 通过类名，从花名册中找。 已经知道了类名，我们直接可以利用Class类的静态方法，例如： Class studentClass = Class.forName(\"Student\"); 比如我们在使用JDBC的时候会使用这种方法来加载数据库驱动： Class.forName(\"com.mysql.jdbc.Driver\"); 通过已经实例化的对象 每个类的实例都有一个方法指向了这个类的类对象，这个方法叫做getClass，这是继承自Object的方法，我们可以通过这个属性得到类对象。例如：Student student = new Student(); Class studentClass = student.getClass(); 通过类本身的静态方法 类本身就也有就可以知道自己的类对象的地址，这个属性是class属性。例如Class studentClass = Student.class; 好了拿到了类对象，真的可以为所欲为了，可以做什么事呢？ 很多很多，比如我想用它实例化一个对象：Student sdt = studentClass.newInstance()。 想看看它是不是一个接口：boolean isInterface = studentClass.isInterface()，想要获取类的所有的属性和方法，想要获取特定的属性等等，想怎么做就怎么做。 常用的一些操作要眼熟，比如最常用的是获取类的对象。 Class类位于java.lang包下，其具体方法可以参考“源码解读——Class\" 当然，这其中还涉及到其他一些相关的类，都在java.lang.reflet子包下面，具体的有 java.lang.reflect.Constructor java.lang.reflect.Field java.lang.reflect.Method java.lang.reflect.Modifier 这些类的具体实现可以参考\"源码实现\"中的相关博客。 这五个类的常见用法要熟悉，具体的可以参考深入解析Java反射（1） - 基础这里的讲解。 一些常用的操作要熟悉: 获取类对象的方法（3种） 创建一个类的对象的方法（3种） 触发一个对象的方法操作（2种） 判断是否为某个类的实例 获取域、方法、构造器 利用反射创建数组，详见Array类的源码解读 反射会破坏封装性，而且会消耗额外的系统资源，所以不是非必须情况下还是不要用反射，但是反射非常重要，它是各种框架实现的基础。 下一步，就要看看在Spring是如何利用反射的。 参考 深入解析Java反射（1） - 基础 学习java应该如何理解反射？ Java程序编译和运行的过程 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 10:14:07 "},"Java基础知识整理/防御式编程和契约式编程.html":{"url":"Java基础知识整理/防御式编程和契约式编程.html","title":"防御式编程和契约式编程","keywords":"","body":"防御式编程和契约式编程 程序的健壮性是软件成功的重要指标。为此提出了防御式编程和契约式编程的思想。 防御式编程 这一概念来自于防御性驾驶。在防御式驾驶中要建立这样一种思维：那就是你永远不能确定另一位司机将要做什么，你要承担起保护自己的责任，哪怕错误不是你自己产生而是由其他司机产生的，这样才能确保在其他人做出危险动作时保证你自己不会受到伤害。 所以防御式编程的主要思想是：子程序应该不因传入错误的数据被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改。 一般的高级程序设计语言都提供了【断言】和【异常】两种方式来进行错误处理。两者具体的实现在此略过不谈，在这里我们主要解决的问题是：两者的区别是什么？ 首先【断言】是语言层次的防御式编程方法，是一种开发阶段使用的，让程序在运行时候进行自检的代码。用来处理绝不应该发生的状况，是用来检查内部逻辑的是否产生了错误。 举个例子：加入一个函数的参数是某数据流，这个数据流是软件下层通过读取文件传进来的，调用这个函数的时候，内部逻辑已经确定正确读取到了这个文件，否则是不会调用这个函数的。那么我们可以在这个函数的开头，对这个参数进行断言加以检查。 诶？这里有一个疑问，你不是说如果没有读到文件就不会调用这个函数呢，这时候已经调用了这个方法，那么这个参数一定是存在的，那么再进行这么一次参数检查岂不是多此一举？ 话是没错，上面这个假设是建立在你的逻辑正确的情况下，要是你本身的逻辑错误怎么办？即使逻辑错误，如果发生内存的意外析构，那又怎么办？这时候函数开头的断言就很有用了，它可以用来寻找程序逻辑的bug。 从上面的例子很容易看出，断言是给程序员看的，用来检查内部的逻辑错误，是属于开发阶段的一种调试手段。为什么呢?因为默认情况下，断言是不被开启的，在产品阶段，断言是不起作用的，所以，断言中不能出现执行代码！ 另外一种手段是【异常】，当代码出现问题时，可以通过抛出异常进行通知，如果无法处理就交给调用者进行处理。使用异常需要注意的一点是，不要过度，也不要把所有的代码都直接try-catch。一方面不好找bug，一方面降低代码性能。 契约式编程 “契约”就是双方约定的一些条件，作用于两方，每一方都会完成一些任务，从而促进契约的达成。同时，每一方也会接受一些义务，作为制定契约的前提，如果有一方没有尽到义务，那么契约无效。 契约式编程要求在【前提条件】、【后继条件】和【不变量条件】进行契约检查，这点和防御式编程有一点像，具体差别在哪里，目前我尚不能参透，暂且搁置。 参考 契约式编程与防御式编程 防御式编程 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-22 15:26:02 "},"Java基础知识整理/异常处理机制.html":{"url":"Java基础知识整理/异常处理机制.html","title":"异常处理机制","keywords":"","body":"异常处理机制 《Java编程思想》中对“异常”的解释是： 阻止当前方法或作用域继续执行的问题 所以异常是导致程序失败的可能原因，Java异常处理就是要告诉开发人员，程序出现了不正常的情况，需要注意。 异常处理机制，目的就是将错误的地方和错误处理的地方分离，从而避免因为在有可能产生错误的代码中加入过多的错误检测，影响程序本身的执行逻辑。 在C语言中，通常都是通过函数返回值进行判断并采取响应措施的，给程序员带来了非常大的工作量，并且逻辑混乱。C++和Java都采取了异常处理机制。 Java异常层次结构 下面这张图清晰地概括了Java异常的层次结构： 首先Throwable是所有异常类的“顶级”父类（这种说法不是很正确啦，因为所有类的的顶级父类是Object，我这里指的是在异常领域内的意思，所以加了引号，不要在意细节~），这个类里面定义定义了很多底层的东西，比如异常消息message，异常原因cause，堆栈轨迹stackTrace及相应的调用方法等。 往下分出了两个子类Error和Exception。 其中Error属于严重错误，大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。这类异常不需要捕捉。按照Java惯例，我们是不应该是实现任何新的Error子类的！ 而Exception是合理的应用程序想要捕获的条件。 而Exception又分出了两个派别Checked Exception和Unchecked Exception，两者有什么区别呢？ Checked Exception: 受检查的异常，其必须被try-catch语句块所捕获，或者通过throws子句声明。之所以命名为Checked，是因为Java编译器和JVM都要进行检查，以确保这个规则得以遵守。假如子类可能产生A异常，那么在父类中也必须throws A异常。 Unchecked Exception：不受检查的异常，这类异常不能通过代码来试图解决，所以称为Unchecked exception。程序无需捕捉这类异常，“无需”的意思就是程序员可以分析代码决定是不是要进行捕获和处理。 上图中，Exception下的子类中，粉色的是Checked Exception，蓝色的是Unchecked Exception，可以看到后者都是RuntimeException的子类，RuntimeException名字起得的就很有意思是，表示JVM运行时候引发的错误。 对于上面三种类型的异常，我们应该使用哪种异常？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。 如果以Checked和Unchecked来划分的话，Error也是Unchecked的，所以上图中Error也标注成了蓝色。 需要记住一些常见的异常是属于哪一类的!!!主要记住常见的RunTimeException有哪些？主要空指针异常、数组越界异常、数学计算异常（？这样翻译好像不对劲...囧） Throwable类 看源码可以看到，Throwable非常重要，因为它定义了底层实现细节，下面列出的是该类的一些关键点： message：这个属性保存了关于异常类的说明，可以通过String getMessage()获得。另外还有一个方法String getLocalizedMessage()可以获得，用户可以重写getLocalizedMessage从而生成自定义的消息格式，如果没有重写，则与getMessage输出相同。要设置message必须通过构造函数。在toString方法中会调用这个getMessage得到这个信息说明。 cause：因由。当我们在捕获到一个异常后想抛出另一个异常，并且希望把原始的异常信息保存下来，就可以调用构造器把原始的异常对象保存到新的Throwable的cause中，如Throwable(String message, Throwable cause)。或者构造新的异常对象时没有初始化cause，则可以调用Throwable initCause(Throwable cause)，这个方法最多只能调用一次，也就是说cause一旦初始化了就不能再设置。 可以把cause看成是链表元素中指向上一个元素的引用，所以最终将形成一条异常链。异常链的信息会在printStackTrace()中打印出来。 StackTrace：轨迹栈。栈轨迹记录了程序从开始到异常抛出点所调用的方法。通过StackTraceElement[] getStackTrace()可以获得一个StackTraceElement的数组，每个StackTraceElement记录一个栈帧，0号元素表示栈顶，由栈的FILO规则可知0号元素表示最后调用的方法，而栈底则表示第一个调用的方法，一般就是main了。 Throwable提供了一个打印栈轨迹的方法void printStackTrace()，输出到System.err,如要输出到其它地方，可调用printStackTrace(PrintStream s)或void printStackTrace(PrintWriter s)。 重抛异常时，异常对象的所有信息保持不变，所以printStackTrace()打印的将是原来异常抛出点的调用栈信息，而非重新抛出点的信息。要想更新这个信息，可以调用Throwable fillInStackTrace()，该函数将产生一个新的Throwable对象，它是通过把当前的调用栈信息填入原来那个异常对象而建立的。调用fillInStackTrace()的那一行成了异常的新发生地。不过fillInStackTrace()要生效必须保证StackTrace是可写的，这个可通过调用构造器Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)实现。 SuppressedException：被屏蔽的异常。保存被屏蔽的异常，可通过Throwable[] getSuppressed()获得。添加的话用addSuppressed(Throwable exception)，这个函数一般是在try-with-resources语句中由自动调用的。try-with-resources和suppressedExceptions都是JDK1.7的新特性，会在后面try-with-resources的学习中讲到。 throw和throws 异常处理中除了try-catch-finally之外还有两个关键字，throw和throws，throw用来抛出异常，throws用在方法签名中，用来声明该方法可能抛出的异常。Java允许在catch块中重新抛出异常，交给调用者。 下面是一个很好的例子： public class Junk { public static void main(String args[]) { try { a(); } catch(HighLevelException e) { e.printStackTrace(); } } static void a() throws HighLevelException { try { b(); } catch(MidLevelException e) { throw new HighLevelException(e); } } static void b() throws MidLevelException { c(); } static void c() throws MidLevelException { try { d(); } catch(LowLevelException e) { throw new MidLevelException(e); } } static void d() throws LowLevelException { e(); } static void e() throws LowLevelException { throw new LowLevelException(); } } class HighLevelException extends Exception { HighLevelException(Throwable cause) { super(cause); } } class MidLevelException extends Exception { MidLevelException(Throwable cause) { super(cause); } } class LowLevelException extends Exception { } } try-catch-finally 前面说到开发者可以在程序中捕获异常，怎么捕获？通常用到的就是try-catch-finally。一般的写法如下： try { //代码区域 }catch (Exception e){ //异常处理区域 }finally { //资源清理区域 } try：用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch：用于捕获异常。catch用来捕获try语句块中发生的异常。可以有很多个。 finally：finally语句块总是会被执行，不管有没有抛出异常，不管异常有没有被捕获。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 针对try-catch-finally语句，需要注意一下几点： catch和finally至少得出现一个。如果catch出现了，必须紧跟着try。即try-catch-finally可能出现的组合形式有：try-catch、try-catch-finally、try-finally，不能存在try-finall-catch这种形式。 catch可以有很多块，但是要注意异常匹配的顺序，先子类后父类，为什么这样呢？因为异常匹配的过程是一旦比配成功后面的就不执行了，这个switch的case是不一样的。 finally语句块总是会被执行，不管有没有抛出异常，不管异常有没有被捕获\"，这句话成立有个前提，就是在程序进入try语句块之前没有出现程序退出以及try和catch块执行的过程中没有发成程序的意外退出，比如System.exit(0)，如果是这个样的话，那整个程序就退出了，finally块不会再执行了。 除了下列情况，总将执行 finally 做为结束： JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击 关于try块中return语句是笔试中经常遇到的问题，关于return语句有这样的结论： return语句不是函数的最终出口，如果有finally语句，这在return之后还会执行finally，return的值会存放在栈里面，等待finally执行再返回) 如果return出现在finally中，那么它会覆盖掉之前出现过的语句，并且执行后将执行权立即返回给调用者。 下面是一个典型的考察return的例子： public class ExceptionTest { public static void main(String[] args) { System.out.println(\"=============NoException==================\"); System.out.println(NoException()); System.out.println(\"===============================\"); } public static int NoException(){ int i = 10; try{ System.out.println(\"i in try block is：\" + i); //10 i = i/0; return --i; } catch(Exception e){ System.out.println(\"i in catch - form try block is：\"+i); //10 --i; // 9 System.out.println(\"i in catch block is：\" + i);//9 return --i; //8 } finally{ System.out.println(\"i in finally - from try or catch block is--\"+i);//8 --i; //7 System.out.println(\"i in finally block is--\" + i); //7 return --i; //6 } } } 程序执行结果是： =============NoException================== i in try block is：10 i in catch - form try block is：10 i in catch block is：9 i in finally - from try or catch block is--8 i in finally block is--7 6 =============================== 程序执行的过程如下：在try块中首先输出了i的值，是10，然后执行除法，这时候发生了RuntimeException，具体的是MathException，因为除数为0，这时候直接被catch捕捉到了异常（也就是说try块中的return根本就没有执行），然后输出此时的i值，还是10，之后自减为9，输出9，接着执行return语句，首先是自减为8，发现有finally块，就将这个值保存在栈中。在fianlly块中先打印当前i值，为8，然后自减为7，打印出7，再执行return，执行自减，变成6，上面说过，finally中如果return语句就会覆盖以前所有的return语句。所以返回的i的值是fianlly块中的执行结果6。 这个题如果将所有的前置自减改成后置自减，那会是什么结果呢？同样做了实验，结果如下： =============NoException================== i in try block is：10 i in catch - form try block is：10 i in catch block is：9 i in finally - from try or catch block is--8 i in finally block is--7 7 =============================== 各块的执行语句顺序没有什么变化，主要还是return i--这句话，先执行的是return，即原始值，然后在执行自减的。 如果这道题去掉了finally块中的return语句（后置递减的情况下），程序就会变成这样： public class ExceptionTest { public static void main(String[] args) { System.out.println(\"=============NoException==================\"); System.out.println(NoException()); System.out.println(\"===============================\"); } public static int NoException(){ int i=10; try{ System.out.println(\"i in try block is：\"+i); i = i/0; return i--; } catch(Exception e){ System.out.println(\"i in catch - form try block is：\"+i); i--; System.out.println(\"i in catch block is：\"+i); return i--; } finally{ System.out.println(\"i in finally - from try or catch block is--\"+i); i--; System.out.println(\"i in finally block is--\"+i); } } } 最后输出结果是 =============NoException================== i in try block is：10 i in catch - form try block is：10 i in catch block is：9 i in finally - from try or catch block is--8 i in finally block is--7 9 =============================== try-catch-finally 三者的执行顺序的深入分析可以参见 http://www.cnblogs.com/aigongsi/archive/2012/04/19/2457735.html try-catch-finally语句可以嵌套。 fianlly块常用来清理资源。写法有很多用，例如一个文件读取文件的例子，这样的例子在JDBC的操作中也十分常见： public void readFile(String file) { BufferedReader reader = null; try { reader = new BufferedReader(new InputStreamReader( new FileInputStream(file))); // do some other work } catch (FileNotFoundException e) { e.printStackTrace(); } finally { reader.close(); } } 或者 public void readFile() { BufferedReader reader = null; try { reader = new BufferedReader(new InputStreamReader( new FileInputStream(\"file\"))); // do some other work //close reader reader.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 注意两个方法的区别，前者考虑到由于finally子块一定被执行，所以将资源释放放到finally子块中。后者考虑到需要及早关闭资源，但是后者有一个问题在于reader.close()可能也会抛出异常，这样的话程序会在异常的地方跳出，不会执行后面的代码，此时我们可以用try-finally块来嵌套改造： public void readFile() { BufferedReader reader = null; try { try { reader = new BufferedReader(new InputStreamReader( new FileInputStream(\"file\"))); // do some other work // close reader } finally { reader.close(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 当然对于前者的写法，也可以采取下面的这种改造方法： public void readFile(String file) { BufferedReader reader = null; try { reader = new BufferedReader(new InputStreamReader( new FileInputStream(file))); // do some other work } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } 这两种写法，在网上看到的http://www.cnblogs.com/focusj/archive/2011/12/26/2301524.html 偏向于在try块中关闭。 将try块写的简短，不要什么东西都往里面扔，尽量分析出哪几行程序可能出现异常，只是对可能出现异常代码进行try。尽量为每一个异常写一个try-catch，避免异常丢失。 try-with-resources 前面说到资源作为对象，必须在程序程序结束之后关闭，一般的做法就是放到finally块中进行手动关闭。JDK1.7之前我们都是这样做的，1.7及之后版本我们就可以使用try-with-resources语句，必须要再手动关闭资源。 try-with-resources语句确保在语句的最后每个资源都被关闭，任何实现了java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resources来实现异常处理和关闭资源。用法如下： private static void customBufferStreamCopy(File source, File target) { try (InputStream fis = new FileInputStream(source); OutputStream fos = new FileOutputStream(target)){ byte[] buf = new byte[8192]; int i; while ((i = fis.read(buf)) != -1) { fos.write(buf, 0, i); } }catch (Exception e) { e.printStackTrace(); } } 注意看语法有什么不同了？之前的try是一块，现在try语句多了一个括号，而括号中就是一个资源对象。 在try后面加上括号，再初始化对象的语法叫做try-with-resources。这是Java的一颗语法糖。比如: try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } 就相当于： BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { if (br != null) br.close(); } 在使用try-with-resources语句的时候，异常可能会发生在try语句中，也可能发生在释放资源（即调用close方法）时。 如果异常发生在try语句中，则异常正常抛出，而资源也正常释放；如果try和释放过程都出现了异常，那么最终抛出的异常是try语句中的异常，在释放资源的过程中发生的异常被称为\"被抑制的异常\"，即SuppressedException，通过Throwable.addSuppressed方法被添加进去。 try-with-resources怎么实现的呢?可以参考http://blog.csdn.net/hengyunabc/article/details/18459463 try-with-resources语句做出了很多的改进： 声明多个资源。例如： public class AboveJDK7_2 { public static void writeToFileZipFileContents(String zipFileName,String outputFileName) throws java.io.IOException { java.nio.charset.Charset charset = java.nio.charset.Charset.forName(\"US-ASCII\"); java.nio.file.Path outputFilePath = java.nio.file.Paths.get(outputFileName); //打开zip文件，创建输出流 try ( java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName); java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset) ) {//遍历文件写入txt for (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) { String newLine = System.getProperty(\"line.separator\"); String zipEntryName = ((java.util.zip.ZipEntry) entries.nextElement()).getName() + newLine; writer.write(zipEntryName, 0, zipEntryName.length()); } } } } 这是一个在一个ZIP文件中检索文件名并将检索后的文件存入一个txt文件中的例子，这个例子无论是正常执行还是有异常抛出，zf和write都会执行close()方法，不过需要注意的是JVM里调用的顺序和声明的顺序相反，即调用的顺序是 writer.close(); zf.close(); 在使用的时候要注意资源关闭的顺序。 catch多种异常。例如在1.7之前可能会有如下的try-catch块： try{ //逻辑代码 }catch (IOException ex) { logger.log(ex); throw new SpecialException(); catch (SQLException ex) { logger.log(ex); throw new SpecialException(); } 两个不同的异常但是处理过程是一样的，写的很难看，在1.7之后可以采取这样的写法： try{ //逻辑代码 }catch (IOException | SQLException ex) { logger.log(ex); throw new SpecialException(); } 其中ex是隐式的final，不可以在catch块中改变ex。 catch多种异常后抛出新异常。例如在1.7之前，在方法声明中抛出的异常如果在方法体内没有抛出是不允许的。例如： static class FirstException extends Exception { } static class SecondException extends Exception { } public void rethrowException(String exceptionName) throws Exception { try { if (exceptionName.equals(\"First\")) { //如果异常名称为\"First\"，则抛出异常一 throw new FirstException(); } else { //否则的话，则抛出异常二 throw new SecondException(); } } catch (Exception e) { throw e; } } 1.7 之后就可以用这样的办法了： static class FirstException extends Exception { } static class SecondException extends Exception { } public void rethrowException(String exceptionName) throws Exception, FirstException, SecondException { try { // 逻辑代码 }catch (Exception e) { throw e; } } 之前说到能被try语句管理的资源需要实现两个接口，否则会有编译错误。当释放资源的时候，close方法被自动调用。Java类库中已有不少接口或类继承或实现了这个接口，使得它们可以用在try语句中。在这些已有的常见接口或类中，最常用的就是与I/O操作和数据库相关的接口。与I/O相关的java.io.Closeable继承了AutoCloseable，而与数据库相关的java.sql.Connection、java.sql.ResultSet和java.sql.Statement也继承了该接口。如果希望自己开发的类也能利用try语句的自动化资源管理，只需要实现AutoCloseable接口即可。 multi-catch multi-catch是1.7的新特性，就是说之前我们定义了很多catch块中的异常可以合起来写了，比如在1.7之前 import java.io.*; public class Hello { public static void main(String[] args) { try { throw new IOException(\"我错了\"); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } 先子类后父类，在1.7之后可以使用multi-catch语法： import java.io.*; public class Hello { public static void main(String[] args) { try { throw new IOException(\"我错了\"); } catch (IOException | Exception e) { e.printStackTrace(); } } } 但是这在IOException | Exception e处出现编译错误，原因是multi-catch语法中的异常不能相交，即不能有父子关系，如果是IOException | ClassNotFoundException这种的就可以编译通过。 参考 Throwable、Error、Exception、RuntimeException 区别 联系 异常处理 - Checked还是Unchecked java中关于try、catch、finally中的细节分析 有效处理Java异常三原则 关于Java中try-catch-finally-return的执行顺序 Java7里try-with-resources分析 JDK1.7中的multi-catch的变化 你真的了解try{ return }finally{}中的return？ Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-23 09:29:05 "},"Java基础知识整理/断言.html":{"url":"Java基础知识整理/断言.html","title":"断言","keywords":"","body":"断言 在看Objects类的时候发现如果调用了Objects类的私有构造函数，将会抛出AssertionError异常，该类继承自Error，是非常严重的、不可错误的异常，开发人员需要对其进行处理。先不管这个异常是如何使用的，首先这个名字让我立即想到了“assert”这个关键字，我一直认为这是一个鸡肋，因为同样的功能使用if-else或者异常就可以代替，断言有什么用呢？ 最近在看JDK源码，并且在项目中经常看到别人用断言语句，另外就是测试的时候经常用，意识到自己可能忽略了，断言是可以改善代码质量的，所以这次重新捡起来。 首先需要了解语法。 语法 assert是JDK1.4中引入的新关键字，用于在程序开发中创建“断言”。什么是断言？就是“断定会出现某种情况，如果结果非预期，那么就一定是哪里发生了错误”，它具有两种语法形式： assert Condition 这里的condition必须是一个结果为true的布尔表达式。它表示，“预期结果一定为真，如果预测失败了，就一定哪里出了问题”。即如果表达式为true，就是预期的值，那么什么也不做，程序该怎么走就怎么走。如果表达式的结果为false，预计失败了，那么就抛出一个AssertionError异常，它继承自Error类，属于JVM严重错误了。 assert Condition: expr 这里的condition和上面一样，是一个预期结果为true的布尔表达式。如果预期对了，那么什么都不做；如果错了，就抛出一个AssertionError异常，与上面的情况不同的是，这个异常创建的时候将expr作为参数，值被转化为它对应的字符串，并显示出来。其他情况均相同。 根据以上的内容说明，下面是一个测试程序： public class AssertTest { public static void main(String[] args) { AssertTest test = new AssertTest(); test.test(true); test.test(false); } public void test(boolean param){ assert param; System.out.println(\"true param\"); } } 【JDK1.8下】代码编译、运行都没有问题，但是执行结果为打印了两次\"true param\"，诶，断言语句好像没有作用。实际上，这段代码的编译和运行都有一些地方需要注意。首先，由于assert是1.4引入的，所以在编译的时候需要指定JDK为1.4之上的版本，否则编译会报错，使用的语句为javac -source 1.4 AssertTest.java，当然，很多IDE已经帮你选择好了JDK版本，而且现在基本上都比1.4高。另外，默认情况下，断言是关闭状态，要想使得断言语句发挥作用，需要利用语句java -ea AssertTest.class来打开断言功能。所以上面这段代码的执行结果是： true param Exception in thread \"main\" java.lang.AssertionError at AssertTest.test(AssertTest.java:18) at AssertTest.main(AssertTest.java:13) 这次终于抛出异常了。 一般情况下，断言是关闭状态，使用开关语句-ae才能打开断言功能 讲到这里，似乎明白了，断言就是来检查程序是否出错的一种手段。诶，那和异常，以及if-else有什么区别呢？ 断言和异常的区别 在我们写程序的时候，总有一些不在设计范围之内的情况，比如，对于输入年龄，我们要求年龄是一个正整数，但是接收到的却是一个负数，这种情况到底是该用if-else来检测之后抛出异常呢还是用断言呢？ 就上面这个例子来说，如果这个方法是一个public，即这个参数是外部输入的，我们无法遇到输入的值是什么，但是程序又要求对参数范围作出检查，此时我们应该对非法参数作出抛出异常的处理，而不是使用断言。因为断言是开发阶段的一种程序自检手段，在产品阶段是不起作用的，那么什么时候用断言呢？ 还是上面的的例子，如果这个参数是由程序中的另一个方法传入的，而这个方法按照正常的逻辑，只有在参数检查合格了之后才能调用该方法，否则是走不到这一步的，这时候，我们可以在方法的开头进行断言。如果逻辑没错，那么断言就不会抛出AssertionError，如果上层逻辑错误了，在参数不合法的情况下居然调用的该方法，那么断言失败，就会产生错误。所以这是一种开发阶段调试的手段。 记住，断言是一种调试工具。 但是断言还是要慎用，因为一旦断言失败，程序就挂了，如果是生产环境中的应用是不能容忍的。断言的一个重要涌入就是JUnit测试程序。 需要注意 断言是一种开发阶段的调试手段，不要出现逻辑代码 默认情况下断言是关闭状态，在java运行命令后分别加上-ea和-da，用来开启和关闭断言。如果想要是的一个包中断言都无效，可以使用 -da:com.test 这样就是的包com.test中的断言都无效。如果要是的一个包中的所有子包的断言都失效，需要在后面加上三个点，如： -da:com.test... 这样就使得com.test包及其子包中的断言都无效。 断言失败抛出的AssertionError是继承自Error的，属于严重错误，不可恢复，开发者必须予以关注并解决。 在对外公开的方法中，不能使用断言作为校验。因为需要遵守契约。这个例子具体可以参照https://www.cnblogs.com/DreamDrive/p/5417283.html 参考 Java断言机制 改善Java代码]断言绝对不是鸡肋 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 19:51:43 "},"Java基础知识整理/集合框架.html":{"url":"Java基础知识整理/集合框架.html","title":"集合框架","keywords":"","body":"集合框架 概述 在Java2之前，Java是没有完整的集合框架的。只有一些简单的可以自扩容的容器类，比如Vector、Stack、HashTable等，这些容器类在使用中饱受诟病，所以在Java2中被重新设计，于是有了现在的集合框架，需要注意的是，原来的那些容器类并没有被抛弃而是进行了保留，主要的目的是为了向下兼容，即使这样，我们还是应该注意尽量少使用。 Java集合框架涵盖众多数据结构类，其结构图如下： 一般用接口定义框架；用抽象类提供接口的一部分实现；用抽象类通过具体的数据结构实现整个接口。 JDK1.8 集合框体系 从上面的集合框架图可以看出，Java集合框架主要包括两种类型的容器： 集合Collection：存储一个元素集合,Collection接口又有3种子类型的接口List、Set、Queue，再下面是一些抽象类，再下面是具体的实现类，常用的有HashSet、LinkedHashSet、ArrayList、LinkedList等。 图Map：存储键/值对映射，有两个抽象类AbstractMap和SortedMap，常用的实现类有HashMap、LinkedHashMap、WeakHashMap等。 Collection接口 Collection接口是处理对象接口的根接口，其中定义了很多对元素进行操作的方法，例如add、remove、addAll、contains、toArray等。 Collection接口有3个子接口：List、Set、Queue，它们各自又有自己的实现类，继承结构如下： 接下来就具体的实现进行学习。 List接口 List接口扩展自Collection，可以定义一个 允许有重复 的有序集合。从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器 ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要提供了对链表的支持。 下面介绍List接口的两个重要的实现类：数组线性表ArrayList和链式线性表LinkedList。 ArrayList ArrayList直接继承AbstractList类，实现List接口、RandomAccess接口、Cloneable接口和Serializable接口。 由于实现了RandomAccess接口，所以使用for循环遍历比使用迭代器效率更高。 ArrayList使用数组存储元素，提供了三种构造方法。需要注意的是，如果是初始化时人为指定容量大小，那么数组空间在初始化的时候就被申请了；如果没有指定大小或者指定大小为0，那么在构造函数中是指数组空间指向了默认空间DEFAULTCAPACITY_EMPTY_ELEMENTDATA或EMPTY_ELEMENTDATA，其真正的空间分配在第一次插入元素的时候，默认大小是10。 需要注意的是，元素的个数和容量并不是一个概念，方法size可得到元素的真实个数，这个数一定小于等于数组容量。当元素个数超过数组容量的时候，数组需要进行扩容。扩容原则是扩容为原来的1.5倍，这个扩容的大小是固定的，不能认为指定。数组不能无限增长，约定数组的最大容量为Integer.MAX_VALUE - 8，而实际上数组的最大容量可以达到Integer.MAX_VALUE。ArrayList类定义了多个与空间容量有关的方法，比如ensureCapacityInternal、ensureExplicitCapacity和grow，三者层层调用，grow才是最终绝对扩容容量的方法。所谓的扩容，实际上是重新申请了一块更大的空间，然后将原来的元素复制到新空间中，这一步采取的方法是Arrays.copyOf方法。ArrayList的数组空间可以自动扩容，却不能自动缩容。但是可以通过trimToSize方法进行收缩，使得元素个数正好等于容量，避免空间浪费。 ArrayList类有很多常用的方法。例如 add是最常用的对单元素操作的方法，有两个重载：一个用来追加元素，一个用来添加元素到指定位置，但是建议尽量少使用后面一种重载方法，因为数组的添加和删除操作涉及到元素的移动，频繁的移动简直是噩梦，虽然这种实现是基于System.arraycopy实现的，效率相对较高，但是能避免就避免吧。 remove是为最常用到的对单个元素操作的方法，有两个重载，不同于add方法的两个重载， remove的两个方法都是单个参数，一个用来删除指定索引上的元素，另一个以Object对象作为参数，用来删除第一个与之匹配的元素，需要注意的是，参数是Object类型，需要考虑null类型可能造成的空指针异常问题。 对于集合的操作，ArrayList定义了三种方法，addAll、removeAll和retainAll。addAll重载了两个方法，同样提供了对位置的操作。removeAll顾名思义不多做解释。retainAll是保留与参数集合相同的那些元素，实际上，removeAll和retainAll正好是两个相反的实现过程，在源码中都是巧妙地利用了batchRemove的方法，利用布尔参数控制某个元素是否保留，比较巧妙，值得学习。 ArrayList还提供了一些基于位置的操作，比如get、set、indexOf、lastIndexOf等。 ArrayList实现了Cloneable接口，所以必须提供clone方法，ArrayList重写了该方法，但是要注意该方法提供的是浅拷贝，对于得到的拷贝对象的操作可能会影响原来的对象。 ArrayList的toArray方法需要注意，有两个，而我们如果想要得到特定类型的数组，一般的写法是：String[] array = x.toArray(new String[]); ArrayList实现了Iterable接口，所以他必须提供迭代器方法。在ArrayList内部分别提供了两种迭代器方法：iterator和listIterator，前者返回Iterator类型迭代器，后者返回ListIterator。后者提供了双向迭代方法，比Iterator更强大。而两者类型的迭代器的实现是基于ArrayList的两个内部类：Itr和ListItr，前者实现Iterator接口，后者实现ListIterator接口。我们也可以学习这种方法来自定义自己的迭代器。需要注意的是，ArrayList中有一个变量modCount，这是用来观测在使用迭代器期间，外部对象是否对集合做出修改，如果做出修改，那么迭代器将不能使用。这个变量实际上就是计数器，记录外部对象修改操作的次数，修改操作例如add、remove、retainAll等。初始化迭代器的时候，会将这个量保存在迭代器的变量expectedModCount中，每次迭代器的操作都会先检查这个量和外部对象此时的modCount是否相等，不相等则说明发生了非迭代器的操作，那么迭代器操作就不能进行下去。 ArrayList可以和数组相互转化。ArrayList通过toArray方法转为为数组，注意写法，在上面第6条解释过。数组可以通过Arrays.asList(变长字符串数组)可以创建字符串线性表，但是需要注意的是，这个方法返回值是Arrays.ArrayList，而不是java.util.ArrayList。 注意java.util.ArrayList和java.util.Arrays.ArrayList的区别，后者具有 set()，get()，contains()等方法，但是不具有任何添加或移除元素的任何方法。因为该类的大小(size)是固定的。 实际上我们真正创建java.util.ArrayList的写法如下: ArrayList list = new ArrayList(Arrays.asList(arr)); ArrayList的构造方法可以接受一个Collection类型的对象，而我们的 java.util.Arrays.ArrayList正好也是它的一个子类。实际上，更加高效的代码示例是： ArrayList list = new ArrayList(arr.length); Collections.addALL(list, Arrays.asList(arr)); ArrayList是非线程安全的，其方法全部都是非线程安全的。如果要求实现线程安全，那么使用Vector或者使用Collections.synchronizedList来创建线程安全的ArrayList。 LinkedList LinkedList类直接继承自抽象父类AbstractSequentialList，实现List、Deque、Cloneable和Serializable接口。 与ArrayList不同，LinkedList使用双向链表存储数据，所以链表没有初始化大小的概念，也没有空间大小的限制。 由于数据结构的实现是双向链表，所以LinkedList提供了一些时间复杂度为O(1)的操作，比如getFirst用来获取第一个节点元素，getLast用来获取最后一个节点元素，同理还有removeFirst、removeLast、addFirst、addLast操作。当然对于插入和删除，LinkedList提供了add（两种重载），remove（两种重载）、addAll、removeAll操作，这些操作和ArrayList提供的方法具有相同的功能。源码实现的时候稍有技巧，如果指定了index，将会比较index是靠近链表头还是链表为，以决定双向链表遍历的方向。 其他线性表的操作与ArrayList类似，在此不做赘述。 LinkedList采取双向链表的数据结构，使得它实现了栈、单向队列和双线队列的功能。 对于栈的实现，LinkedList提供了pop和push方法，分别对应出栈和入栈操作，实际上，此时链表的头就是栈顶，方法的实现分别依赖于addFirst和removeFirst方法。 对于单向队列的实现，LinkedList提供了offer(基于add方法)、poll（基于removeFirst方法）、remove方法(基于removeFirst方法)、peek（基于getFirst方法）和element（基于getFirst）方法。实际上，此时链表头是队头，链表尾是队尾，offer方法是真正的入队操作，poll和remove方法是真正的出队操作，两者的不同点在于前者在遇到空链表的时候返回null，而后者抛出异常。peek和element方法用来获取队头元素，不出队，两者的不同在于peek方法在遇到空队列的时候返回null，而后者抛出异常。 对于双向队列，LinkedList提供 offerFirst、offerLast、pollFirst、pollLast、peekFirst和peekLast方法，很容易想的明白具体的实现细节。 ArrayList和 LinkedList的不同是由于各自的数据结构不同造成的，即数组和链表的区别。所以在实际使用中我们需要根据特定的需求来选择合适的类：如果经常读取、除了在末尾外不能再其他位置插入或删除元素，则 ArrayList效率更高；如果经常插入或删除元素，就选择LinkedList。 Vector 同步版本的ArrayList，现在很少使用。可以使用Collections.synchronizedList实现ArrayList的同步操作。 Stack 对于栈操作的抽象，直接继承Vector，是栈基于数组的实现。由于数组具有空间的限制，且大部分操作都是在一段进行插入和删除操作，这种特点使用链表来实现更加合适，所以这个类一般不被使用，而是使用LinkedList提供的栈操作来代替。 对于 List，需要说明的是，List的顺序是元素插入的顺序，本身不支持有序存储（这里的有序是指大小有序），但是可以利用Collections类中的静态方法来实现排序。 Set接口 Set接口扩展自 Collection，与List的不同之处在于Set不允许包含重复元素。即一个规则集内，一定不存在两个相等元素。这一点非常好理解，因为Set本身模拟的是数学中“集合”的概念，而集合本身是不能有重复元素的。 AbstractSet是一个实现Set接口的抽象类。Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 散列集HashSet HashSet是Set接口的最常用的实现类。该类中有一个HashMap类型的属性，而集合中的元素保存为HashMap的key值。所以说，HashSet是基于HashMap实现的，这也就能理解，为什么HashSet不允许有重复元素，以及最多包含一个null元素。 既然HashSet是基于HashMap实现的，那就一定存在HashMap的容量和装载因子问题，默认情况下，HashSet的初始容量为16，默认装载因为为0.75，当使用集合来实例化HashSet对象的时候，初始化容量为集合大小的4/3与16中的较大值。HashSet有5种重载的构造方法，其中需要注意，三个参数的构造方法中创建的是LinkedHashMap的实例，该构造方法的主要用途是为了创建LinkedHashSet对象。 链式散列集LinkedHashSet LinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。需要注意的是，这里的排序说的是按照插入顺序进行排序，并非指按照某种自定义的顺序（比如字典序），进行排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。 LinkedHashSet是基于HashSet实现的，或者从根本来说，是基于LinkedHashMap实现的。默认初始化大小为16，默认装载因子为0.75，如果以集合来实例化对象，其初始化大小为2倍的集合大小与11中的较大值。 树形集TreeSet TreeSet扩展自AbstractSet，并实现了SortedSet，其内部的实现是NavigableMap。 在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。下面是一个TreeSet的例子 public class TestSet { public static void main(String[] args) { TreeSet set = new TreeSet<>(); set.add(1111); set.add(2222); set.add(3333); set.add(4444); set.add(5555); System.out.println(set.first()); // 输出第一个元素 System.out.println(set.lower(3333)); //小于3333的最大元素 System.out.println(set.higher(2222)); //大于2222的最大元素 System.out.println(set.floor(3333)); //不大于3333的最大元素 System.out.println(set.ceiling(3333)); //不小于3333的最大元素 System.out.println(set.pollFirst()); //删除第一个元素 System.out.println(set.pollLast()); //删除最后一个元素 System.out.println(set); } } 和TreeMap类似，更新一个集合时，如果不需要保持元素的排序关系，应该使用散列集，因为在散列集中插入和删除元素所花的时间少；如果需要保持集合中的元素排序时，可以把散列集转化为树形集。如下: public class TestHashSet { public static void main(String[] args) { Set set = new HashSet(); set.add(\"London\"); set.add(\"Paris\"); set.add(\"New York\"); set.add(\"New York\"); set.add(\"San Francisco\"); TreeSet treeSet = new TreeSet(set); System.out.println(treeSet); for (String string : treeSet) { System.out.println(string + \" \"); } } } Queue接口 Queue接口扩展自Collection，并提供插入、提取、检验等操作。以下是Queue 接口中的全部方法： 常用的方法有： offer()：表示向队列添加一个元素。 poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。 element()与peek()主要是获取头部元素，不删除。 LinnkedList LinkedList实现了Deque接口，Deque接口，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素。LinkedList使用双向链表实现了双向队列。 public class TestQueue { public static void main(String[] args) { Queue queue = new LinkedList<>(); queue.offer(\"aaaa\"); queue.offer(\"bbbb\"); queue.offer(\"cccc\"); queue.offer(\"dddd\"); while (queue.size() > 0) { System.out.println(queue.remove() + \"\"); } } } PriorityQueue PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除，实际上，这就是一个堆结构。 堆是一个特殊的完全二叉树，满足根节点全部大于或小于左右子树的节点值。PriorityQueue使用数组实现该节点，默认为最小堆，如果要创建最大对，可以在创建的时候传入自定义的Comparator。需要注意注意的是，PriorityQueue禁止null元素，否则抛出空指针异常。 PriorityQueue的操作有3种，新建、插入和删除。 PriorityQueue的插入可以创建一个新的空优先队列，此时默认的容量为11，默认的比较器为null，即按照自然排序（这也是默认为最小堆的原因）。当然PriorityQueue可以进行扩容，当旧容量小于64，扩容时候增加2倍，如果是大容量，那么增加1倍+2的容量。还可以使用已经存在的集合来创建优先队列。如果该集合已经有序，比如SortedSet和PriorityQueue的实例，则不用进行调整，直接按顺序复制数组即可，前者注意需要排查是否有null元素，有的话抛出异常。如果是非有序数组，那么就不光需要复制数组，还需要进行调整，这个过程是从最后一个节点的父节点开始，不断将以其为根节点的树调整为堆。这个过程和删除节点操作的类似。 PriorityQueue的插入操作是将一个节点插入到堆中，注意这时候已经是现成的堆了。我们总是将这个节点插入到最后一个位置，然后沿着其祖先节点的序列找到自己适合的位置：将大于自己的祖先节点下移，直到找到比自己小的节点或者根节点，然后赋值。这个过程叫做\"上浮\"。 PriorityQueue的删除操作可以是将根节点删除（或者软删除，即将其放到数组的末尾，由于size减1，所以之后无法访问到，相当于删除了），其做法是将最后一个元素赋值到根节点中，然后堆就变成了这样的结构：根的左右子树是堆，但是整体不是堆，这时候只需要将根节点与左右子树中较小的那个数交换位置，然后递归循环，直到跟根节点比左右孩子节点值都小或者达到叶子节点。 堆的更多内容和演示可参见源码或者算法中的“堆排序”。 Map接口 Map是一种存储键值对映射的容器类，也是集合框架中最最重要没有之一的容器分支。为什么重要？一来是因为存储比较灵活，可以存储任意类型的对象；二来，它能够将查询效率从O(n)提高到O(1)。 Map接口是这类容器的根接口，定义了接口的基本特性：键值对中的“键”不能重复，可以为null（由于不能重复，所以最多只能有一个为null的键）；每个键对应了一个\"值\"，这个值是可以重复的，也可以为null。 Map中最基本的元素是映射关系，这里定义了其存储结构是Entry接口。这个接口中定义了映射关系的操纵方法，比如获取映射关系的key值getKey方法，获取映射关系的value值getValue方法，重新赋值方法setValue方法，映射比较方法equals，获取哈希值的方法hashcode等。Map的实现类中数据的存储结构必须要实现这个接口。 Map中还提供了三种视图及其获取方法：key集合（通过keySet方法），value集合（通过values方法）和key-value集合（通过entrySet方法），注意values方法返回值类型是Collection，因为键值对中的值可以重复，而keySet方法和entrySet方法的返回值类型是Set，因为元素必须是唯一的。我们常常利用这三种视图进行Map的遍历，遍历的示例如下： public static void main(String[] args) { Map map = new HashMap(); map.put(1, \"a\"); map.put(2, \"b\"); map.put(3, \"c\"); map.put(4, \"d\"); map.put(4, \"e\"); System.out.println(map.size());//元素不能重复，所以map大小是4，最后e将覆盖d //1. 第一种遍历方法，得到keySet，遍历该Set元素，取得对应的value Set keySet = map.keySet(); for (Integer i : keySet){ System.out.println(i + \"=\" + map.get(i)); } System.out.println(); //2. 第二种遍历方法，通过entrySet使用iterator遍历key和value Iterator> iterator = map.entrySet().iterator(); while (iterator.hasNext()){ Map.Entry entry = iterator.next(); System.out.println(entry.getKey() + \"=\" + entry.getValue()); } System.out.println(); //3. 第三种方法，通过entrySet遍历key和value（推荐使用） Set> entries = map.entrySet(); for (Map.Entry entry : entries){ System.out.println(entry.getKey() + \"=\" + entry.getValue()); } //4. 第四种方法，通过values()遍历所有的value，但不能遍历key for (String value : map.values()){ System.out.println(value); } } 这里打印出的顺序基本上是按照插入顺序打印的，而实际上，如果插入的更多不同的值，再进行遍历，会发现顺序和插入顺序无关。那是因为Map本身对元素的访问顺序并无要求，对元素的访问顺序无任何保证。对元素书序的要求需要在各个实现类中定义，比如HashMap对元素访问顺序无任何保证，而LinkedHashMap能够包含保证基于插入顺序或基于访问顺序，TreeMap能够保证？？？ Map的重要实现了有HashMap、LinkedHashMap、TreeMap，它们基于不同的需求，重写了求哈希值、映射关系组成、存储结构、访问顺序等。 Map接口及其实现类非常非常重要，必须要熟练掌握。 HashMap HashMap是非常重要！非常重要！非常重要！几乎是整个Map存储框架的核心。 HashMap继承自AbstractMap，实现Map接口。其中内部类Node实现了Map的内部接口Entry，这就是HashMap的映射关系的数据结构。Node类中定义属性hash、key、value和next，分别为哈希值，键、值和下一个映射关系的指针，由于存在指向下一个映射关系的指针，所以可以组成一个单链表，HashMap中定义了Node类型的数组table，用来存储所有的映射关系。在JDK1.8之前，HashMap的内部数据结构设计就是这样——哈希桶 + 单链表，JDK1.8对HashMap做出了改进，引入了\"红黑树\"，即当哈希桶某个位置发生严重（此位置的链表长度大于8）的哈希碰撞，就将哈希桶这个位置上的单链表转化为红黑树，当哈希碰撞不严重（此位置的链表长度小于6），就将该位置上的红黑树转化为单链表。而红黑树的节点的数据结构定义为内部类TreeNode，注意，这个内部类继承自LinkedHashMap定义的映射关系数据结构LinkedHashMap.Entry，因此除了TreeNode类型的四个属性：parent、left、right和prev外，还具有Map.Entry类型的before、after两个指针。所以对于JDK1.8中的HashMap，其数据的存储结构应该是：数组（哈希桶） + 单项列表 + 红黑树。 单链表的设计是为了解决哈希冲突。 HashMap是一种散列存储结构，即根据元素计算得到存储地址。在HashMap定义了一个hash方法，用key值来计算得到一个哈希值，计算规则是(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);，容易看出，对于key=null，其hash方法的返回值永远是0。然而hash方法的返回值实际上是散列函数的输入值，即码值，而散列函数是(n - 1) & hash，其中n是table数组的长度。所以这里就能回答为什么HashMap最多只能保存一个key=null的映射关系？（因为对于key=null映射关系，计算得到的table中的位置永远是0），以及key=null的映射关系一定被保存在table[0]中。 HashMap的实现原理重点在于putVal方法，该方法展示了如何插入一个键值对以及如何处理哈希碰撞。首先，判断用来存储数据的table是否已经初始化，如果没有则初始化，此处调用了HashMap的容量扩充方法resize，在后文会讨论到。接着根据上文所说的计算table中存储位置的方法找到table[i]。如果此时该位置为null，直接new一个Node出来并保存，结束。如果此时该位置为不为null，说明此处已经有人占领了，诶，会不是同样的key呢？所以怀抱这一丝希望，比较一下是否相等。相等的标注是：hash值相同且key相同。如果发现相同，则根据布尔型参数onlyIfAccess判断是否需要对映射关系进行值的覆盖，一般情况下，这个参数都是true，即发现相同的key的时候对值进行覆盖。如果不幸发现不相等，此时就发生了哈希碰撞，此时就需要解决哈希冲突。HashMap的哈希冲突解决办法是链地址法 + 红黑树：发生冲突的时候，先判断以下当前该槽位上的节点是Node类型还是TreeNode类型，如果是后者，说明这个位置上的单项链表的长度已经大于某个限定值（默认为8），那么此时又一次发生了哈希冲突，那么只需要在红黑树上再次添加一个节点即可。如果此时table[i]上的节点类型是Node，那么新建一个节点添加到单链表尾部，如果此操作之后，链表的长度大于了限定值，需要将链表主转为红黑树。此时已经完成了一大半工作，剩下的一点扫尾的工作是： ①如果发生写入覆盖，那么需要执行afterNodeAccess方法，这个方法在HashMap中为空，其目的是为了让HashMap的继承者能够自定义一些节点访问后的操作，比如LinkedHashMap利用该方法实现了LUR式节点访问。 ②变量modCount自增，与迭代器从操作相关。 ③若需要则扩容。 ④处理一下节点添加之后的操作，即执行afterNodeInsertion方法，与afterNodeAccess一样，在HashMap中该方法体为空，目的也是为了让其子类自定义功能，比如LinkedHashMap覆盖该方法，完成了双向链表的操作。至此，大致完成了HashMap的插入节点操作。 以上过程的过程如下： 红黑树的相关实现参照TreeMap。 前面多次提到扩容的概念，这里做一个总结。与其他容器类一样，HashMap同样具有初始容量的概念，这个初始容量就是数组table的大小，默认为16，与其他容器类不同的是，HashMap还有一个装载因子的概念，装载因子即数组实际使用个数与总个数的商，默认的阈值为0.75，即我们不必等到数组全部使用完毕才进行扩容，而是在使用到一定程序时候就进行扩容。这个“一定程度”的概念是数组实际使用个数超过装载因子和容量的积（即阈值，用变量threshold表示）。而扩容策略是容量加倍，即2 oldCap。另外需要注意的是，HashMap规定容量大小必须是2的倍数，这一点在方法tableSizeFor方法中有体现，比如，如果初始化时定义容量大小为5，那么实际上容量大小将被定义为8。在扩容的同时，需需要将原来table中的Entry对象拷贝到新的table中，在1.7之前，会重新计算每个key的哈希值，然后使用头插法的顺序节点插入到新的索引位置。而在1.8中，很好利用了容量为2次幂且扩容采取2次幂的，那么扩容后*元素的位置要么在原来的位置上，要么在原来的位置上再移动2次幂的位置的特性，避免了哈希值计算，提高了效率。 与putVal相反的是removeNode方法。其中涉及到节点操作和链表与红黑树的转化问题。 需要注意，HashMap的元素的访问顺序上没有任何保证，既无法保证存储顺序也无法保证访问顺序。如果对元素访问顺序有要求，那么可以使用LinkedHashMap和TreeMap。 HashMap经常用来与HashTable来作比较。两者的比较可以从以下几个方面来做比较： 继承关系： HashMap继承自AbstractMap，而HashTable继承自Dictionary。 容量大小和扩容策略：HashMap默认初始化为16，默认装载因子为0.75，约定容量和阈值必须为2的倍数，扩容策略为2倍，最大空间容量为2^{30};HashTable默认初始化容量为11，默认装载因子为0.75，不对容量和阈值做限制，扩容策略是2倍加上1，最大空间容量为Integer.MAX_VALUE - 8。 数据存储结构：HashMap采取“数组 + 单向链表 + 红黑树” 结构，而HashTable采取\"数组 + 单项链表\"。 解决哈希冲突的方法： HashMap采取链地址法，而Hashtable采取再散列。 对于null值的允许：HashMap允许null值作为key和value，但是只能有一个key=null的键值对;HashTable不允许null值作为key和value。 线程安全性：HashMap非线程安全，HashTable线程安全。 LinkedHashMap LinkedHashMap继承自HashMap，它在HashMap的基础上保证了元素的访问顺序，注意是访问顺序（可支持基于插入的访问和基于访问顺序的访问），而不是存储顺序（存储顺序和HashMap相同）。 LinkedList利用双向链表来维护访问顺序。首先，内部类Entry作为映射关系的存储结构，它继承自HashMap的映射关系存储结构Node，在其基础上增加了前后指正before和after，这里需要区分这两个指针和next指针的关系：这两个指针代表访问关系中的节点关系，而next指针代表的是发生哈希冲突的下一个节点，当我们遍历LinkedHashMap的时候，实际上是按照双向链表的顺序进行访问，从而保证了访问的有序性。那么，这个双向链表是如何维护的呢？首先，LinkedHashMap重写了newNode和newTreeNode方法：不仅仅创建一个新的节点，更要将这个节点链接到双向链表的末尾，在方法linkNodeLast中有所体现。再者，LinkedHashMap重写了afterNodeInsertion和afterNodeRemoval方法，在节点插入和节点删除之后，都重新维护了双向链表。最后，LinkedHashMap支持基于访问顺序的访问，即LUR算法，这个依靠afterNodeAccess方法实现，其原理是在每次对单个节点进行访问或操作之后，将此节点连接到双向链表的末尾。 所以， LinkedHashMap的数据结构实际上是： 数组（哈希桶） + 单项链表 + 红黑树 + 双向链表 TreeMap Treemap是大名鼎鼎的红黑树的实现，该类实现了NavigableMap接口，而该接口实现SortedMap接口，所以TreeMap能更加灵活地定义元素的排序关系，这种排序关系即BST的排序关系。 红黑树既是一种平衡二叉排序树（AVL），也是一个二叉索引数。其中映射关系定义内部类Entry，该类实现Map.Entry接口，定义key、value、right、left和parent，其中parent即为二叉索引。 红黑树的主要操作就是节点的插入和删除，分别在put和deleteEntry方法中定义，两者都是先按照BST的节点插入（新插入节点都是红色节点）和删除进行操作，由于新插入节点和删除节点将破坏红黑树的平衡，所以接下来都需要进行调整和平衡，这部分的操作分别在fixAfterInsertion和fixAfterDeletion方法中进行。 fixAfterInsertion先判断了新节点是否为根节点，是的话直接设置为黑色，算法结束。如果不是，判断其父节点是不是黑色，如果是，不做操作，算法结束。如果还不是，就需要进行接下来的一系列判断，首先判断其叔节点是否为红色，如果是，那么将父节点和叔节点都置为黑色，将祖父节点置为红色，并设其为当前节点，递归进行操作。如果叔叔节点是黑色，如果当前节点是父节点的左节点，父节点是祖父节点的左节点，那么以父节点为轴进行LL旋转，之后将原来的祖父节点置为黑色，将父节点置为红色。如果当前节点是父节点的....（具体的操作看红黑树那一篇博文，在此不再赘述。） fixAfterDeletion对删除节点后的红黑树进行调整和着色，过程比插入更加复杂，仍旧是看红黑树博文和TreeMap源码解读，在此不再赘述。 总的来说，在不要求顺序的情况下，HashMap的性能最好，所以我们尽量使用HashMap进行存储。如果需要特定的存储顺序，我们仍旧先用HashMap进行插入，最后构造一个TreeMap的实例，再进行操作。这一点和上面的TreeSet类似。 Collections Collections提供了对于集合的操作，它主要提供了两类方法：对于集合的包装和一些基本的简单算法。 对于集合的包装，Collections提供了不可变集合unmodifiableXXX、线程安全集合synchronizedXXX、类型安全集合checkedXXX、空集合emptyXXX、单元素集合singletonXXX等，注意前三类实际上并未实现真正的不可变、线程安全和类型安全，后面两个方法注意返回的集合都是只读的。 该类中定义了一些简单的算法：排序(sort)、反转(rotate)、二分查找（binarySearch）、混排(shuffle)、填充（fill）、拷贝(copy)、替代（replaceAll）、子串匹配(indexOfSubList和lastIndexOfSubList)、最大(max)、最小(min)。其中每个方法都对随机访问的列表和链表分别做了特殊处理，前者采用索引式存取，后者采取迭代器，提高了效率。这些方法要熟记。 Arrays Arrays和Collections一样是一个工具类，它提供了对于数组的操作，注意和Array进行区分。这个类提供了对于数组的常用操作，比如查找、排序、填充等方法。而这个方法提供了对于基本数据类型数组和对象数组的操作，其中对象数组又可以分为一维数组和多维数组，必要的地方对二维数组做了特殊处理，这些特殊方法的名字形式是deepXXX。 Arrays只提供了binarySearch一种查询方法，二分查找方法注意使用前提是有序，注意这个方法中可能会存在整数溢出问题。 Arrays提供了sort和parallelSort两种方法，后者暂且不管，前者非常复杂。 首先，对于基本数据类型，在1.7之前采用的是基础快排，1.7之后采用的是优化后的快速排序。算法在DualPivotQuicksort类的排序方法中实现。这个类名字可以翻译为“双轴快速排序”，这是一个经过优化后的快速排序然后实际上，并不一定是采用双轴快排的方法。它采取以下策略： 当数组的规模较小时，直接插入排序的比较次数并不会比快排或者归并多多少，其效率反而不如简单排序算法，所以在数组规模小于7时，使用直接插入排序。 当数组规模较大时，合理的选择快排的枢轴元素，如在规模小于40时，在数组的首，中，尾三个位置上的数，取中间大小的数做枢轴；在数组规模大于40时，从数组中取位置均匀分布的9个数，然后每三个数一组取中间数，最后三个中间数再取中间数。确定枢轴后，与数组的第一个元素交换，之后的快排与普通快排一样。 　当数组中有大量重复元素时，选择重复元素作为枢轴，然后两个端各设置两个工作指针low、high，left、right用于始终指向要交换的元素位置，如5，2，5，6，4，3，5，1，5，7 　　从high开始判断，low = 基准元素high–，同时若high位置的元素 == 基准元素，high位置的元素与right位置的元素交换，同时right–，继续直到high位置的元素 基准元素。 　　low、high位置的元素交换，同时low++、high–，然后再从high开始继续上面的过程，最后将重复的元素至于序列的两端，中间的序列分成了两部分，左面的为小于基准元素的，右面的为大于基准元素的，如5，5，2，1，4，3，7，6，5，5，此时low在7位置，high在3位置。 　　将两端重复的元素都交换到中间后，对两端不等的元素使用快排，左侧外循环从下标0开始判断，若等于枢轴进入内循环，内循环从下标low - 1开始向前找不等于枢轴的，找到交换，直到外循环遇到不等于枢轴的退出；右侧外循环从下标n - 1开始判断，若等于枢轴进入内循环，内循环从下标high + 1开始向后找不等于枢轴的，找到交换，直到外循环遇到不等于枢轴的退出。 另外，对于引用数据类型数组，采取过优化的归并排序算法。当数组规模较小（小于7）时，使用直接插入排序。当属组规模较大时，使用归并排序，且当合并的两个有序序列中，低子序列的最高元素小于高子序列的最低元素时，无序执行合并算法，这个可以在merge算法里判断。 DualPivotQuicksort.sort的算法可以计算的上是内排序算法的集大成者，里面的一些优化思路值得节点和学习。 Arrays提供了fill填充方法，注意对于引用类型数组，这个方法直接将对象赋值给元素。如果这个元素类型是可变类，比如自定义了一个类，那么改变对象参数的值将会导致牵一发而动全身的结果。如果这个元素类型是不可变对象，比如String类，Integer缓存范围内使用valueOf方法得到的对象，那么改变某一个元素将不会影响其他元素。 Arrays提供了copyOf和copyOfRange两种拷贝方法，后者可指定拷贝范围，两者的根本是调用了System.arraycopy方法，特别注意这个方法是浅拷贝。 Arrays提供了hashCode和deepHashCode两种计算数组哈希值的方法，后者专门为多维数组服务，对于一维度数组，两者并无差别。这里哈希算法与String类一致，即int hashValue = ∑ hash(A[i]) * 31 ^(n-i)， 其中hash(A[i])是数组元素本身的哈希值。 Arrays提供了equals和deepEquals两种判断数组相等的方法，后者专门服务于多维数组，对于基本数据类型，相等的含义是“=”，对于引用数据类型，相等的含义是\"equals\"。 Arrays提供了toString和deepToString两种数组打印方法，区别与上文中相等。注意数组本身的toString方法只能得到十六进制值，不能出元素值。 Arrays提供asList方法，将数组转为ArrayList实例，注意该方法的返回结果为java.util.Arrays.ArrayList的实例，这个实例没有添加和删除方法，我们如果想要得到java.util.ArrayList的实例，可以有以下两种方法： //方法1： 将asList的结果组作为ArrayList的构造参数 String[] arr = new String[]{\"A\", \"B\", \"C\"}; ArrayList list = new ArrayList(Arrays.asList(arr)); //方法2： 使用Collections.addAll()方法 ArrayList list = new ArrayList(arr.length); Collections.addAll(list, Arrays.asList(arr)); 其逆操作是List实例的toArray方法。 参考 java集合继承关系图 map的遍历的4种方法 Arrays.sort()的内部排序机制 java1.8 HahMap的改进 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 14:46:56 "},"Java基础知识整理/多线程.html":{"url":"Java基础知识整理/多线程.html","title":"多线程","keywords":"","body":"多线程 这个专题真的好神圣，因为多线程在我心中就是一座永远不能登高的高峰。因为从来没有弄明白过，sad。 进程和线程 在正式学习之前，我们需要补一下操作系统的相关知识。 首先明确\"CPU\"、“多核处理器”、\"多处理器\"这些名词的关系。 首先\"CPU\"，中央处理器，是一块超大规模的集成电路，是一条计算机的运算核心和控制核心。通常家用电脑就一个CPU，一些服务器和图形工作站都有2个、4个或者更多的CPU，大型服务器或者超级电脑有多少个都行。 “多核”指的是什么呢?多核处理器是指在一枚处理器中集成两个或者多个完整的计算引擎（内核）。在运算效果上等同于多个“单核CPU”。”多核处理器“和“多处理器”是完全不同的概念。至于单个“多核处理器”和多个“单核处理器”之间的区别和优劣，网上讨论很多了。不再赘述了。 看知乎上有个形象的总结：简单来说就是一家子人干活和几家人干活的区别，假设人数一样，一家人开个门就能商量，几家人要过街才能商量。 多CPU的方式称为分布式计算！ 进程的概念有一个背景：多道程序设计技术。 在这个技术引进之前，多个程序串行执行。只存在一个程序计数器（PC, program counter）,一个程序执行完毕之后，才会执行下一个程序。 而多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。 注意这里的描述“相互穿插的运行”，这是什么意思？一个CPU在同一时间只能处理一项任务，那么如何选择处理哪项任务呢，这就是所谓的任务调度。大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行。由于CPU的效率非常高，所以每个任务没有隔多久就又被执行了，从我们的感官来看，就好像每个任务都没有被耽误，多个任务都在并发(concurrent)执行。 这里又有一个概念：并发(concurrent)，和它经常放在一起比较的另外一个词是：并行(parallel)。两者有什么区别和联系呢？ Erlang 之父 Joe Armstrong用下面这张图解释了concurrent和parallel的区别： 可以看到，两队人交替使用同一个咖啡机，是并发（concurrent）；两队人同时使用两个咖啡机，是并行（parallel）；一队人使用一台咖啡机，是串行（serialization）。 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 话题扯远了，回到正题。既然多道程序设计允许多个程序同时进入内存并发并行，那么就要每个程序都分配程序计数器了，那么如何描述、刻画这样执行的程序呢？因此引入了“进程”。下面进程的一种定义： 进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度（若不支持线程机制，进程的系统调度的单位。否则，线程是系统调度的单位）的独立单位。 注意定义里面的几个关键词，\"运行活动\"说明进程是程序的一次执行过程，如果程序要执行两次甚至多次，那么需要两次甚至多次进程。“数据集合”是说系统资源（如内存、文件）以进程为单位分配，操作系统为每个进程分配了独立的地址空间，通过“调度”把控制权交给进程。 有了进程的概念，那么为什么还要引入线程呢？有这些考虑： 应用的需要。比如打开一个浏览器，我想一边浏览网页，一边下载文件，一边播放音乐。如果一个浏览器是一个进程，那么这样的需求需要线程机制。 开销的考虑。在进程内创建、终止线程比创建、终止进程要快。同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。线程之间相互通信无须通过内核（同一进程内的线程共享内存和文件） 性能的考虑。多个线程中，任务功能不同（有的负责计算，有的负责I/O）,如果有多个处理器，一个进程就可以有很多的任务同时在执行。 线程有以下特点： 有标识符ID 有状态及状态转换，所以需要提供一些状态转换操作 不运行时需要保存上下文环境，所以需要程序计数器等寄存器 有自己的栈和栈指针 共享所在进程的地址空间和其它资源 线程和进程更通俗易懂的解释可以参考 https://www.zhihu.com/question/25532384 ,讲的很明白易懂了。 线程和进程之间的区别： 比较项 进程 线程 定义 程序在某个数据集合上的一次运行活动 线程是进程中的一个执行路径。 角色 系统资源分配的单位 CPU调度的单位 资源共享 进程之间不能共享资源。一个进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成 线程共享所在进程的地址空间和其它资源。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈 独立性 有自己独立的地址空间 没有独立空间，线程依赖于进程而存在。 开销 切换的开销较大 相对较小 今天遇到一个有意思的题，问的是“线程里面什么是独立的”？我们知道进程是资源的分配单元，而线程是调度的基本单元。线程会共享进程包括：①进程代码段；②进程的共有数据（堆、方法区）；③进程打开的文件描述符、信号的处理器、进程的当前目录和进程组ID、进程用户ID。 线程之间不能共享的有：①线程ID，唯一；②寄存器组的值，每次切换的时候保存，重新切换时恢复；③线程优先级。 一个程序至少有一个进程，一个进程至少有一个线程。 多线程和多核 前面提到的\"同一时间只有一个任务在执行\"，这句话在当下看来是不对的，至少是不全面的。这句话说的是单个单核处理器的情况，但是现在大都是多核处理器，这时候会怎么进行进程和线程的处理呢？ 多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。 内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。 那么，四核八线程处理器是不是能让八线程并行呢？ 不是！CPU中的线程与操作系统中的线程不是一个概念，CPU中的操作是以时序为准的，它类似一个流水线操作，8线程指同时有8条指令被执行，但这所谓的执行在时序上是有差别的。由于同时处理多条指令从而提高了CPU的处理速度。但对PC系统而言它的处理还是一个分时系统，每次只能完成一个任务片段。而\"四核八线程\"是指四个物理核心，八个逻辑核心，有几核心就有多少个真实线程，多出来的都是假的。 线程和线程分类 Java中，Thread定义了线程。这个类实现了Runnable接口，所以我们可以直接继承该类来创建自定义线程。但是更多时候，是创建实现Runable的类之后，再以此为参数创建线程。在创建线程的时候，我们可以自定义线程的名称（也可以在后面使用setName来更改名称）和线程组。如果不指定，那么默认将以Thread-x的方式命名、以父线程（当前线程）所在的线程组为自己的线程组。创建的时候，线程的优先级与父线程保持一致，我们可以使用setPrority方法来改变线程优先级（线程的优先级一共有3种，分别对应1，5，10），但是最终线程的优先级不能超过其所在线程组的maxPriority。另外，线程是否是守护线程将于其父线程保持一致，也可以通过setDaemon将其设置为守护线程，但是注意，这种设定必须在线程start之前加入，否则会抛出异常。 Thread类提供了一些方法来获取当前线程的信息，比如可以使用静态方法currentThread来获取当前线程，使用示例方法getName来获取线程名、使用getPriority来获取线程的优先级、使用getThreadGroup来获取所在线程组的名称、使用isDeamon来判断是否是守护线程、使用getContextClassLoader来获取上下文类加载器、使用getState来获取当前线程状态、使用holdsLock(Object)来判断当前线程是否持有某个对象的锁。interrupted和isInterrupted都可以用来判断线程是否是中断状态，但是前者在调用的时候讲擦除这个中断状态，即第二次调用的时候会发现原本中断的线程结果不再中断了。isAlive判断线程是否还活着。activeCount用来取得线程所在线程组中活跃的线程数量。 Thread最重要的两个方法start和run经常被弄混。start是启动线程的方法，在这个方法中，线程才真正被加入到线程组，真正开始就绪状态，等待JVM调用run方法。而run方法是Runable中的方法，就是一个普通的方法，直接调用run方法是无法实现线程的。 Thread中也提供了很多线程状态的方法，如静态方法sleep、实例方法join、实例方法interrupt、实例方法yield，这些方法的差别是常考的点，需要特别注意。它们对于线程状态转化中的作用参见下文“线程状态”。 通过阅读Thread源码可以知道，线程可以分为两类：用户线程（非守护线程）和守护线程。 非守护线程包括常规的用户线程（User）或诸如用于处理GUI事件的事件调度线程，Java虚拟机在它所有非守护线程已经离开后自动离开，所以JVM结束的标识是所有非守护线程结束。 守护线程（Daemon）是用来服务于非守护线程的，典型的比如GC线程、内存管理线程、数据库连接池后面的后台线程。如果没有其他用户线程在运行，那么就没有可服务对象，也就没有理由继续下去。 这两个线程其实没啥区别，就是在创建的时候setDaemon(true)方法可以将其设置为守护线程。然后JVM会等待所有守护线程结束之后在结束。但是需要注意的是，setDaemon需要在线程start之前调用，不能对对一个已经启动的线程作此操作，否则将抛出一个IllegalThreadStateException异常。另外，从Deadmon线程中产生的线程也是守护线程。 协程、守护线程、僵尸进程和孤儿进程又都是什么？Linux内核的知识，之后再整理。 线程的创建 一共有四种创建线程的方式： 实现Runnable接口后再以此实例化Thread public class ThreadTest{ public static void main(String[] args){ Task task = new Task(); Thread a = new Thread(task); Thread b = new Thread(task); Thread c = new Thread(task); a.start(); b.start(); c.start(); } public class Task implements Runnable{ @Override public void run(){ for (int i = 0; i 这种方式比直接继承Thread要好，因为创建线程的意义在于多个线程来共同完成一项任务，而这项“任务”就是Runnable接口的实现类。这样的逻辑非常清晰，而且创建多个执行形同任务的线程，扩展性好。 实际上Runable是线程的工作单元，而Thread是线程的执行单元。 当然我们经常使用更加优雅的方式——匿名函数的函数来创建任务，例如： Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 这种写法比较优雅，但是匿名函数只能使用一次。 继承Thread类后重写run方法 Thread类本身就实现了Runnable接口，所以我们直接继承Thread后重写run方法即可。 例如： public class ThreadTest{ public static void main(String[] args){ MyThread thread = new MyThread(); thread.start(); } public lass MyThread extends Thread{ @Override public void run(){ for (int i = 0; i 使用Executor框架来创建线程池 使用Executor框架用来创建线程池，用线程池来对线程进行管理。可以自己创建ThreadPoolExecutor对象，更多时候是利用工具类Executors提供的静态方法来创建线程池，最常用的是以下三种常见方法： Executors.newFixedThreadPool： 创建一个固定长度的线程池 Executors.newCachedThreadPool： 创建一个无限长度的缓冲线程池 Executors.newSingleThreadExecutor：创建一个单线程的线程池 具体的用法可以参考下一篇博文\"Executors框架\"。 下面是利用Executors工具类来创建无限长度的缓冲线程池的例子： public class FixedThreadPoolTest { public static void main(String[] args) { ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(new Runnable() { @Override public void run() { try { System.out.println(\"Runnable1 begin : \" + System.currentTimeMillis()); Thread.sleep(10000); System.out.println(\"A\"); System.out.println(\"Runnable1 end:\" + System.currentTimeMillis()); }catch (InterruptedException e){ e.printStackTrace(); } } }); executor.execute(new Runnable() { @Override public void run() { try { System.out.println(\"Runnable2 begin : \" + System.currentTimeMillis()); Thread.sleep(10000); System.out.println(\"A\"); System.out.println(\"Runnable2 end:\" + System.currentTimeMillis()); }catch (InterruptedException e){ e.printStackTrace(); } } }); } } 实现Callable接口 Callable接口是定义在java.util.concurrent中的接口，和Runnable非常类似，都表示一项任务，能够让线程运行，也是一个函泛型参数化接口、数式接口，里面只有一个call方法，该方法可能会抛出异常Exception。 但是Callable和Runnable的使用具有巨大的区别。Thread类以Runnable实例作为参数实例化，然后通过start方法启动线程，实际上是等待run方法运行。而Callable通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用。例如： ExecutorService pool = Executors.newCachedThreadPool(); Future future = pool.submit(new Callable{ public String call(){ //TODO } }); 线程的管理 线程组 Java中的每一个线程都要父线程和线程组的概念。父线程是指创建当前线程所在的线程，这是无法指定的，但是线程组是可以指定的，即当我们创建线程的时候，可以传递线程组参数，使得该线程加入指定的线程组，如果没有指定，则该线程加入到父线程所在的线程组。 Java中ThreadGroup是线程组的定义，里面并没有添加线程的方法，有一个add方法比较有迷惑性，首先这个方法是私有的，我们外部无法调用，另外，这个方法的含义是在线程组中添加子线程组，而并非在线程组中添加线程。 任何一个线程都属于一个线程组，而一个线程组也一定有父线程组，所以线程组之间组成了树，而线程和线程组之间组成了集合。有一个顶级线程组，名字叫做\"System\"，最高优先级是10，这就是ThreadGroup中私有的那个构造方法，这个构造方法为C程序调用。 开发者创建线程组的时候，必须执行线程组的名字，之后我们可以用getName方法得到它。也可以指定父线程组，如果没有指定，那么将当前线程的线程组作为新线程组的父线程组。父线程组非常关键，因为子线程组的最高优先级和是否为守护线程组都将于父线程组保持一致（所以从守护线程组中一定都是守护线程，从守护线程中创建的线程也一定是守护线程）。 另外还有一点需要注意，我们可以使用setMaxPriority来改变某个线程组的最大优先级（这种改变也收到限制，即最后选择的是参数和其父线程组的最大优先级中的较小值），但是这个改变是递归的，即其子线程组的线程组的最大优先级也将改变。虽然已经存在的线程不受到影响，但是会影响加入到该线程组的新的线程，因为线程的优先级不能大于其所在线程组的maxPriority值。 线程组还能获取一些线程、子线程组的信息，比如activeCount返回该线程组及其子线程组中活动着的线程的数量，activeGroupCount返回该线程组中活动的子线程组的数量。enumerate将复制当前线程的线程组及其子组中的每一个活动线程到指定的数组。interrupt将中断该线程组中所有活动的线程，注意这个方法也是递归的。stopOrSuspend用来中断或挂起这个线程组中除了当前线程之外的所有线程。destroy方法用来销毁线程组(除初始线程组)其子线程组，但是前提是，线程组中已经没有活动着的线程了。list方法打印出线程组中线程的相关信息，这个方法只在debug的时候用到。toString方法将打印出当前线程组的信息，其格式是\"getClass().getName() + \"[name=\" + getName() + \",maxpri=\" + maxPriority + \"]\";\" 线程池 线程池对于线程而言不仅仅是管理了，而且是创建。JUC中Executor框架提供了线程池操作。具体内容可以参考下一篇博文“Executor框架”。 线程组和线程池的区别和联系 线程组和线程池都对线程进行了管理，也可以对线程进行控制（休眠，唤醒，结束，创建，中断（暂停），但是不一定都包含这些操作），两者有什么联系和区别么？ 两者并没有什么从属联系，虽然都是对线程进行管理，但是立足点是不一样的。 线程组存在的意义，首要原因是安全。Java默认创建的线程都是属于系统线程组，而同一个线程组的线程是可以相互修改对方的数据的。但如果在不同的线程组中，那么就不能“跨线程组”修改数据，可以从一定程度上保证数据安全。 线程池存在的意义，首要作用是效率。线程的创建和结束都需要耗费一定的系统时间（特别是创建），不停创建和删除线程会浪费大量的时间。所以，在创建出一条线程并使其在执行完任务后不结束，而是使其进入休眠状态，在需要用时再唤醒，那么 就可以节省一定的时间。如果这样的线程比较多，那么就可以使用线程池来进行管理。保证效率。 线程生命周期的控制 当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。那么这些线程中同一时刻只能有一个是被执行的，其他的都在等待，这就有了“线程的生命周期”一说。 下面是一张完整的线程的生命周期图，这张图给我背下来！闭着眼睛都能画出来的程度！ 线程一般有5种状态 新建：就是新建了一个线程对象。 就绪：即可运行状态，就是调用start()方法后，线程将进入一个线程池，等待系统分配资源，（注意不是说用start()方法后，线程就被执行的，他得等待获得资源），一旦得到CPU资源就能运行。注意，这个时候除了CPU之外的所有的资源都已经获得了，包括锁。 运行：就是系统给分配了资源（有的教材认为资源就是CPU的使用权），程序开始执行 阻塞：由于某种原因，程序执行到某种程度时，放弃了资源的使用权，暂时停止运行。满足相应条件后，又变成可运行状态，这个由分为几种情况： 等待阻塞：运行的线程执行了wait()方法；这时候将释放拥有的资源。 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用；这时候仍旧没有资源，在等待别人释放资源 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。这时候并没有释放资源，仍旧拥有资源，但是自己阻塞了 结束：也叫死亡状态，就是程序执行完成了，或发生异常退出run()方法了。 与线程阻塞状态相关的一些方法： wait、notify、notifyAll、yield、sleep、join。它们各自的用法和区别需要牢记在心。下面是一个总结： 比较项目 wait notify notifyAll yield sleep join 所属类、方法类比 Object类，实例方法 Object类，实例方法 Object类，实例方法 Thread类，静态方法 Thread类，静态方法 Thread类，实例方法 受影响的线程 当前线程 在该对象上wait的随机一个线程 在该对象上wait的所有线程 调用该的线程 当前线程 当前线程 状态转化 运行态 -> （等待）阻塞 等待）阻塞 - > (同步)阻塞 (等待)阻塞 -> (同步)阻塞 运行状态 -> 就绪状态 运行状态 - > （其他）阻塞 运行状态 -> (其他)阻塞 锁处理 释放所持有的锁 既没有锁的获得也没有锁的失去 既没有没有获得锁也没有锁的失去 不会释放任何资源 不会释放任何资源 不会释放任何资源 操作结果 当前线程由运行状态转变为阻塞状态，在某个对象上等待，直到等待时间结束或者由别的线程使用该对象的notify或者notifyAll方法唤醒，当前线程调用该方法后将释放锁 当前线程调用某个对象的notify方法，将会唤醒随机一个在该对象上等待的线程，但是注意，唤醒线程并不等于获得锁，被唤醒线程仍然处于阻塞状态，它需要竞争锁，所以该过程没有释放锁也没有获得锁 当前线程调用某个对象的notifyAll方法，将会唤醒所有正在该对象省等待的线程，但是注意，唤醒线程并不等于获得锁，这些线程仍旧处于阻塞状态，它们仍旧需要竞争锁，所以该过程没有释放锁也没有获得锁 调用该方法的当前线程将自动放弃时间片，做出让步，回到就绪状态，但是注意，该线程本身不会释放任何资源，它只是给和自己具有相同优先级的、已经就绪的线程再一次选择的机会。当前线程从运行状态转为就绪状态，让和自己有相同优先级别的线程再一次竞争，不能保证比自己优先级高的一定会在下一次被选中， 也有可能是自己再一次重新进入运行状态。只是暂时回到了起跑点，不会释放任何资源 当前线程进行休眠，不释放任何锁， 可以使得任何优先级的线程得到优先执行的机会。实际上是调用了自己的wait方法，当参数为0的时候表示无限等待，notify方法也可以唤醒sleep的线程，唤醒之后，将变为就绪状态。特别注意，该方法需要捕获 InterruptedException异常 当前方法A调用了其他线程B的该方法，那么原本并发的两个线程就变成了串行，A线程需要等到B线程执行完毕后才能继续执行。并发过程将变成串行过程，谁主动调用，谁垫后 线程的状态转化和执行依赖于具体代码和JVM调度，但是也提供了主动“杀死”线程的方法——interrupt，这里的杀死并不是真正的杀掉（忘了stop和suspend方法吧），而是温和的。这种温和的方式叫做“线程中断”。 interrupt只对由于wait、join和sleep而处于阻塞状态的线程有立竿见影的效果，如果处于这种线程的interrupt方法被执行，那么该线程会立即被唤醒，这里的唤醒不同于notify这种方法，而是抛出了一个InterruptedException异常，该线程以后该何去何从，完全依赖于异常处理的过程，有可能回归正途，有可能走歪路，也要可能over掉。很多时候这种中断是很有必要的，比如发生死锁的时候。但是注意了，interrupt对于非阻塞状态的线程是没有用的！！！interrupt对于非阻塞状态的线程是没有用的！！！interrupt对于非阻塞状态的线程是没有用的！！！重要的话说三遍。另外，synchronized在获取锁的过程，虽然它也是阻塞状态，但是中断是无效滴！ 线程同样提供了两种检查线程是否处于中断的方法，Thread.interrupted()和Thread.currentThread().isInterrupted()，在实现上，前者调用了后者，两者的区别如下： 比较项 Thread.interrupted() Thread.currentThread().isInterrupted() 是否静态 静态方法 实例方法 是否清除标志位 清除中断标志位（false） 不清除中断标志位 如果一个线程正处于中断状态，其interrupted被连续调用两次，那么第一次返回true，第二次返回false。原因在于第一次调用时，返回了true，然后将标志位清除了，第二次调用的时候就放回false。 线程死锁 线程互斥 竞争状态和临界区 在同一个程序中运行多个线程本身不会导致问题，问题在于如果多个线程访问了同一个资源，如同一内存区(变量、数组或对象)，系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。 线程竞争状态产生的原因是对共享数据的访问，对于Java程序来说，准确来讲，是对堆区和方法区的对象的多线程写操作才会出现竞争状态。而能对这些对象产生影响（改变）的代码叫做临界区。 写操作比如下面这个例子： public Class Counter{ protected long count = 0; public void add(long value){ this.count += value; } } 假设有A和B两个线程同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 从内存获取 this.count 的值放到寄存器 将寄存器中的值增加value 将寄存器中的值写回内存 观察线程A和B交错执行会发生什么： this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。 上例中要怎么做改变才能得到预期的结果5呢？很简单，只允许每次只有一个线程能执行add方法，比如A首先执行了add方法，在A没执行完之前，B不能用，等A完成了B才能进行add操作。道理都懂，但是怎么才能保证每次只有一个线程在执行呢？想想，给这个方法加一个标识就行了，A执行的时候，拿到这个标识，就表示：诶这个方法我先用了，其他人先等着。等到A执行完之后，释放这个标识，就表示：我用完了，其他人自便。那这个标识是什么呢？我们给这个标识起个很形象的名字，叫做“锁”。 以前学习操作系统的时候，关于多线程的互斥有过很多的解决方法，其中两个重要的概念就是“互斥量”和“信号量”，两者有什么联系和区别呢？ 互斥量和信号量都是操作系统中为并发编程设计的基本概念。两者的区别在于，对于同一个资源，互斥量只有0和1的概念，而信号量远不止于此。信号量可以使资源同时被多个线程访问，但是互斥锁只能是线程同时被一个线程访问。另外一个不同点是，互斥量用于线程的互斥，而信号量用于线程的同步。 如果实现这个“锁”，就是问题的关键所在，这就是Java的\"锁机制\"。 互斥和同步不是一个概念，这段视频讲的很清楚：http://www.imooc.com/video/5118 对哪些数据进行同步控制 首先需要明确的是，需要对一个对象的哪些资源进行协调。有JVM基本数据分区概念之后知道，JVM只要对其中两种数据进行监视： 保存在堆中的实例变量 保存在方法区的类变量 方法区和堆是线程不隔离的，所以需要进行线程同步，而保存在栈中的数据是不需要进行保护的，因为这个区域是线程隔离的。 synchronized关键字 一个很重要的常识是：Java中每一个对象都有一个内置锁。这是Java语言层实现的线程机制，不同于JDK 5中的Lock，不用显式地释放。可以使用synchronized关键字来获取这个内置锁。synchronized关键字可以修饰方法和代码块，分别叫做“同步方法”和“同步代码块”。 同步方法 用synchronized关键字修饰的方法，称为“同步方法”。由于每个对象都有内置锁，所以当synchronized关键字修饰方法时，内置锁会保护整个方法在同一时间只能被一个线程访问。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。对上面的例子来说，可以写成这样： public Class Counter{ protected long count = 0; public synchronized void add(long value){ this.count += value; } } 特别的是，如果synchronized修饰的是静态方法，那么将会获得类锁，类锁和对象锁是完全不同的锁，一个线程可以同时获取类锁和对象锁。 但是同步方法会影响效率，最好不要使用同步方法而改用同步代码块。 同步代码块 用synchronized关键字修饰的代码块，称为“同步代码块”，这时候，内置锁保护的区域是代码块。例如： public Class Counter{ protected long count = 0; public void add(long value){ synchronized(this){ this.count += value; } } } 由于add方法只有一条语句，这条语句放到了同步代码块中，所以它的效果和上面同步方法的效果是一样的。 同步方法和同步代码块能够保证同一时刻最多只有一个线程执行方法或代码块，下面是几个测试程序： 当两个并发线程访问同一个对象object中的这个synchronized(this) 同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 public class Thread1 implements Runnable { public void run() { synchronized(this) { for (int i = 0; i 执行结果是： A synchronized loop 0 A synchronized loop 1 A synchronized loop 2 A synchronized loop 3 A synchronized loop 4 B synchronized loop 0 B synchronized loop 1 B synchronized loop 2 B synchronized loop 3 B synchronized loop 4 ta线程首先执行，两者都执行了同一个对象的run方法，而run方法中的代码都放到了同步块中，所以ta首先拿到了对象t1的锁，此时tb线程只能等待ta执行完毕再执行。 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 public class ThreadTest { public void m1(){ synchronized (this){ int i = 5; while (i-- > 0){ System.out.println(Thread.currentThread().getName() + \" : \" + i); try{ Thread.sleep(500); }catch (InterruptedException e){ } } } } public void m2(){ int i = 5; while( i-- > 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); try { Thread.sleep(500); } catch (InterruptedException ie) { } } } public static void main(String[] args) throws Exception{ ThreadTest test = new ThreadTest(); Thread t1 = new Thread(new Runnable() { @Override public void run() { test.m1(); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { test.m2(); } }); t1.start(); t2.start(); } } 执行结果是： Thread-1 : 4 Thread-0 : 4 Thread-0 : 3 Thread-1 : 3 Thread-0 : 2 Thread-1 : 2 Thread-1 : 1 Thread-0 : 1 Thread-1 : 0 Thread-0 : 0 当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 将上例中的m2方法改成下面这种形式： public void m2(){ synchronized (this){ int i = 5; while( i-- > 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); try { Thread.sleep(500); } catch (InterruptedException ie) { } } } } 打印的结果是： Thread-0 : 4 Thread-0 : 3 Thread-0 : 2 Thread-0 : 1 Thread-0 : 0 Thread-1 : 4 Thread-1 : 3 Thread-1 : 2 Thread-1 : 1 Thread-1 : 0 也就是当一个对象的锁被其中一个线程获得的时候，其他的线程只能访问该对象的其他非同步方法，不能访问其他同步方法。 以上规则对其他对象锁也同样适用 注意到同步方法块synchronized有一个参数（同步方法的默认参数是this），这个参数代表什么意思呢？ 这个参数表示\"锁\"加到谁的身上。synchronized(this)表示线程锁加在被调用对象本身上，因此，同一时刻，该对象只能有一个synchronized方法会被一个线程调用，其它线程调用的synchronized方法都会阻塞以等待锁的释放。synchronized(obj)表示的线程的锁加到了obj这个对象上（也有可能是类上，比如synchronized(OtherClass.class)这种写法。），表示锁住的是另一个对象。 在同步方法块中用括号括起来的对象叫做“监视器对象”。 对于这一点，http://www.cnblogs.com/devinzhang/archive/2011/12/14/2287675.html 这篇博文中”房间和钥匙”的比喻很生动了，可以参考加深理解。 注意理解\"synchronized是线程级的，而不是方法级\"这句话的意思。如果两个方法A和B都对同一个对象加了synchronized方法，并且在A方法中调用了B方法。这时候有线程1调用A方法，那么执行到调用B方法的时候会等着释放锁么？不会。A和B都在一个线程里，线程1已经获得了锁，所以会畅通无阻地执行下去。 synchronized(this)适用于方法彼此间都会修改对象的某个状态，如果在某个对象的两个synchronized彼此不会共享任何资源，比如A中修改资源r1，B中修改资源r2，则在A和B中同时加上synchronized(this)会引起不必要的性能开销，因为调用A和B的线程不必要同步，此时简单的办法就是通过为A和B加不同的锁： Object lock1 = new Object(); Object lock2 = new Object(); public void A(){ synchronized(lock1){ } } public void B(){ synchronized(lock2){ } } 这样调用A和调用B的两个进程不会同步，只有都调用A或者都调用B的线程间需要同步。 之前提到“对象锁”和“类锁”的概念，如果synchronized同时修饰静态和非静态方法，会有什么结果呢？看下面这段测试程序： public class ThreadTest { public synchronized void m1(){ int i = 5; while (i-- > 0){ System.out.println(Thread.currentThread().getName() + \" : \" + i); try{ Thread.sleep(500); }catch (InterruptedException e){ } } } public synchronized static void m2(){ int i = 5; while( i-- > 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); try { Thread.sleep(500); } catch (InterruptedException ie) { } } } public static void main(String[] args) throws Exception{ ThreadTest test = new ThreadTest(); Thread t1 = new Thread(new Runnable() { @Override public void run() { test.m1(); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { ThreadTest.m2(); } }); t1.start(); t2.start(); } } 最后的输出结果是： Thread-0 : 4 Thread-1 : 4 Thread-0 : 3 Thread-1 : 3 Thread-1 : 2 Thread-0 : 2 Thread-1 : 1 Thread-0 : 1 Thread-0 : 0 Thread-1 : 0 可以看到两个线程是交替进行了，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。 有了上面的解释，来看看下面这段程序会输出什么？ public class ThreadTest { class Inner{ public void m1(){ int i = 5; while (i-- > 0){ System.out.println(Thread.currentThread().getName() + \" : \" + i); try{ Thread.sleep(500); }catch (InterruptedException e){ } } } public void m2(){ int i = 5; while( i-- > 0) { System.out.println(Thread.currentThread().getName() + \" : \" + i); try { Thread.sleep(500); } catch (InterruptedException ie) { } } } } private void m1(Inner inner){ synchronized (inner){ //使用对象锁 inner.m1(); } } private void m2(Inner inner){ inner.m2(); } public static void main(String[] args) throws Exception{ final ThreadTest test = new ThreadTest(); final Inner inner = test.new Inner(); Thread t1 = new Thread(new Runnable() { @Override public void run() { test.m1(inner); } }, \"t1\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { test.m2(inner); } }, \"t2\"); t1.start(); t2.start(); } } 尽管t1获得了inner对象的锁，但是t2访问的是同一个inner中的非同步部分。所以两个线程不会互相干扰。交替执行。但是如果ThreadTest中m2方法改成这样： private void m2(Inner inner){ synchronized (inner){ inner.m2(); } } 那么将会先执行t1，再执行t2。 如果main方法给成这样呢（在上例改变m2的基础上）？ public static void main(String[] args) throws Exception{ final ThreadTest test = new ThreadTest(); final Inner inner1 = test.new Inner(); final Inner inner2 = test.new Inner(); Thread t1 = new Thread(new Runnable() { @Override public void run() { test.m1(inner1); } }, \"t1\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { test.m2(inner2); } }, \"t2\"); t1.start(); t2.start(); } 当然是两个线程交替执行了，因为引用的不是同一个Inner类实例。 总结一下： 线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。 对于同步，要时刻清醒在哪个对象上同步，这是关键。 synchronied关键字是不能被继承的，即如果父类中某个方法用synchronized关键字修改，在子类继承得到这个方法后，这个方法将失去synchronized关键字。 实现原理 前面说道，synchronized取得的是内置锁，那么背后到底是什么原理呢？其实就是操作系统中“监视器”的概念。 关于监视器的具体说明，可以参考监视器–JAVA同步基本概念 在SUN的HopSpot JVM中，synchronized锁又叫做\"监视器锁\"。在JVM中，每个对象和类在逻辑上都是和一个监视器相关联的。对于对象来说，相关联的监视器保护对象的实例变量。对于类来说，相关联的监视器保护类的类变量。换句话说，如果一个对象没有实例变量，或者一个类没有类变量，相关联的监视器就什么都不监视。 为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。 但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器） 类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。 一个线程可以多次对同一个对象上锁。对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。 而syncrhoized(lock)加锁时，用到的其实只是lock对象内置的monitor而已，假设有代码块 syncrhoized（Object lock）{ 同步代码...; } 它在字节码文件中被编译为： monitorenter;//获取monitor许可证，进入同步块 同步代码... monitorexit;//离开同步块后，释放monitor许可证 当多个线程访问这个对象的时候，对象监视器会将这些请求存储在不同的容器中： Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中 Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中 Wait Set：那些调用wait方法被阻塞的线程被放置在这里 OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck Owner：当前已经获取到所资源的线程被称为Owner !Owner：当前释放锁的线程 他们之间的关系如下图所示： 他们协调工作的实现细节可以参见原博客http://www.cnblogs.com/longshiyVip/p/5213771.html 原子性和可见性 把代码块声明为synchronized，有两个重要后果，通常是指该代码具有原子性（automicity）和可见性（visibility）。 原子性：原子性意味着某个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor Object保护。从而防止多个线程在更新共享状态时相互冲突。 可见性：可见性要对付内存缓存和编译器优化的各种反常行为。它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。 原子性比较好理解，可见性非常重要。如果没有同步机制提供这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。如何实现可见性的呢？当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。同样，在对象释放锁之前，它会刷新其高速缓存。强制使已做的任何更改都出现在主内存中。这样，可以保证在同一个锁上同步的两个线程看到在synchronized块内修改的变量的相同值。 Java中有一个修饰符volatile，这个修饰符只能保证可见性，不能保证原子性。 死锁 死锁是多线程开发中比较常见的一个问题。若有多个线程访问多个资源时，相互之间存在竞争，就容易出现死锁。下面就是一个死锁的示例，当一个线程等待另一个线程持有的锁时，而另一个线程也在等待该线程锁持有的锁，这时候两个线程都会处于阻塞状态，程序便出现死锁。 class Thread01 extends Thread{ private Object resource01; private Object resource02; public Thread01(Object resource01, Object resource02) { this.resource01 = resource01; this.resource02 = resource02; } @Override public void run() { synchronized(resource01){ System.out.println(\"Thread01 locked resource01\"); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (resource02) { System.out.println(\"Thread01 locked resource02\"); } } } } class Thread02 extends Thread{ private Object resource01; private Object resource02; public Thread02(Object resource01, Object resource02) { this.resource01 = resource01; this.resource02 = resource02; } @Override public void run() { synchronized(resource02){ System.out.println(\"Thread02 locked resource02\"); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (resource01) { System.out.println(\"Thread02 locked resource01\"); } } } } public class DeadLock { public static void main(String[] args) { final Object resource01=\"resource01\"; final Object resource02=\"resource02\"; Thread01 thread01=new Thread01(resource01, resource02); Thread02 thread02=new Thread02(resource01, resource02); thread01.start(); thread02.start(); } } 执行结果: Thread02 locked resource02 Thread01 locked resource01 执行上面的程序就会一直等待下去，出现死锁。当线程Thread01获得resource01的锁后，等待500ms，然后尝试获取resource02的锁，但是此时resouce02锁已经被Thread02持有，同样Thread02也等待了500ms尝试获取resouce01锁，但是该所已经被Thread01持有，这样两个线程都在等待对方所有的资源，造成了死锁。 注意，一旦使用synchronied进行线程同步的时候如果发生了死锁，那么是无法中断的。这是synchronied的缺点，为此，java.util.concurrent.lock包中提出了各种各样的锁，这些锁比synchronied具有更好的同步效果。 锁重入 关键字synchronized具有锁重入功能。锁重入的意思是：当一个线程已经持有一个对象锁之后，再次请求该对象锁是可以得到该对象的锁的。这种方式是必须的，否在在一个synchronized方法内部就没办法调用该对象的另一个synchronized方法了。 锁重入的原理是通过为每个锁关联一个计数器和一个占有它的线程。当计数器为0的时候，表示锁是未被占有的。线程请求一个被未被占有的锁时，JVM会记录锁的占有者，并为计数器设置为1。如果同一个线程再次请求该锁，计数器会递增，每次占有的线程退出同步代码块的时候计数器会递减，直至减为0的时锁才会被释放。 在声明一个对象作为锁的时候要注意字符串类型锁对象，因为字符串有一个常量池，如果不同的线程持有的锁是具有相同字符的字符串锁时，两个锁实际上是同一个锁。 synchronied的限制 它无法中断一个正在等候获得锁的线程。 无法通过投票得到锁，如果不想等下去，也就没法得到锁。 同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行，多数情况下，这没问题（而且与异常处理交互的很好），但是，确实存在一些非块结构的锁更合适的情况。 Lock Lock是JDK5开始，包java.util.concurrent.locks中的一个接口。Lock提供了比使用synchronized方法和语句可获得的更广泛的锁定操作，它能以更优雅的方式处理线程同步问题。注意到，这里locks用了复数，是因为这个包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），其实现都依赖java.util.concurrent.AbstractQueuedSynchronizer类（简称AQS）。 java AQS的实现原理（大部分同步类都依赖AQS实现） 一步步透彻理解Lock的Acquire和Release原理源码 同步 Object监视器 Condition 并发编程 同步器 JDK提供的用于并发编程的同步器： 截止1.8位置Java锁的种类以及辨析 参考 多核 CPU 和多个 CPU 有何区别？ 多核与多个CPU啥区别 编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程 多个处理器和多核处理器的区别 进程与线程的一个简单解释 线程和进程的区别是什么？ 我是一个线程 深入理解进程和线程 Java中Wait、Sleep和Yield方法的区别 Java线程状态转换 一张图让你看懂JAVA线程间的状态转换 Java线程：线程的同步与锁 Java 多线程（七）——线程组与线程池 java中的互斥锁,信号量和多线程等待机制 Java并发编程——信号量与互斥量 Java线程：线程的同步与锁 【Java线程】锁机制：synchronized、Lock、Condition 深入浅出Java并发包—锁机制(一) 监视器–JAVA同步基本概念 并发编程学习总结(三) ： 线程的中断详解 Java 为什么使用线程池？又如何优化线程池 透彻理解 Java synchronized 对象锁和类锁的区别 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-28 10:44:15 "},"Java基础知识整理/Executor框架.html":{"url":"Java基础知识整理/Executor框架.html","title":"Executor框架","keywords":"","body":"Executor框架 Executor是Java提供的有关于线程的框架，在JDK1.5中被提出。在此之前，线程即是工作单元也是执行机制。而Executor框架将线程的工作单元和执行机制相互分离，其中Runnable和Callable是工作单元，而Executor框架则提供了线程的执行机制。 Executor框架主要包含三个部分 部分 内容 任务 包括Runnable和Callable，其中Runnable可以表示一个异步执行的任务，而Callable表示一个会产生结果的任务 任务的执行 包括核心接口Executor及其子接口ExecutorService，有两个类——ThreadPoolExecutor和ScheduledThreadPollExecutor实现了ExecutorService接口 异步计算的结果 包括接口Future及其实现了FutureTask 为什么线程池 首先我们要弄清楚为什么要用线程池？ 之前我们用继承Thread类和继承Runnable接口的方法来创建线程，完全能够运作起来，没有什么不妥。但是试想这样一种情况：许多服务器应用程序都面向处理来自远程来源的多而小的任务，应用程序需要为每一个任务都创建一个线程，然后让线程执行完程序之后，再进行销毁，如此反复，导致造成这样一种局面：创建和销毁线程带来的开销远大于处理业务的开销。另外，只要线程活动着，它就会消耗资源。所以，如果系统创建了过多的线程，在一个JVM中创建了太多的线程将可能导致系统由于过度消耗内存而用完内存或“切换过度”。为了防止资源不足，应用程序需要一些办法来限制任何给定时刻处理的请求数目。 基于以上的考虑，线程池应运而生。它的基本原理是线程的重用：当请求到达时，由于线程已经存在，所以也就不用再创建线程，也不用等创建成功后再进行操作，既节省了资源空间，也提高了响应速度。另外，线程池的线程数目是有上线的，当一个任务到来但是已无线程可用的时候，需要强制使新到的任务等待，一直等到其获取线程为止，这样就可以避免资源不足的问题。（说到这里，想到了Semaphore的应用） 总的来说，以下原因促使线程池出现： 创建/销毁线程伴随着系统的开销，过于频繁的创建/销毁线程将影响处理效率。 线程并发量过多，抢占系统资源从而导致阻塞 对线程进行一些简单的管理，比如延迟执行，定时循环执行等。 Java在JUC中提供了Executor框架，框架中重要类的继承树如下： 其实这其中重要的一个是Executors工厂类。 Executor框架 Executor接口 Executor接口是Executor框架最重要的根本的接口，里面定义了execute方法，用来执行任务。 ExecutorService接口 ExecutorService直接继承了Executor接口，另外还提供了任务的管理办法，比如shutdownNow来立即停止一切任务，shutdown来停止接受新任务，并等待之前提交的任务完成，submit方法用来提交任务，注意该方法的返回值是异步结果Future。 ThreadPoolExecutor 这个类非常非常非常重要，可以说是Executor框架的核心。它定义一个线程的处理流程，具体如下： 我们需要熟悉几个参数的含义： corePoolSize： 核心线程的数量 maxPoolSize：线程池的最大数量 keepAliveTime： 线程空闲时间数量 workQueue：阻塞队列 handler：拒绝策略，包括四种(AbortPolicy|DiscardPolicy|DiscardOldestPolicy|CallerRunsPolicy)，默认AbortPolicy。 上图中的流程可以这样解释： 当一个任务被执行后，它首先需要判断当前线程数量是否小于corePoolSize，如果是，则新建线程运行，如果不是，则考虑放到workQueue中。如果此时workQueue还有空间，那么就放到阻塞队列中，如果已经满了，那么就看当前线程数量是否小于maxPoolSize，如果是，则创建线程，如果不是，则使用拒绝策略。 这就是ThreadPoolExecutor这个类最重要的地方。一般情况下，我们使用的是Executors工厂类为我们创建的四种线程池。而他们本质上，是使用了不同的参数来创建的ThreadPoolExecutor。不同的参数导致了不同类型的线程池。 Executors Executors是Executor框架中的工具类，它提供了很多线程操作的支持。具体如下： 对于ExecutorService的支持 Executors中提供了不同的线程池的获取， 方法名称 newFixedThreadPool newCachedThreadPool newSingleThreadExecutor 线程池特点 固定线程数量，无界队列 可缓存线程池， 线程池固定大小为1，无界队列 处理方式 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 corePoolSize 自定义 0 1 maximumPoolSize 自定义，与corePoolSize保持一致 Integer.MAX_VALUE 1 keepAliveTime 0 60分钟 0 workQueue类型 LinkedBlockingQueue SynchronousQueue LinkedBlockingQueue threadFactory DefaultThreadFactory DefaultThreadFactory DefaultThreadFactory handler AbortPolicy AbortPolicy AbortPolicy 备注 使用FinalizableDelegatedExecutorService对ThreadPoolExecutor进行包装 优点 保证新任务不会被拒绝 保证新任务不会被拒绝 缺点 当任务处理无线等待的是会造成内存问题 当任务处理无线等待的是会造成内存问题 适用于 逻辑上需要单线程处理任务的场景 对于ThreadFactory的支持 主要定义了DefaultThreadFactory和PrivilegedThreadFactory用于返回创建新线程的线程工厂。前者是默认定义，主要是约定了线程名字为pool-[线程池编号]-thread-[该线程池的线程编号]和线程优先级固定为Thread.NORM_PRIORIT。后者继承前者，约定线程的优先级与当前线程具有同样的优先级。 对于Callable的支持 特别注意的是callable(Runnable task, T result)方法，它用Runable类型的对象作为参数，但是内部转成了callable并返回结果，其中的原因是使用了适配器RunnableAdapter。 定义如下： // 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。callable(task)等价于callable(task, \bnull)。 public static Callable callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter(task, result); } // RunnableAdapter类 /** * A callable that runs given task and returns given result */ static final class RunnableAdapter implements Callable { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } 使用Executors来创建线程池 官方建议使用Executors来创建线程池，但是最近阿里发布的Java开发手册中强调线程池的建立禁止使用Executors，而是通过 ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 这里，我们还是需要知道Executors如何创建线程池，并运行线程。下面是一个用newCachedThreadPooll来创建无界限线程池的例子： public class FixedThreadPoolTest { public static void main(String[] args) { ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(new Runnable() { @Override public void run() { try { System.out.println(\"Runnable1 begin : \" + System.currentTimeMillis()); Thread.sleep(10000); System.out.println(\"A\"); System.out.println(\"Runnable1 end:\" + System.currentTimeMillis()); }catch (InterruptedException e){ e.printStackTrace(); } } }); executor.execute(new Runnable() { @Override public void run() { try { System.out.println(\"Runnable2 begin : \" + System.currentTimeMillis()); Thread.sleep(10000); System.out.println(\"A\"); System.out.println(\"Runnable2 end:\" + System.currentTimeMillis()); }catch (InterruptedException e){ e.printStackTrace(); } } }); } } 执行效果如下： Runnable1 begin : 1520171243755 Runnable2 begin : 1520171243756 A Runnable1 end:1520171253758 A Runnable2 end:1520171253760 下面的代码是一个程序复用的例子： public class MyRunnable implements Runnable { private String username; public MyRunnable(String username) { super(); this.username = username; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" begin:\" + System.currentTimeMillis()); System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" end:\" + System.currentTimeMillis()); } } public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i 执行效果如下： pool-1-thread-1 username=0 begin:1470229448635 pool-1-thread-4 username=3 begin:1470229448635 pool-1-thread-3 username=2 begin:1470229448635 pool-1-thread-2 username=1 begin:1470229448635 pool-1-thread-3 username=2 end:1470229448635 pool-1-thread-4 username=3 end:1470229448635 pool-1-thread-5 username=4 begin:1470229448635 pool-1-thread-1 username=0 end:1470229448635 pool-1-thread-5 username=4 end:1470229448636 pool-1-thread-2 username=1 end:1470229448635 pool-1-thread-1 username=2 begin:1470229450637 pool-1-thread-3 username=4 begin:1470229450637 pool-1-thread-3 username=4 end:1470229450637 pool-1-thread-2 username=0 begin:1470229450637 pool-1-thread-2 username=0 end:1470229450638 pool-1-thread-5 username=1 begin:1470229450637 pool-1-thread-4 username=3 begin:1470229450637 pool-1-thread-4 username=3 end:1470229450638 pool-1-thread-5 username=1 end:1470229450638 pool-1-thread-1 username=2 end:1470229450637 由打印结果可见，第一次for循环中创建了5个线程对象分别是pool-1-thread-1到pool-1-thread-5，第二次for循环中没有创建新的线程对象，复用了第一次for循环中创建的线程对象。 下面是一个使用自定义线程工厂创建无界线程池的例子： public class MyThreadFactory implements ThreadFactory { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setName(\"定制池中线程对象的名称\" + Math.random()); return thread; } } public class Run { public static void main(String[] args) { MyThreadFactory myThreadFactory = new MyThreadFactory(); ExecutorService executorService = Executors.newCachedThreadPool(myThreadFactory); executorService.execute(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + \"运行：\" + System.currentTimeMillis()); } }); } } 程序执行结果如下： 定制池中线程对象的名称0.2671917944865071运行：1470230269473 下面使用newFixedThreadPool(int)方法创建有界线程池： public class MyRunnable implements Runnable { String username; public MyRunnable(String username) { super(); this.username = username; } @Override public void run() { try { System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" begin:\" + System.currentTimeMillis()); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" end:\" + System.currentTimeMillis()); } catch (Exception e) { e.printStackTrace(); } } } public class Run { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i 线程执行结果如下： pool-1-thread-1 username=0 begin:1470230865037 pool-1-thread-3 username=2 begin:1470230865037 pool-1-thread-2 username=1 begin:1470230865037 pool-1-thread-3 username=2 end:1470230867043 pool-1-thread-1 username=0 end:1470230867042 pool-1-thread-3 username=0 begin:1470230867043 pool-1-thread-1 username=1 begin:1470230867043 pool-1-thread-2 username=1 end:1470230867043 pool-1-thread-2 username=2 begin:1470230867043 pool-1-thread-3 username=0 end:1470230869047 pool-1-thread-1 username=1 end:1470230869047 pool-1-thread-2 username=2 end:1470230869047 此时线程池中最多有三个线程。 下面是使用使用newSingleThreadExecutor()方法创建单一线程池 public class MyRunnable implements Runnable { String username; public MyRunnable(String username) { super(); this.username = username; } @Override public void run() { try { System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" begin:\" + System.currentTimeMillis()); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \" username=\" + username + \" end:\" + System.currentTimeMillis()); } catch (Exception e) { e.printStackTrace(); } } } public class Run { public static void main(String[] args) { ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i 程序执行结果如下： pool-1-thread-1 username=0 begin:1470231470978 pool-1-thread-1 username=0 end:1470231472978 pool-1-thread-1 username=1 begin:1470231472978 pool-1-thread-1 username=1 end:1470231474982 pool-1-thread-1 username=2 begin:1470231474982 pool-1-thread-1 username=2 end:1470231476984 可以看到，此时线程池中只有一个线程。 参考 Java并发编程核心方法与框架-Executors的使用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-16 14:57:02 "},"Java基础知识整理/锁.html":{"url":"Java基础知识整理/锁.html","title":"锁","keywords":"","body":"锁 互斥锁 排他锁 可重入锁 读写锁 阻塞锁 公平锁 非公平锁 互斥锁 互斥锁是指，当一个线程尝试去获取锁的时，如果该锁已经被其他线程占用，那么它就将进入睡眠或阻塞状态，这个方法保证了公共资源在任意时刻最多只能由一条线程获取使用。我们的对象的内置锁就是一个互斥锁。 自旋锁 自旋锁同样保证了公共资源在任意一个时刻最多只能由一条线程获取使用，但是与互斥锁不同的是，当检测到锁已经被其他线程获得的时候，而不是进入线程挂起或睡眠状态。而是此线程将不断循环检查该锁是否被释放。自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。 public class SimpleSpinLock { private AtomicReference owner = new AtomicReference(); public void lock() { Thread currentThread = Thread.currentThread(); // 如果锁未被占用，则设置当前线程为锁的拥有者 while (owner.compareAndSet(null, currentThread)) { } } public void unlock() { Thread currentThread = Thread.currentThread(); // 只有锁的拥有者才能释放锁 owner.compareAndSet(currentThread, null); } } SimpleSpinLock里有一个owner属性持有锁当前拥有者的线程的引用，如果该引用为null，则表示锁未被占用，不为null则被占用。 这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。 缺点： CAS操作需要硬件的配合； 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重； 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。 Ticket Lock Ticket Lock 是为了解决上面的公平性问题，类似于现实中银行柜台的排队叫号：锁拥有一个服务号，表示正在服务的线程，还有一个排队号；每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，如果是，则表示自己拥有了锁，不是则继续轮询。 当线程释放锁时，将服务号加1，这样下一个线程看到这个变化，就退出自旋。 简单实现： public class TicketLock { private AtomicInteger serviceNum = new AtomicInteger(); // 服务号 private AtomicInteger ticketNum = new AtomicInteger(); // 排队号 public int lock() { // 首先原子性地获得一个排队号 int myTicketNum = ticketNum.getAndIncrement(); // 只要当前服务号不是自己的就不断轮询 while (serviceNum.get() != myTicketNum) { } return myTicketNum; } public void unlock(int myTicket) { // 只有当前线程拥有者才能释放锁 int next = myTicket + 1; serviceNum.compareAndSet(myTicket, next); } } 缺点： Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。 CLH锁和MCS锁都是为了解决这个问题的。 CLH锁和MCS锁 CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁。其思想是通过一定手段将所有线程对某一共享变量轮询竞争转化为一个线程队列且队列中的线程各自轮询自己的本地变量。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。 这个转化过程由两个要点，一是构建怎样的队列&如何构建队列，为了保证公平性，构建的将是一个FIFO队列，构建的时候主要通过移动尾部节点tail实现队列的排队，每个想获取锁的线程创建一个新节点并通过CAS原子操作将新节点赋予tail，然后让当前线程轮询前一节点的某个状态位。 public class CLHLock { public static class CLHNode { private boolean isLocked = true; // 默认是在等待锁 } @SuppressWarnings(\"unused\" ) private volatile CLHNode tail ; private static final AtomicReferenceFieldUpdater UPDATER = AtomicReferenceFieldUpdater . newUpdater(CLHLock.class, CLHNode .class , \"tail\" ); public void lock(CLHNode currentThreadCLHNode) { CLHNode preNode = UPDATER.getAndSet( this, currentThreadCLHNode); // 转载人注释: 把this里的\"tail\" 值设置成currentThreadCLHNode if(preNode != null) {//已有线程占用了锁，进入自旋 while(preNode.isLocked ) { } } } public void unlock(CLHNode currentThreadCLHNode) { // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。 if (!UPDATER .compareAndSet(this, currentThreadCLHNode, null)) { // 还有后续线程 currentThreadCLHNode. isLocked = false ;// 改变状态，让后续线程结束自旋 } } } 将众多线程长时间对某资源的竞争，通过有序化这些线程转化为只需对本地变量检测。唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但竞争的线程的数量已经少了很多，且比起所有线程直接对某资源竞争的轮询次数也减少了很多，节省了很多CPU缓存同步操作，大大提升系统性能，利用空间换取性能。 AQS中的CLH队列是一个改进后的队列，改进的地方有两点：点的结构与节点等待机制。在结构上引入了头结点和尾节点，他们分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关，并且每个节点都引入前驱节点和后后续节点的引用；在等待机制上由原来的自旋改成阻塞唤醒。 MCS Spinlock 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。 public class MCSLock { public static class MCSNode { MCSNode next; boolean isLocked = true; // 默认是在等待锁 } volatile MCSNode queue ;// 指向最后一个申请锁的MCSNode private static final AtomicReferenceFieldUpdater UPDATER = AtomicReferenceFieldUpdater . newUpdater(MCSLock.class, MCSNode. class, \"queue\" ); public void lock(MCSNode currentThreadMcsNode) { MCSNode predecessor = UPDATER.getAndSet(this, currentThreadMcsNode);// step 1 if (predecessor != null) { predecessor.next = currentThreadMcsNode;// step 2 while (currentThreadMcsNode.isLocked ) {// step 3 } } } public void unlock(MCSNode currentThreadMcsNode) { if ( UPDATER.get( this ) == currentThreadMcsNode) {// 锁拥有者进行释放锁才有意义 if (currentThread.next == null) {// 检查是否有人排在自己后面 if (UPDATER.compareAndSet(this, currentThreadMcsNode, null)) {// step 4 // compareAndSet返回true表示确实没有人排在自己后面 return; } else { // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者 // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完 while (currentThreadMcsNode.next == null) { // step 5 } } } currentThreadMcsNode.next.isLocked = false; currentThreadMcsNode.next = null;// for GC } } } 两者的比较： 从代码实现来看，CLH比MCS要简单得多。 从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋 从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。 CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。 注意：这里实现的锁都是独占的，且不能重入的。 偏向锁 大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier） 偏向锁的获取 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁的撤销 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word，要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 偏向锁的设置 关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。 轻量级锁 加锁 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。 解锁 轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。 重量级锁 重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。 参考 自旋锁、排队自旋锁、MCS锁、CLH锁 Java并发框架——AQS阻塞队列管理（一）——自旋锁 Java并发框架——AQS阻塞队列管理（二） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 12:19:38 "},"Java基础知识整理/生产者消费者模型.html":{"url":"Java基础知识整理/生产者消费者模型.html","title":"生产者消费者模型","keywords":"","body":"\"生产者-消费者\"模型 首先要明确一下这个模型的意义。“生产者”是指“生产”某个东西，而\"消费者\"是指“消耗”由生产者“生产”出来的东西。 两者生产和消耗的速度是不一样的。我们开辟一个公共的空间，让生产者将生产的东西往这个空间里存放，然后让消费者从这个空间中取出。我们不能让同一时刻既让生产者往里仍东西，也让消费者往里面存东西，同一时刻是能有一个生产者往里面仍东西，或者只有一个消费者里面取东西。所以我们对这个公共的空间上一把锁，只有获得了锁的那个人才能操纵这个空间。另外还有一个问题，就是空间的状态和不同角色的操作之间具有限制关系，比如此时一个生产者拿到了锁，美滋滋地想要往空间里面扔东西了，却发现，坏了，空间已经满了，那么它只能放弃这个好不容易得到的锁，然后关到一个小黑屋里面，只有等到有空间扔东西的时候在把它放出来，再参与抢夺锁的竞争。如果后面一个来的还是一个生产者，同样被关到小黑屋中...直到一个消费者从里面取出一个东西，这时候它就要发出一个号令：有空间啦，你们都出来吧。好了所有小黑屋里面人都自由了，重新投入到新一轮的锁的争夺中。如果生产者速度太慢，消费者又太多了，僧多粥少，一个消费者抢到了锁，美滋滋地打开空间一看，好家伙，啥也没有，好吧，白抢了一把锁，我也要进小黑屋了，这锁我不不要了，你们谁要谁拿去（当然生产是一个生产者抢到了，这样我就能少在小黑屋中呆一会了），有东西可以取了再来通知我。如果这人运气不错，刚进小黑屋，后面锁被一个生产者抢到了，生产者往里扔了一个东西，然后吆喝：地主家有余粮了，快来抢，\b这时候所有小黑屋里的人都可以出来了。 这就是生产者-消费者的模型。 我们大概可以抽象出这样的结构：生产者和消费者是两类进程，它们“扔东西”和“取东西”就是各自run方法的实现。而公共的空间我们可以用一个数组、队列或者栈（随便什么都好，反正能存数据就行），然后每次进行操作之前，都尝试获取同一个“锁”，获取到之后，当空间满的时候生产者需要放弃锁然后等待，当空间空的时候消费者需要放弃锁然后等待。 使用wait/notify/notifyAll 使用wait和notify或notifyAll方法实现的“生产者-消费者”模型的程序如下： public class ProducerCustomerInJava { class Producer extends Thread{ private Queue queue; private int maxSize; public Producer(Queue queue, int maxSize, String name){ super(name); this.queue = queue; this.maxSize = maxSize; } @Override public void run() { while (true){ synchronized (queue){ while (queue.size() == maxSize){ try { System.out.println(\"Queue is full, Producer thread waiting for customer to take something for queue\"); queue.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } Random random = new Random(); int i = random.nextInt(); System.out.println(\"Producing value: \" + i); queue.add(i); queue.notifyAll(); } } } } class Customer extends Thread{ private Queue queue; private int maxSize; public Customer(Queue queue, int maxSize, String name){ super(name); this.queue = queue; this.maxSize = maxSize; } @Override public void run() { while (true){ synchronized (queue){ while (queue.isEmpty()){ //当缓冲区为空，则等待 System.out.println(\"Queue is empty, Customer thread is waiting for Producer thread to put something in queue\"); try { queue.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } Integer value = queue.remove(); System.out.println(\"Consuming value : \" + value); queue.notifyAll(); } } } } public static void main(String[] args) { System.out.println(\"How to use wait and notify method in Java\"); System.out.println(\"Solving Product Consumer Problem\"); Queue buffer = new LinkedList<>(); int maxSize = 10; ProducerCustomerInJava test = new ProducerCustomerInJava(); Thread producer = test.new Producer(buffer, maxSize, \"PRODUCER \"); Thread customer = test.new Customer(buffer, maxSize, \"CUSTOMER \"); producer.start(); customer.start(); } } 上面程序中的“锁”，用的是对象的内置锁，这个对象就是公共空间，而这个公共空间我们采取队列来存储。 一个非常重要的一点是，一般我们听到“如果空间满，那么生产者需要\b放弃锁进行等待”，我们可能会用到if判断语句，这种做法是错的，因为如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以需要记住的一点是：永远在loop(循环)中调用wait和notif语句，而不是在if语句。 下面这是使用wait和notify语句的模板代码： // The standard idiom for calling the wait method in Java synchronized (sharedObject) { while (condition) { sharedObject.wait(); // (Releases lock, and reacquires on wakeup) } // do action based upon condition e.g. take or put into queue } 就像我之前说的一样，在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。 使用Condition class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; } finally { lock.unlock(); } } } 使用BlockingQueue队列 class Producer implements Runnable { private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } } 参考 如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例 Java使用管道实现进程间通讯 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-16 14:57:02 "},"Java基础知识整理/线程通信和进程通信.html":{"url":"Java基础知识整理/线程通信和进程通信.html","title":"线程通信和进程通信","keywords":"","body":"线程通信和进程通信 进程间的通信 IPC，Inter-Porcess Communcation，进程是资源分配的基本单位，当多个进程间需要通信的时候，可以采取以下办法： 管道（Pipe） 管道是一种半双工的通信方式，数据只能单向流动（所以如果想要双向通信，需要建立起两个管道），而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。 有名管道（named pipe） 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。 信号量（semophore） 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列（message queue） 消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号（signal） 信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。 共享内存（shared memory） 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 套接字（socket） 套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。 线程间的通信 同一个进程中的线程可以共享进程的资源，所以对于线程来说，它们之间的通信并不是为了共享资源，而是为了同步， 所以线程没有像进程通信中那样的用于数据交换的通信机制。常常采用的方式有： 锁机制 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。 读写锁：允许多个线程同时读共享数据，而对写操作互斥。 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制：包括无名线程信号量与有名线程信号量 信号机制：类似于进程间的信号处理。 参考 进程间的几种通信方式的比较和线程间的几种通信方式 进程间通信的方式——信号、管道、消息队列、共享内存 进程间通信（IPC）介绍 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-18 21:29:34 "},"Java基础知识整理/协程、孤儿线程、僵尸线程、守护线程.html":{"url":"Java基础知识整理/协程、孤儿线程、僵尸线程、守护线程.html","title":"协程、孤儿线程、僵尸线程、守护线程","keywords":"","body":"协程、孤儿线程、僵尸线程、守护线程 面试碰到的问题，原来真的是听都没听过，囧... 用户态和内核态 用户态线程和内核态线程 线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，前者又称为内核支持的线程或轻量级进程。 内核级线程：切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。Windows NT和2000/XP支持内核线程。 用户级线程：内核的切换由用户态程序自己控制内核切换，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核CPU。目前Linux pthread大体是这么做的。不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。 协程 Python 协程 次时代Java编程（一）：Java里的协程 ！！ Java中的协程 孤儿线程 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-23 09:32:12 "},"Java基础知识整理/标准IO.html":{"url":"Java基础知识整理/标准IO.html","title":"标准IO","keywords":"","body":"标准IO 一直以来都搞不明白IO的framework，总觉得好多类啊好烦躁啊。现在来具体学习一下。 Java IO一般包含两个部分： java.io中堵塞型IO。 java.nio中非堵塞型IO。 前者是基础，后者是扩展，通常称为\"NEW IO\"。到底new在什么地方呢？ 操作系统的知识高速我们系统运行的瓶颈一般在于IO操作，一般打开某个IO通道需要大量的时间，同时端口中不一定就有足够的数据，这个read方法就一直等待获取此的端口的内容，从而浪费大量的系统资源。诶？不是有多线程技术。话是这么说，但是创建线程也要法费一定的时间和系统资源的，因此不一定可取。 Java NEW IO的非堵塞技术主要采取用了Observe模式，就是有一个具体的观察者来检测IO端口，如果有数据进入就会立即通知相应的应用程序。这样我们就避免建立多个线程，同时也避免了read等待的时间。 不过我们还是先学习下java.io。 概述 这个包中包含了非常非常多的IO类和接口（JDK1.6中有83个类或者接口，JDK1.8中没数反正很多）。这么多的类和接口，我们怎么入手呢？ IO可以进行简单的分类。IO主要包含三部分 流式部分。 这一部分是IO的主体部分。这部分可以概括为两个对象一个桥梁。 \"两个对象\"是指字节流（Byte stream） 和字符流（Char Stream） 的对应，“一个桥梁”是指从字节流到字符流的桥梁，对应于输入和输出为InputStreamReader和OutputStreamWriter。 非流式部分。 这一部分主要包含一些辅助流式部分的类，比如File类、RandomAccessFile类和FileDescriptor类。 文件读取部分的与安全相关的类和以及与本地操作系统相关的文件系统的类。 前者比如SerializablePermission类，后者比如FileSystem类和Win32FileSystem类和WinNTFileSystem类。 所以我们首先要把重点放在\"IO\"流上。 IO中的流 流是什么？ 流是一组有顺序的， 有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输。 注意到上高亮的部分，可以知道流具有最基本的特点：“One dimension , one direction.” 即流是一维的，同时流是单向的。关于维和我们通常说的一维长度，二维平面，三维空间，四维时空……是同一个概念，流就是一维的。单向就是只可以一个方向（按顺序从头至尾依次）读取，不可以读到某个位置，再返回前面某个位置。 流的这种特性在JMS（Java Message Service）的API设计中得到了体现。JMS是J2EE平台下面向消息中间件的一个标准。（关于中间件技术有机会和大家探讨）JMS中有五种具体类型的消息，这些消息一般分为两类：①流式的消息――包含ByteMessage和StreamMessage；②非流式的消息――包含TextMessage、ObjectMessage和MapMessage。我们在明白IO中流的特点后，基本可以明白JMS API设计者的意图。 IO流的分类有很多的标准，比如按照处理数据的类型不同可以分为\"字符流\"和“字节流”，按照数据流向的不同可以分为\"输入流\"和“输出流” 那“字符流”和“字节流”、\"输入流\"和\"输出流\"各自有什么区别呢？ 字符流（Byte Stream） 和 字节流（Char Stream） 因为数据编码的不同，从而有了对字符进行高效操作的流对象，其本质还是基于字节流读取的，去查了指定的码表而已。两者的区别如下表： 字节流 字符流 读写单位 以字节（8bit）为单位，一次读入或读出的是8位二进制 以字符为单位，根据码表映射字符，一次可能读多个字节，一次读入或读出是16为二进制 处理对象 能处理所有类型的数据（如图片、avi等） 只能处理字符类型的数据 设备上任何形式的资源都是以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现的，所以计算机中最小数据单元就是字节。这就意味着，字节流能处理所有的数据。 上面的比较给我们就如何选择字符流还是字节流提供了启发：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。 输出流和输入流 这两个概念就很好理解了，输出流就是往外写数据，而输入流就是从外面往里读数据。程序中往往根据传输数据的不同特性而使用不同的流，分类如下: 字符 字节 输入流 Reader InputStream 输出流 Writer OutputStream 下面是以数据处理类型为主要分类标准，以数据流向不同为次要分类标准进行的IO分类： 这样的话，好像IO还是能学的:-D。 IO目标媒介 上面我们提到了Java IO中的四个类：InputStream、OutputStream、Reader、Writer，而实际应用中，我们用到的是它们的子类。之所以设计那么多的子类，目的是让每一个类都应用于不同的媒介，实现不同的功能。这些用途总汇如下： 用途 文件访问 (Files) 网络访问 内存缓存访问 线程内部通信（管道）（Pipes） 缓冲 (Buffering) 过滤(Filtering) 解析(Parsing) 读写文件 (Readers / Writers) 读写基本类型数据 (long, int etc.) 读写对象 (Object) 上面各个类还可以按照媒介进行细分： 事实上，IO的分类标准还有一种粗粒度的分类，可以将流分成“节点流”、“处理流”和\"转换流\"。 节点流：直接与数据源相连，读入或读出。 常用的节点流有以下几种 父类 ：InputStream 、OutputStream、 Reader、 Writer 文件：FileInputStream 、 FileOutputStream 、FileReader 、FileWriter文件进行处理的节点流 数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组） 字符串 ：StringReader、 StringWriter对字符串进行处理的节点流 管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter对管道进行处理的节点流 直接使用节点流，读写不方便，为了更快地读写文件，才有处理流。 处理流：处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上就是处理流。如BufferedReader处理流的构造方法总是要带有一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为“流的链接”。 常用的处理流有以下几种： 缓冲流：BufferedInputStrean 、BufferedOutputStream、 BufferedReader、 BufferedWriter 增加缓冲功能，避免频繁读写硬盘。 转换流：InputStreamReader 、OutputStreamReader实现字节流和字符流之间的转换。 数据流： DataInputStream 、DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来。 常用的场景 由于I/O中的类是在太多了。到现在我们用到最多的场景就是读取文件，所以我们先了解一下最常见的用法吧。 BufferedReader 用法 构造方法： BufferedReader br = new BufferReader(Reader in); int read();//读取单个字符。 int read(char[] cbuf,int off,int len);//将字符读入到数组的某一部分。返回读取的字符数。达到尾部 ，返回-1。 String readLine(); //读取一个文本行。 void close(); //关闭该流。并释放与该流相关的所有资源。 使用示例： package Buffered; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class BufferedWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"Buffered.txt\"); // fw.write(\"ok168\"); // fw.close(); /** * 为了提高写入的效率，使用了字符流的缓冲区。 * 创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。 */ BufferedWriter bufw = new BufferedWriter(fw); //使用缓冲区中的方法将数据写入到缓冲区中。 bufw.write(\"hello world !\"); bufw.newLine(); bufw.newLine(); bufw.write(\"!hello world !\"); bufw.write(\"!hello world !\"); //使用缓冲区中的方法，将数据刷新到目的地文件中去。 bufw.flush(); //关闭缓冲区,同时关闭了fw流对象 bufw.close(); } } 一个自定义的BufferReader类： package Buffered; import java.io.FileReader; import java.io.IOException; public class MyBufferedReader { private FileReader fr; private char []buf = new char[1024]; private int count = 0; private int pos = 0; public MyBufferedReader(FileReader f){ this.fr = f; } public int myRead() throws IOException{ if(count == 0){ count = fr.read(buf); pos = 0; } if(count BufferedWriter 类 构造方法：bufferedWriter bf = new bufferedWriter(Writer out ); void write(char ch);//写入单个字符。 void write(char []cbuf,int off,int len)//写入字符数据的某一部分 void write(String s,int off,int len)//写入字符串的某一部分。 void newLine()//写入一个行分隔符。 void flush();//刷新该流中的缓冲。将缓冲数据写到目的文件中去。 void close();//关闭此流，再关闭前会先刷新他。 使用示例： package Buffered; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class BufferedWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"Buffered.txt\"); // fw.write(\"ok168\"); // fw.close(); /** * 为了提高写入的效率，使用了字符流的缓冲区。 * 创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。 */ BufferedWriter bufw = new BufferedWriter(fw); //使用缓冲区中的方法将数据写入到缓冲区中。 bufw.write(\"hello world !\"); bufw.newLine(); bufw.newLine(); bufw.write(\"!hello world !\"); bufw.write(\"!hello world !\"); //使用缓冲区中的方法，将数据刷新到目的地文件中去。 bufw.flush(); //关闭缓冲区,同时关闭了fw流对象 bufw.close(); } } 下面是一个使用BufferReader和BufferedWriter写的复制文本的小程序： package IOtest; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class TextCopyByBuf { /** * 首先创建读取字符数据流对象关联所要复制的文件。 * 创建缓冲区对象关联流对象。 * 从缓冲区中将字符创建并写入到要目的文件中。 * @throws IOException */ public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"C:\\\\demo.txt\"); FileWriter fw = new FileWriter(\"D:\\\\love.txt\"); BufferedReader bufr = new BufferedReader(fr); BufferedWriter bufw = new BufferedWriter(fw); //一行一行的寫。 String line = null; while((line = bufr.readLine()) != null){ bufw.write(line); bufw.newLine(); bufw.flush(); } /* 一个字节一个字节写。 int ch = 0; while((ch = bufr.read())!=-1){ bufw.write(ch); }*/ bufr.close(); bufw.close(); } } 参考 Java IO流学习总结一：输入输出流 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 15:52:36 "},"Java基础知识整理/NIO.html":{"url":"Java基础知识整理/NIO.html","title":"NIO","keywords":"","body":"NIO NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。 实际上，我们常常听到另外两个词，BIO和AIO。它们有什么区别呢？在分辨这几个概念之前，我们需要回答以下几个问题： 什么是异步和同步？ 什么是阻塞和非阻塞？ 什么是同步阻塞、什么是同步非阻塞、什么是异步非阻塞？ 同步和异步、阻塞和非阻塞 这个问题在知乎怎样理解阻塞非阻塞与同步异步的区别？这里有透彻的解释，读后豁然开朗，将内容总结如下： 有两个角色，调用者和被调用者。 同步和异步 同步和异步描述的是一种行为，它关注的是一种消息通信机制（synchronous communication/ asynchronous communication） 。 同步是指当调用者发出一个调用之后，在没有得到调用结果之前，这个调用就不返回，但是一旦返回，就得到返回结果了。也就是说，调用者一直在主动等待调用结果。 异步是指当调用者发出一个调用之后，这个调用立刻返回了，但是此时是没有返回结果的。那么这个返回结果就没有办法取得了么？不是的，得靠着被调用者通过通知、状态来通知调用者，或者通过回调函数来处理这个调用。典型的异步编程模式比如node.js。 阻塞和非阻塞 阻塞和非阻塞关系的是程序在等待调用结果（消息、返回值）时候的状态。 阻塞只指当调用结果返回之前，当前线程就会被挂起，调用线程只有在得到结果之后才会返回。（？怎么越说越想是同步呢？不一样的，好好体会一下） 非阻塞是指在不能立刻得到结果之前，该调用不会阻塞当前线程。 知乎上有一个例子讲的很明白： 老张爱喝茶，他用一个普通的茶壶烧水。 第一种方式，水在烧，老张在等，等到水烧开了再去干别的事情。我们从老张的角度看，在等待茶烧开的时间里，他自个儿什么都没有做，是“挂起”状态，这就是阻塞，并且一直在主动查询水烧开的状态，这就是同步。所以这方式是同步阻塞。 第二种方式，水在烧，但是老张并没有一直在等，他做别的事情去了，但是时不时过来看看水烧开了没有。这个过程我们可以看到，老张一直在定时轮询水/茶壶（被调用者）的状态，这就是同步，但是这段时间他做别的事情也没有耽误，所以这是非阻塞状态。所以这种方式是同步非阻塞。 第三种方式，老张买了一个会响的水壶，水一开就会响。用了这个水壶，老张仍在等待这个水开，什么都没干，可能放空状态，但是也没去主动查询结果，最后“水开了”这个讯息还是水壶告诉老张的（所以老张什么都不敢光等了，这不是傻么），所以这种方式是异步阻塞。 第四种方式，用的还是会响的水壶。老张也学聪明了，水放上去之后就干自己的事儿去了，水开了水壶就会响，中间老张是不会去查询这个水壶的状态的，这样效率就非常高了。这种方式叫做异步非阻塞。 同步异步阻塞和非阻塞组合有4种情况，其中同步阻塞和异步非阻塞都非常有道理，问题在“同步非阻塞”和“异步阻塞”有点疑惑。 首先“同步非阻塞”这个能实现呢？即不断去查询状态，但是还在做别的事情？可以的。这就是协程。 另外“异步阻塞”，这个方式就有点傻了，感觉有点浪费资源，又存在的必要么？还真的有，Java NIO就是这种存在！ BIO、NIO和AIO 上文对同步和异步、阻塞和非阻塞进行了辨析，那么BIO、NIO和AIO的具体含义就呼之欲出了： 同步阻塞IO —— BIO：即synchronous Blocking IO 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 同步非阻塞IO(Java NIO)—— NIO：即synchronous Non blocking IO 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 异步阻塞IO —— JAVA NIO 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！ 异步非阻塞IO——Java AIO（Java NIO2.0）：即Asynchronous non blocking IO 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。 Java中的AsynchronousServerSocketChannel。 Java NIO Java NIO与BIO的区别 IO NIO 面向流 面向缓冲 阻塞IO 非阻塞IO 无 选择器 面向流和面向缓冲 Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 而Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer） 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中 阻塞和非阻塞 Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。 选择器Selector Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 NIO将阻塞交给了后台线程执行 服务器模式 BIO的服务器实现模式为一个连接一个线程，NIO服务器实现模式为一个请求一个线程; Java NIO 其中有三个重要的概念：Channel、Buffer和Selector。 channel翻译为“通道”，和标准IO中的\"Stream\"是差不多一个等级的，区别在于stream是单向的，比如InputStream、OutputStream，要么只能读，要么只能写。但是Channel是双向的，既可以读又可以写。java.nio.Channels包中提供了四种类型的channle， FileChannel提供了对于文件的读写通道，我们经常使用RandowmAccesFile或FileInputStream的实例方法getChannel来获取实例。其中write和read分别用来表示读和写。 DatagramChannel是UDP的的读写通道。我们使用DatagramChannel的静态方法open来获取实例，write和read分别用来表示读和写。 SocketChannel和ServerSocketChannel是TCP的读写通道，前者的write和read方法用来读和写，后者可以监听新的SocketChannel。 需要注意的，应用程序不能和channel直接相连, 他们只能从buffer中读取数据，再写入buffer，所以他们之间的关系如下： buffer意为“缓冲区”，java.nio中定义了7种基本数据类型（除了BooleanBuffer），这些都是抽象类，真正的实现类有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等。缓冲区既可以被读，也可以被写，这两种操作的主体都是channel。实现读写的原理是buffer由四个参数控制，mark、position、limit和capacity，有很多方法来控制缓冲区的读写，比如clear就是情况缓冲区，等待写入。flip就是将写入模式转化成读取模式，compact和clear类似，但是会将一些剩余的数据复制到0-position的位置。需要注意的是，不管是clear还是compact方法，都没有将数据清除，它们只是调整了指针，下次数据再输入的时候，将会覆盖旧值。 前面说到channel必须和buffer配合使用，下面就是一个FileChannel的使用例子： public class FileChannelTest{ private String path = \"src/nio_test.txt\"; public void readFileViaNIO(){ try(RandowmAccesFile aFile = new RandowmAccesFile(path); FileChannel channel = aFile.getChannel()){ ByteBuffer buf = ByteBuffer.allocation(1024); int byteRead = channel.read(buf); while(byteRead != -1){ //将buf由写入模式转为读取模式 buf.flip(); while(buf.hasRemaining()){ System.out.print((char)buf.get() + \" \"); } buf.compact(); byteRead = channel.read(buf); } }catch(IOException e){ e.printStackTrace(); } } } 两个channel之间如何通信呢？用transferTo方法。 例如下面这个两个文件拷贝的例子： public void copyFileViaNIO(String fromPath, String toPath) thrws IOException{ File from = new File(fromPath); File to = new File(toPath); if (!form.exist()) { throw new IOException(\"from file is not exist\"); } if (to.exist()) { to.createFile(); } try(FileChannel in = new FileInputStream(from); FileChannel out = new FileInputStream(to);){ in.transferTo(0, in.size(), out); }catch(IOException e){ e.printStackTrace(); } } Selector Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。 参考 Java NIO 与 IO之间的区别 通俗编程——白话NIO之Selector NIO编程之ServerSocketChannel用法详解 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 20:26:59 "},"Java基础知识整理/路径.html":{"url":"Java基础知识整理/路径.html","title":"路径","keywords":"","body":"路径 学到File类的时候，发现搞不明白各种路径，所以专门写一篇介绍各种各样眼花缭乱的路径。 Windows和Unix/Linux中的路径 Windows下 绝对路径 平常我们说的绝对路径是指这种：C:\\Windows\\System32\\calc.exe，另外下面还要两种特殊的路径也是属于绝对路径。 UNC（Universal Naming Convention通用命名规范）路径 UNC路径用于在局域网上定位文件或文件夹，在通过网上邻居访问其它系统上的共享文件时使用的就是UNC路径。UNC路径的格式如下： \\\\PC101\\ShareFiles\\job.doc，其中PC101是目标系统的计算机名，ShareFiles是目标系统上的共享文件夹名称。 以\\\\?\\开头的路径 在某些手工辅助杀毒的工具中可以看到以\\\\?\\头的路径。完整路径和UNC路径都可以以\\\\?\\开头： \\\\?\\C:\\Windows\\System32\\calc.exe \\\\?\\UNC\\PC101\\ShareFiles\\job.doc 相对路径 这种路径需要与进程的当前文件夹（Current directory）一起合作才可以定位一个文件或文件夹。进程的当前文件夹并不是指EXE文件所在的文件夹，它是每个进程都有的一个属性。例如在命令提示符中显示的路径就是这个cmd.exe进程的当前文件夹，使用cd命令可以改变当前文件夹，无论当前文件夹如何改变，cmd.exe文件所在的文件夹总是不变的。在进程启动的时候可以指定它的当前文件夹，例如在快捷方式的属性中有一个“起始位置”输入框，这个就是进程启动后的当前文件夹。如果在启动时不指定进程的当前文件夹（直接双击EXE文件的情况），那么EXE文件的所在文件夹就会作为它的当前文件夹。纯粹的相对路径格式例如：Windows\\System32\\calc.exe，注意最前面不能有\\，否则将会变成另一种路径。 以\\开头的路径 在windows下，如果以\\开头，它就表示相对于当前文件夹根目录的路径。例如进程的当前文件夹是C:\\Windows，那么\\System32\\calc.exe就表示C:\\System32\\calc.exe。不论当前文件夹的路径有多深，只取根目录进行合并。 以盘符和冒号开头的路径 类似于C:System32\\calc.exe，乍一看，这好像是拼写错误的绝对路径。其实不是，盘符加冒号是一种特殊的表示法，表示的是进程在“该分区上的当前文件夹”。这里的\"当前文件夹\"，这与上文的\"当前文件夹\"是不同的。简单来说，对于每一个分区，进程都会保存在这个分区上最后使用的当前文件夹。 例如：运行cmd，执行cd C:\\Windows\\System32命令进入该文件夹，然后切换到其它的分区，再执行C:calc.exe命令，可以看到计算器程序启动了。 为什么？ 我们在执行cd命令进入C:\\Windows\\System32文件夹后，进程便以此为当前文件夹，当切换到其他的分区时，进程先将这个文件夹的路径保存起来，再进行切换。使用盘符和冒号的形式读取指定分区上的当前文件夹。 Unix/Linux下 路径的概念都是一样的，有几点不同。 在Unix/Linux中，路径的分隔采用正斜杠/，比如/home/fzu；而在Windows中，路径分隔采用反斜杠\\，比如D:\\tools\\eclipse。由于存在转义的问题，所以windows下的路径经常会用双反斜杠来表示，不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是\\，因此写成D:\\\\tools\\\\eclipse是不会出问题的。 linux下相对路径的表示： . 表示用户所处的当前目录； ..表示上级目录； _ 表示前一个工作目录； ~ 表示当前用户自己的根目录； ~account 表示[account]这个用户的根目录。 路径的限制 路径的写法有很多的限制： 长度限制：除了以\\\\?\\开头的路径之外，其它路径的长度都不能超过260个字符（包括结尾的\\0字符），而\\\\?\\开头的路径长度可以达到约32000个字符（系统在处理\\\\?\\前缀的时候可能将它扩展成更长的字符串）。网络上流传的一则技巧：文件路径太长而不能被删除，可以在执行del命令时在路径前加上\\\\?\\前缀。 句点： 文件或文件夹名称的最后一个字符不能为空格或句点。但在路径中，最后一个字符可以为句点(英文句点)，因为路径中的句点表示的是当期文件夹（这与上文的当前文件夹完全不同），两个句点表示的是上一级文件夹。以\\\\?\\开头的路径中不能使用句点表示当前文件夹或上一级文件夹，在资源管理器的地址栏中虽然可以这么做，那是因为资源管理器对其作了处理。 特殊字符： 文件或文件夹名称不能包含的字符 ： : \" / \\ | ? * 在路径中可以使用 : \\ ?，冒号是与盘符一起使用的，问号是\\\\?\\前缀中特有的，除此之外不能出现这两个字符；而\\是文件夹分割符。虽然我们也能使用/作为分隔符，实际上这是不允许的，系统在处理路径时会将/替换成\\。另外，如果路径最后一个字符是\\，那么该路径表示的是文件夹；否则表示的是一个文件。 UNC路径的计算机名部分不能出现以下字符：` ~ ! @ # $ % ^ & * ( ) = + _ [ ] { } \\ | ; : . ‘ “ , / ?，确实是够多的了，实际上标准的计算机名推荐只使用26个英文字母、10个数字以及-（连字符），否则可能会出现找不到计算机的情况。在更改计算机名的时候如果出现非标准字符，系统会作出提示。 参考： windows和linux下的文件路径表示小结 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:38:39 "},"Java基础知识整理/编码和编码格式.html":{"url":"Java基础知识整理/编码和编码格式.html","title":"编码和编码格式","keywords":"","body":"编码和编码格式 在刷题的时候遇到一道题https://www.nowcoder.com/profile/848042/myFollowings/detail/4037564 ，发现自己对“编码”、“编码格式”这种概念完全不清楚，什么\"Unicode\"、“UTF-8”傻傻分不清。所以特地整理了这篇文章。 首先要区分\"编码\"和\"编码格式\"。 区分概念 编码 是信息从一种形式或格式转换为另一种形式的过程。 Unicode编码 Unicode是一种编码，我们现实生活中遇到的编码基本上都是Unicode，因为它兼容了大多数老版本的编码规范，比如ASCII。 Unicode编码定义了这个世界上几乎所有字符的数字表示，也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一到的数字ID确定了这个字符，即给这串字符起了个名字，叫做\"码点\"（code point）。但是这是一个符号集合，只是规定了符号的二进制代码，但是没有规定这个二进制代码应该如何存储，所以就有了Unicode转换格式，英文名字叫做\"Unicode Transformation Formats\"，简写成\"UTF\",是不是豁然开朗！这就是我们经常看到的UTF-8 / UTF-16的前缀的来源。 UTF是为了解决【码点】在计算机中二进制表现形式而设计的。毕竟我们的机内表示涉及到存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题。 【码点】经过映射后得到的二进制串的转换格式单位称之为【码元】（code unit）。也就是说如果有一种UTF的码点二进制表示n字节，其码元为8位（1 byte），那么其拥有的码元是8位的。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UFT-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用的16位作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时湖出现这么多混乱的原因。实时上我们调用这些方法时取得的不是字符个数，而是码元个数。 一旦我们的字符串中包含了位于基于平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常有的困惑——为何return的字符数比实际字符数要多？所示实际写代码时要特别注意这个问题。 采取不同的映射方法可以得到不同格式的二进制串，但是他们背后所表示的【码点】永远是一致的，就好像你换了身份证但是身份证永远不变一样。 Unicode编码发展到今天扩展到了21位（从U+0000到U+10FFFF）。这很重要：Unicode不是16位编码，而是21位编码。这21位提供了1,114,112个码点，其中，只有大概10%正在使用，所以还有相当大的扩展空间。编码空间被分成17个平面（plane），每个平面有65535个字符（正好填充2字节，16位）。0号平面叫做【基本多文种平面】（BMP，Basic Multillgual Plane），涵盖了几乎你能遇到字符，除了emoji(emoji位于1号平面)，其他平面叫做补充平面，大多都是空的。 现在回到【编码格式】，有非常多的编码格式，下面就做个简单的总结。 编码格式 编码格式是编码的存储格式。 UTF-32 最清楚明了的应该是这个格式，它在整个码点上使用整32位，由于32>21，因此每一个UTF-32值都可以直接表示对应的码点。但是，UTF-32基本不再实际中使用，因为每个字符占用4字节太浪费空间了。 UTF-16 UTF-16要常见很多，它是根据有16位固定长度的码元（code units）定义的。UTF-16本身是一种长度可变的编码。基本多文种平面（BMP）中的每个码点都直接与一个码元相映射。鉴于BMP几乎囊括了所有常见字符，UTF-16一般只需要UTF-32一半的空间。其他平面里很少使用的码点都是用两个16位的码元来表示的，这两个合起来表示一个码点的码元叫做代理对。 UTF-8 UTF-8最大的特点是变长的编码方式，它使用1~4个字节来编码一个码点，根据不同的符号而变化字节长度。从0到127的这些码点直接映射成1个字节（对于只包含这个范围字符的文本来说，这一点使得UTF-8和ASCII完全相同，即首位为0）。接下来的1,920个码点映射成2个字节，在BMP里所有苏恒系啊的码点需要3个字节。Unicode的其他码点则需要4个字节。UTF-8是基于8位的码元的。因此并不需要关心字节的顺序（不过仍有一些程序会在UTF-8文件加上多余的BOM）。 有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。 我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如\\U112233之类的。 使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。 在Java中默认Unicode编码，无论什么语言都是一个字符占两个字节。字节码文件的编码格式是UTF-8，而虚拟机的编码格式是UTF-16。 编码格式可以理解为一种“存储方式”。 其他编码 ASCII码 这是美国在19世纪60年代的时候为了建立英文字符和二进制的关系时制定的编码规范，它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符。它用一个字节来表示具体的字符，但它只用后7位来表示字符（2^7=128），最前面的一位统一规定为0。大写字母A的编码是65，小写字母z的编码是96。 非ASCII码 GB1232是因为中文无法用ASCII来表示，至少需要两字节，还不能与ASCII冲突，所以指定了这个编码，将中文编进去。每个国家都有不同的类似于GB1232这种的编码，比如日文的Shift_JIS，韩文的Euc-kr，各国有各国的标准，所以就会出现冲突，混淆写的时候显示乱码，为了解决这个问题才有了Unicode码。 计算机系统通用的字符编码工作方式 在计算机内存中，统一使用的是Unicode编码，当需要保存到硬盘或者传输的时候，就转化为适当的编码格式，比如UTF-8。例如： 用记事本编辑的时候，从文件读取的UTF-8字符被转化为Unicode字符到内存里面，编辑完成后，保存的时候再把Unicode转化为UTF-8。过程如图所示： 浏览网页的时候，服务器会把动态生成的Unicode的内容转化为UTF-8再传输到浏览器，网页源码中头部就表示网页正是用UTF-8编码。过程如图所示： Java对字符的处理 在Java中，会涉及到字符集编码，有点地方需要进行正确的设置，有些地方需要进行一定程度的处理。 getBytes(charset) 这是Jav字符串处理的一个标准函数，其作用是将字符串表示的字符按照charset编码，并以字节方式编码。注意字符串在Java内存中总是以Unicode编码存储的。比如“中文”，正常情况下（即没有错误情况下），存储为\"4e2d 6587\"；如果charset是\"gbk\"，则被编码为\"d6d0 cec4\"，然后返回字节\"d6 d0 ce c4\"。如果charset为\"utf8\"则最后是\"e4 b8 ad e6 96 87\"。如果是\"iso8859-1\"，则由于无法编码，最后返回 \"3f 3f\"（两个问号）。 new String(charset) 这是java字符串处理的另一个标准函数，和上一个函数的作用相反，将字节数组按照charset编码进行组合识别，最后转换为unicode存储。参考上述getBytes的例子，\"gbk\" 和\"utf8\"都可以得出正确的结果\"4e2d 6587\"，但iso8859-1最后变成了\"003f 003f\"（两个问号）。因为utf8可以用来表示/编码所有字符，所以new String( str.getBytes( \"utf8\" ), \"utf8\" ) === str，即完全可逆。 setCharacterEncoding() 该函数用来设置http请求或者响应的编码。对于request，是指提交内容的编码，指定后可以通过getParameter()则直接获得正确的字符串，如果不指定，则默认使用iso8859-1编码，需要进一步处理。 参见下述\"表单输入\"。值得注意的是在执行setCharacterEncoding()之前，不能执行任何getParameter()。 java doc上说明： This method must be called prior to reading request parameters or reading input using getReader()。 该指定只对POST方法有效，对GET方法无效 。原因在于： POST方法在执行第一个getParameter()的时候，java将会按照编码分析所有的提交内容，而后续的getParameter()不再进行分析，所以setCharacterEncoding()无效。 GET方法提交表单是，提交的内容在URL中，一开始就已经按照编码分析所有的提交内容，setCharacterEncoding()自然就无效。 注意：iso-8859-1是JAVA网络传输使用的标准字符集，而gb2312是标准中文字符集,当你作出提交表单等需要网络传输的操作的时候,就需要把 iso-8859-1转换为gb2312字符集显示,否则如果按浏览器的gb2312格式来解释iso-8859-1字符集的话,由于2者不兼容,所以会 是乱码. 下面是一个例子： public static void main(String[] args) { //1. 将字符串用指定的编码集合解析成字节数组，完成Unicode - > charsetName转换 // public byte[] getBytes(String charsetName) throws UnsupportedEncodingException //2. 将字节数组以指定的编码集合构成字符串，完成charsetName - > Unicode转换 // public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException String str = \"你好\"; try { //编码 byte [] utf = str.getBytes(\"utf-8\"); byte [] gbk = str.getBytes(\"gbk\"); System.out.println(\"utf-8编码: \" + Arrays.toString(utf)); System.out.println(\"gbk编码: \" + Arrays.toString(gbk)); //解码 String s1 = new String(utf, \"utf-8\"); String s2 = new String(gbk, \"gbk\"); String s3 = new String(gbk, \"utf-8\"); String s4 = new String(utf, \"gbk\"); System.out.println(\"--------------------\"); System.out.println(\"utf-8解码：\" + s1); System.out.println(\"gbk解码：\" + s2); System.out.println(\"gbk用utf-8解码：\" + s3); System.out.println(\"utf-8用gbk解码：\" + s4); System.out.println(\"---------------------\"); System.out.println(\"用utf-8编码回去\"); s3 = new String(s3.getBytes(\"utf-8\"), \"gbk\"); // 锟斤拷锟? gbk用utf-8解码后无法编回去 System.out.println(s3); }catch (Exception e){ e.getStackTrace(); } } } 执行结果是： utf-8编码: [-28, -67, -96, -27, -91, -67] gbk编码: [-60, -29, -70, -61] -------------------- utf-8解码：你好 gbk解码：你好 gbk用utf-8解码：��� utf-8用gbk解码：浣犲ソ --------------------- 用utf-8编码回去 锟斤拷锟� 规律：utf-8编码可以用gbk和iso8859-1解码后编回去，但是gbk编码后只能用iso8859-1解码后变回去。下面是一段测试程序： public static void main(String[] args) { //1. 将字符串用指定的编码集合解析成字节数组，完成Unicode - > charsetName转换 // public byte[] getBytes(String charsetName) throws UnsupportedEncodingException //2. 将字节数组以指定的编码集合构成字符串，完成charsetName - > Unicode转换 // public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException String str = \"你好\"; try { byte [] utf = str.getBytes(\"utf-8\"); //用utf-8编码后再用gbk解码，最后能编回去 String s1 = new String(utf, \"gbk\"); System.out.println(new String(s1.getBytes(\"gbk\"), \"utf-8\")); //你好 //用utf-8编码后再用iso8859-1解码，最后能编回去 String s2 = new String(utf, \"iso8859-1\"); System.out.println(new String(s2.getBytes(\"iso8859-1\"), \"utf-8\"));// 你好 byte [] gbk = str.getBytes(\"gbk\"); //用gbk编码后再用utf-8解码，最后不能编回去 String s3 = new String(gbk, \"utf-8\"); System.out.println(new String(s3.getBytes(\"utf-8\"), \"gbk\")); //锟斤拷锟� //用gbk编码后再用iso8859-1解码，最后能编回去 String s4 = new String(gbk, \"iso8859-1\"); System.out.println(new String(s4.getBytes(\"iso8859-1\"), \"gbk\")); //你好 }catch (Exception e){ e.getStackTrace(); } } 一个问题：一个汉字在Java中存储占用多少个字节？[Java 语言中一个字符占几个字节？]答案是两个字节。因为Java语言规范规定，Java的char类型是UTF-16的code unit，也就是一定是16位（2字节）。 但是有人说了，我用new String(\"字\").getBytes(\"UTF-8\").length返回的是3，表示3字节。然后换一种编码又变了。比如下面这个程序。 public static void main(String[] args) { String str = \"我\"; try { System.out.println(str.getBytes().length); //3, 默认是utf-8 System.out.println(str.getBytes(\"UTF-8\").length); //3 System.out.println(str.getBytes(\"ISO-8859-1\").length); //1 System.out.println(str.getBytes(\"GBK\").length); //2 } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } 这个问题在Java 语言中一个字符占几个字节？有很好的回答。我们必须弄明白什么是机内码，什么是外码。 JavaEE中基础字符编码设置 对于web应用，和编码有关的设置或方法如下： JSP编译 　指定文件的存储编码，很明显，该设置应该置于文件的开头。例如：。另外，对于一般class文件，可以在编译的时候指定编码。 JSP输出 指定文件输出到browser时使用的编码，该设置也应该置于文件的开头。例如：。该设置和response.setCharacterEncoding(\"GBK\")等效。 meta设置 指定网页使用的编码，该设置对静态网页尤其有作用。因为静态网页无法采用jsp的设置，而且也无法执行response.setCharacterEncoding()。例如：。如果同时采用了jsp输出和meta设置两种编码指定方式，则jsp指定的优先。因为jsp指定的直接体现在response中。需要注意的是，apache有一个设置可以给无编码指定的网页指定编码，该指定等同于jsp的编码指定方式，所以会覆盖静态网页中的meta指定。所以有人建议关闭该设置。 form设置 当浏览器提交表单的时候，可以指定相应的编码。例如：。一般不必不使用该设置，浏览器会直接使用网页的编码。 JSP页面获取表单的值 在JSP页面获取表单的值时会出现乱码，有两种解决方法: post：在调用getParameter之前通过request.setCharacterEncoding设置字符编码。 get： 调用new String(str.getBytes(\"iso8859-1\"), \"UTF-8\");编码后解码。 系统软件中基础字符编码设置 MySql数据库 数据库的编码可以通过mysql的配置文件设置，例如default-character-set=utf8，还可以在数据库链接URL中设置，例如：useUnicode=true&characterEncoding=UTF-8，注意这两者应该保持一致。 参考： 关于JAVA字符编码：Unicode,ISO-8859-1,GBK,UTF-8编码及相互转 关于JAVA字符编码：Unicode,ISO-8859-1,GBK,UTF-8编码及相互转换 字符编码中ASCII、Unicode和UTF-8的区别 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 20:52:06 "},"Java基础知识整理/国际化.html":{"url":"Java基础知识整理/国际化.html","title":"国际化","keywords":"","body":"国际化 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-26 15:09:04 "},"Java基础知识整理/Java注解.html":{"url":"Java基础知识整理/Java注解.html","title":"Java注解","keywords":"","body":"Java注解 Java注解(Annotation)是JDK1.5引入的功能，也叫做元数据，增加代码的可读性，给谁读呢？人和机器。和类、接口、枚举在同一个层次。它可以声明在包、类、方法、局部变量、方法参数之前，用来对它们进行说明，注释。 Annotation的作用包括： 编写文档：通过代码里的元数据生成文档。【生成doc】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 Java api中注解相关的内容都在包java.lang.annotation中，其结构如下： 具体内容可以参考源码解读。 Java元注解 什么是“元注解”呢？就是那些可以用来修饰其他注释的注释，即元注解的@Target的value值一定包含ElementType.ANNOTATION_TYPE。 Java提供了四种元注解:@Documented、@Target、@Retention和@Inherited。具体的作用参考源码解读中相关内容。 下面就来学习一下如何自定义一个注解。 自定义注解并应用的过程分为下面三个过程：定义注解类、应用注解类、反射，如下图： 例如： @Documented @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotaion{ } 上面代码定义了名为MyAnnotaion的注解，注解应用于类、接口和方法，并且在整个运行期间内都存在。 接着将这个注解应用于某个类。如： @MyAnnotaion public Class AnnotationnUse{ } 我们在main方法中测试以下这个类都应用了哪些注解： package cn.gacl.annotation; @MyAnnotation //这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上 public class AnnotationUse { public static void main(String[] args) { // 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查 if (AnnotationUse.class.isAnnotationPresent(MyAnnotation.class)) { /* * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的，这个实例对象是如何创建的呢？ * 一旦在某个类上使用了@MyAnnotation，那么这个MyAnnotation类的实例对象annotation就会被创建出来了 * 假设很多人考驾照，教练在有些学员身上贴一些绿牌子、黄牌子，贴绿牌子的表示送礼送得比较多的， * 贴黄牌子的学员表示送礼送得比较少的，不贴牌子的学员表示没有送过礼的，通过这个牌子就可以标识出不同的学员 * 教官在考核时一看，哦，这个学员是有牌子的，是送过礼给他的，优先让有牌子的学员过，此时这个牌子就是一个注解 * 一个牌子就是一个注解的实例对象，实实在在存在的牌子就是一个实实在在的注解对象，把牌子拿下来(去掉注解)注解对象就不存在了 */ MyAnnotation annotation = (MyAnnotation) AnnotationUse.class .getAnnotation(MyAnnotation.class); System.out.println(annotation);// 打印MyAnnotation对象，这里输出的结果为：@cn.itcast.day2.MyAnnotation() } } } 程序执行结果是：@JavaLangJarTest.anotationTest.MyAnotation()。 注解可以看做是特殊的类，既然是类，那么就可以为类添加属性和方法。 添加属性 语法为：类型 属性名()。这个方法跟我们平常定义属性的办法不同，这种写法来看，注解更像是一种特殊的接口，注解中属性的定义和接口中方法的定义一样，而应用了注解的类可以认为是实现了这个特殊的接口。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface MyAnotation { // 定义基本属性 // @return String color(); } @MyAnotation(color = \"red\") //应用注解，并定义属性，如果定义color，编译会报错，因为属性的值是必须的，有没有办法可以不写呢？可以，指定默认值 public class AnotationUse { public static void main(String[] args) { if (AnotationUse.class.isAnnotationPresent(MyAnotation.class)){ MyAnotation annotation = (MyAnotation) AnotationUse.class.getAnnotation(MyAnotation.class); //用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法 System.out.println(annotation.color()); } } } 为属性值指定默认值 属性如果没有默认值，那么在应用注解的时候，必须指定属性的值，否则编译不通过。指定默认值的语法是:类型 属性值() default 默认值。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface MyAnotation { // 定义基本属性 // @return String color() default \"blue\"; } @MyAnotation //注解里面指定了默认值，所以这里就不用定义color了 public class AnotationUse { public static void main(String[] args) { if (AnotationUse.class.isAnnotationPresent(MyAnotation.class)){ MyAnotation annotation = (MyAnotation) AnotationUse.class.getAnnotation(MyAnotation.class); System.out.println(annotation.color()); //blue } } } value属性 如果一个注解中有一个名称为value的属性，且你只想设置value属性(即其他属性都采用默认值或者你只有一个value属性)，那么可以省略掉“value=”部分。例如：@SuppressWarnings(\"deprecation\")。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface MyAnotation { String color() default \"blue\"; String value(); } @MyAnotation(\"aaa\") //这里可以省略\"value = \" public class AnotationUse { public static void main(String[] args) { if (AnotationUse.class.isAnnotationPresent(MyAnotation.class)){ MyAnotation annotation = (MyAnotation) AnotationUse.class.getAnnotation(MyAnotation.class); System.out.println(annotation.value()); //aaa } } } 数组类型的属性 增加数组类型属性： int[] arrayAttr() default {1, 2, 3}。 应用数组类型属性：@MyAnnotation(arrayAttr = {2, 4, 5})。 如果数组属性只有一个值，这时候属性部分可以省略大括号。@MyAnnotation(arrayAttr = 2)，表示数组只有一个值，值为2。 枚举类型的属性 增加枚举类型的类型的属性：EumTrafficLamp lamp() default EnumTrafficLamp.RED. 应用枚举类型的属性：@MyAnnotation(lamp=EumTrafficLamp.GREEN) 注解类型的属性//MetaAnnotation 注解为元注解 public @interface MetaAnnotation{ String value(); //设置有一个唯一的属性value } 为注解添加一个注解类型的属性，并制定注解类型的缺省值：MetaAnnotation annotaionArttr() default @MetaAnnotation(\"xdp\")。 综合的例子参考https://www.cnblogs.com/xdp-gacl/p/3622275.html Java内建注解 Java提供了三种内建注解。 @Override 当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法。这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。源码如下： @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } @Deprecated 当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java在javadoc中推荐使用该注解，我们应该提供为什么该方法不推荐使用以及替代的方法。源码如下： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { } @SuppressWarnings 这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。它的保留策略是SOURCE（译者注：在源文件中有效）并且被编译器丢弃。源码如下： @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } 内部有一个String数组，主要接受值有： deprecation：使用了不赞成使用的类或方法时的警告； unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告; path：在类路径、源文件路径等中有不存在的路径时的警告; serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; finally：任何 finally 子句不能正常完成时的警告; all：关于以上所有情况的警告。 参考： 深入理解Java注解类型(@Annotation) Java注解教程及自定义注解 Java中三种简单注解介绍和代码实例 Java基础加强总结(一)——注解(Annotation) Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 17:42:02 "},"Java基础知识整理/哈希散列.html":{"url":"Java基础知识整理/哈希散列.html","title":"哈希散列","keywords":"","body":"哈希散列 数据类型按照物理存储方式分为四类：顺序存储、链式存储、散列存储和索引存储。 数组实现顺序存储，能实现O(1)效率的存取，但是必须要求元素连续存储。链式存储不要求连续存储，但是存取的效率是O(n)，对于索引存储，需要额外的空间来保存数据和位置之间的索引关系，存取的效率是O(1)，那么有没有一种实现既省时，又省空间呢？有，这就是散列存储。 数组本身就是一个散列表 散列，又叫做哈希，主要的思想就是根据节点的关键字能够直接计算出该节点的存储地址。这个过程叫做“散列”，而这种计算方式叫做“散列函数”，用h表示。存放记录的数组叫做散列表(Hash Table)，用HT表示。散列表中的一个位置称为一个槽（slot），散列表HT中的数目用变量M表示，槽从0到M-1标号。 散列的过程就是：根据码值，借助散列函数，计算得到槽的位置，如果产生了散列冲突（就是说计算得到的槽已经被人占了），那就要想办法解决冲突。 所以散列过程有以下三个重要的元素。 码值 码值最好能够唯一的标识一个元素。可以是数值，也可以是字符串或者其他类型。我们常常以哈希值作为码值输入，因为它的计算方式已经够复杂以至于能唯一标识一个个体了。不同的对象具有不同的哈希码的计算方法，比如String类（忘记的回去复习下），当然我们也可以自己改造，比如HashMap就是改造了hashCode方法，即内部定义了一个hash方法，其计算码值的过程是key == null ? 0 : (h = key.hashCode() ^ (h >>> 16)); 散列函数 从技术上来说，任何能把所有可能关键码值映射到散列表槽中的函数都是散列函数。下面是一些常用的散列函数 平方取中方法 对于数值类型的码值（比如哈希码），计算码值的平方，然后取中间几位，散列到相应的位置。这样做是因为码值的大多数位或者所有位对结果都有贡献。比如基数是10的四位关键码，散列到长度为100的散列表中，例如码值为4567，其平方值是4567 * 4567 = 20857489，取中间两位是57。位数等于ln100。 折叠方法 对于字符串类型的输入，计算方法是将每个字符的ASCII值累加起来，对M求模。缺点是，如果和sum比M小，就会产生较差的分布，增加了冲突的机率。 取余 .... HashMap中的散列函数关系式是(n - 1)&hash(key)，其中n是哈希表的长度。 散列方法有很多，一般都是利用除余、乘法等计算方法。但是散列有好有坏，我们用冲突率来衡量好坏。具体计算这个不多说。 理想的散列方法就是一个萝卜一个坑，一个冲突都没有，但是有些冲突是不可避免的。冲突发生之后，我们如何解决冲突。 哈希冲突 解决冲突的方法可以分为两类：开散列方法（Open hashing）和闭散列方法（Closed hashing）。 开散列方法 也叫做“单链方法”，Separate chaining，思想就是将冲突记录到表外面。 闭散列方法 也叫做“开地址方法”，Open addressing，思路就是讲冲突记录在表内的另一个空槽内。 主要的方法有：桶式散列、线性探查、二次探查、伪随机探查、双散列方法 桶式散列 思想是：将散列表的多个槽(slot)分成多个桶(bucket)，即将M个槽分成B个桶，每个桶中包含M/B个槽。 散列过程是：散列函数把每条记录分配到某个桶中的第一个槽中，如果槽已经被占用了，那么就顺序沿着桶查找，直到找到一个空槽，如果没有槽了，就放到一个无限容量的溢出桶中。 例如有一个散列表，有6个槽，分为3个桶，每个桶2个槽。即B = 3，散列函数是： int h(int i) { return i % B; } 将9 30 27 4 8按照顺序放入哈希表中，最后将会变成这样： 桶式散列的一个变体是：将码值散列到槽中，当槽满的时，再把码值散列扫同一个桶的其他槽中，如果没哟空槽，就散列到溢出桶中。 即散列函数是： int h(int i) { return i % M; } 仍旧是上面的例子，此时M = 6，同样的顺序结果为： 线性探查 比较常用，允许冲突元素记录在散列表中的任何一个空槽。思想是：如果发生了冲突，那么寻找下一个空槽，直到记录被存放。而中间经过的槽的序列叫做冲突解决策略产生的“探查序列”，这个是由“探查函数”产生的。探查函数类似如下： //@param{i} 第几次探查参数 //@param{k} 码值 int p(int k, int i) { return a * i + b; } 其中a和b是常数，注意该函数返回相对于初始位置的偏移而不是散列表的一个槽。使用的时候如下： return (h(k)+p(k, i))%M; 为了使探查列走遍所有槽，a和M必须互素。 线性探查会导致“基本聚集”这个问题。例如同样使用上面的例子，使用最基本的探查函数return i，其中M = 6， 对于顺序插入序列9 30 27 4 8，那么9的探查序列是3 4 5 0 1 2，而27也是如此，到插入的记录多了，就是大部分都聚到了一起。解决方法就是二次探测或伪随机探查。 二次探查 二次探查的探查函数如下： int p(int k, int i) { return a*i*i+b*i+c; } a、b和c都是常数。二次探查的缺点在于，在某种特定情况下，只有特定的槽能被谈查到。比如M = 3，p(k , i) = i * i。那么散列到槽0的只会探查到0和1，不会探查到2。当散列表长度为素数，以及探查函数为p(k, i) = i*i 时，至少能够访问到表中一半的槽。 如果散列表长为2的指数，并且探查函数为p(k, i) = (i*i+i)/2 ， 那么表中所有槽都能被探查序列访问到。 伪随机探查 在伪随机探查中，探查序列中的第 i 个槽是 (h(k) + ri) mod M ，ri是1 到M-1 之间的数的随机序列。 所有的插入和检索都使用相同的伪随机序列。 尽管二次探查和伪随机探查能够解决基本聚集问题，然而如果散列函数在某个基槽聚集，依然会保持聚集。这个问题称为二次聚集（secondary clustering） 解决二次聚集问题可以使用双散列方法。 双散列方法 思想就是在探查函数中再增加一个散列方法： int p(int k, int i) { return i*h2(k); } h2 是第二个散列函数 好的双散列实现方法应当保证所有探查序列常数都与表 M 长度互素。 其中一种方法是设置 M 为素数，而h2 返回 1 之间的值。 另外一种方法是给定一个 m 值，设置 M = 2^m ，然后让 h2 返回 1 到 2m 之间的一个奇数值。 装填因子 装填因子α = n / m，其中n为要散列的元素的个数，m为哈希表的长度。 不同种解决冲突的方法在解决哈希冲突是哈希表的平均查找长度如下：参考哈希表等概率情况下查找成功和查找不成功的平均查找长度的计算 一致性哈希 余数哈希的弊端 在分布式环境中，对于服务器集群，一个很重要的问题是路由算法，即我应该去找哪一台机器呢？或者在数据库分表的情况下，应该去找哪一个表呢？这种路由算法常用哈希来做。比较常见的是余数哈希。 比方说，字符串str对应的HashCode是50、服务器的数目是3，取余数得到1，str对应节点Node1，所以路由算法把str路由到Node1服务器上。由于HashCode随机性比较强，所以使用余数Hash路由算法就可以保证缓存数据在整个MemCache服务器集群中有比较均衡的分布。 这种办法在于系统无伸缩性的时候非常好办，但是一旦集群容量不够了，需要扩容的时候，问题就来了。新增的缓存将会破坏原有的哈希规则，所有的数据将需要重新计算规则，然后做数据迁移。比如MemCache服务器集群原来有3台，有20个数据，其哈希值分别是0~19。那么数据的分布就是： HashCode 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 路由到的服务器 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 如果现在机器扩容到了4台，更改服务器列表，仍然使用余数哈希，50对4的余数是2，对于Node2，但是原来str是存储在Node1上的，这就倒置了缓存没有命中。对于以上的例子，增加服务器之后的路由变成下面这样： HashCode 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 路由到的服务器 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 加粗的都是没有命中的，占了大多数，这还是简单的情况，而显示情况更加复杂。 以上例子简单地说明了使用余数Hash的路由算法，在扩容的时候会造成大量的数据无法正确命中（其实不仅仅是无法命中，那些大量的无法命中的数据还在原缓存中在被移除前占据着内存）。而缓存存在的目的就是为了缓解数据库的压力，当我们对缓存进行扩容之后，反而降低了命中率，这样不能命中的数据就会去数据库中取得，而数据库的负载能力是以有缓存为前提设计的，这样一来，数据库可能超负荷工作，造成宕机。 针对以上问题，也有办法解决，比如，我们找个访问量低谷的时候，技术人员加班加点扩容然后重启服务器。或者通过模拟请求的方式逐渐预热缓存，使缓存服务器中的数据重新分布。 但是这两种办法都不是好的解决办法，如果每次扩容都来这么一次，技术人员要累死。所以我们要改变哈希策略。 一致性哈希 为了解决分布式环境下哈希算法的伸缩性差的问题，MIT提出了分布式哈希（DHT）算法，一致性哈希就是其中一种。 CARP 一致性Hash算法通过一个叫做“一致性Hash环”的数据结构实现Key到缓存服务器的Hash映射。一致性哈希环的全量大小是2^{32}。其中分布着存储节点和key值的哈希值，范围都是[0, 2^{32} - 1]，根据节点名称的Hash值（其分布为[0, 232-1]）将缓存服务器节点放置在这个Hash环上，然后根据需要缓存的数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），然后在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。 如上如所示，三个存储Node点分别位于Hash环上的三个位置，然后Key值根据其HashCode，在Hash环上有一个固定位置，位置固定下之后，Key就会顺时针去寻找离它最近的一个Node，把数据存储在这个Node的MemCache服务器中。 现在我们来看看哈希环的可伸缩性。如果我们增加了一个节点，如下图中增加了Node4： 可以看到，Node4节点的增加，只影响到了一个Key值的数据，本来这个Key值应该是在Node1服务器上的，现在要去Node4了。 所以，采用一致性Hash算法，并不是说对集群没有影响，而是降低了影响。上图中只影响了加粗那一段的数据，相比余数Hash算法影响了远超一半的影响率，这种影响要小得多。更重要的是，集群中缓存服务器节点越多，增加节点带来的影响越小，很好理解。换句话说，随着集群规模的增大，继续命中原有缓存数据的概率会越来越大，虽然仍然有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，即使访问数据库，也不会对数据库造成致命的负载压力。 注意，当不命中的时候，回去访问数据库，然后将取得的数据写入缓存，在不断的请求之后，这部分的数据就慢慢被迁移到了新的节点中。同理，哈希环在缓存集群收缩的时候，影响也比余数哈希要小。 实现一致性哈希 知道了一致性哈希的原理，我们来看看如何实现这种机制。首先需要选取数据结构。 根据哈希环的定义，我们需要构造出一个长度为232的整数环，根据节点名称的Hash值将服务器节点放置在这个Hash环上。整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？ List + 排序 首先想到的是List+排序。算出所有待加入数据结构的节点名称的Hash值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，最后将排序后的数据放入List中，采用List而不是数组是为了结点的扩展考虑。 之后，待路由的结点，只需要在List中找到第一个Hash值比它大的服务器节点就可以了，比如服务器节点的Hash值是[0,2,4,6,8,10]，带路由的结点是7，只需要找到第一个比7大的整数，也就是8，就是我们最终需要路由过去的服务器节点。 如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度： （1）最好的情况是第一次就找到，时间复杂度为O(1) （2）最坏的情况是最后一次才找到，时间复杂度为O(N) 平均下来时间复杂度为O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为O(N)。 如果考虑排序，我们知道最好的排序是归并排序，算法复杂度是O(nlogn)。看来排序还是很耗费时间的。 List + 遍历 既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。 解决方案使用List不变，不过可以采用遍历的方式： （1）服务器节点不排序，其Hash值全部直接放入一个List中 （2）带路由的节点，算出其Hash值，由于指明了”顺时针”，因此遍历List，比待路由的节点Hash值大的算出差值并记录，比待路由节点Hash值小的忽略 （3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点 在这个算法中，看一下时间复杂度： 1、最好情况是只有一个服务器节点的Hash值大于待路由结点的Hash值，其时间复杂度是O(N)+O(1)=O(N+1)，忽略常数项，即O(N) 2、最坏情况是所有服务器节点的Hash值都大于带路由结点的Hash值，其时间复杂度是O(N)+O(N)=O(2N)，忽略首项系数，即O(N) 所以，总的时间复杂度就是O(N)。其实算法还能更改进一些：给一个位置变量X，如果新的差值比原差值小，X替换为新的位置，否则X不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为O(N)。 总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。 BST树 抛开List这种数据结构，另一种数据结构则是使用二叉查找树。 当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有AVL树、红黑树等，这里使用红黑树，选用红黑树的原因有两点： 1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高 2、JDK里面提供了红黑树的代码实现TreeMap和TreeSet 另外，以TreeMap为例，TreeMap本身提供了一个tailMap(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构。 使用红黑树，可以使得查找的时间复杂度降低为O(logN)，比上面两种解决方案，效率大大提升。 但是对于插入操作，由于需要维护红黑树，对于插入操作，TreeMap是比较慢的。 Hash值的重新计算 为什么需要重新计算哈希值？因为对于集群而言，机器的IP连续是非常常见的，如果直接应用字符串的hashCode，那么得到的哈希值是非常密集的。这样的话，大部分的key有可能会被映射到同一个node节点上。另外一个问题是，哈希环的地址区间是非负的，而String的hashCode有可能出现负数。 这种问题也有解决办法，我们干脆改变求解哈希值的算法。这种重新计算Hash值的算法有很多，比如CRC32_HASH、FNV1_32_HASH、KETAMA_HASH等，其中KETAMA_HASH是默认的MemCache推荐的一致性Hash算法，用别的Hash算法也可以，比如FNV1_32_HASH算法的计算效率就会高一些。 负载均衡 比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求。 这种问题的解决办法是引入虚拟节点。其工作原理是将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上。采取这样的方式，就可以有效地解决增加或减少节点时候的负载不均衡的问题。 那么一个节点需要虚拟多少个虚拟节点才能达到负载均衡呢？ 参考 数据结构和算法分析笔记]散列 hasing 数据结构：散列（hashing） 五分钟理解一致性哈希算法 漫画算法：什么是一致性哈希？ 经典面试题（二）之一致性哈希算法 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 11:23:58 "},"Java基础知识整理/序列化和反序列化.html":{"url":"Java基础知识整理/序列化和反序列化.html","title":"序列化和反序列化","keywords":"","body":"序列化和反序列化 为什么会有序列化和反序列化 在学习序列化和反序列化之前，我们首先要知道的一个概念是“持久化”。 “持久化”是相对于“瞬时”状态而言的，对于内存当中的数据，它们是瞬时的，JVM停止后，内存区域被回收，那么这些数据也就不复存在。而存储在文件、数据库中的数据是持久的，就算关机也不会消失。所以我们将内存中的数据写入到数据库或文件中的过程称之为“持久化”。 持久化的方式有很多，比如对象关系映射是一种典型的用关系数据库来持久化对象的方式；也存在很多直接存储对象的对象数据库；Java语言内建了一种对象对象持久化方式，很容易实现在JVM的活动对象和字节数组(byte[]，流) 之间进行转化，这种方式就是序列化。 序列化的两种应用，一是简单地实现持久化，二是在远程方法调用中，用来对开发人员屏蔽底层的实现细节。 序列化和反序列化这篇文章的前半部分介绍了序列化在通讯协议中的位置。 序列化和非序列化实现的机制 首先待序列化的类需要实现java.lang.Serializable接口。这个接口只是一个标记接口，没有任何抽象方法需要实现。 真正实现序列化的类是ObjectOutputStream和ObjectInputStream，其中ObjectOutputStream的writeObject方法可以把一个对象写入到流中，ObjectInputStream中的readObject方法可以从流中读取一个Java对象。虽然写入和读取的时候，用的参数或返回值是单个对象，但实际上操纵的是一个对象图，包括对该对象所引用的其他对象，以及这些对象所引用的另外的对象。Java会帮你遍历对象图并逐个序列化。除了对象，Java中的基本数据类型和数组也可以通过ObjectInputStream和ObjectOutputStream来序列化。下面这段代码给出了典型的Java对象序列化之后保存在磁盘上，以及从磁盘上读取的基本方式： try { User user = new User(\"Alex\", \"Cheng\"); ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"user.bin\")); output.writeObject(user); output.close(); } catch (IOException e) { e.printStackTrace(); } try { ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"user.bin\")); User user = (User) input.readObject(); System.out.println(user); } catch (Exception e) { e.printStackTrace(); } 其中User类实现了Serializable接口。 writeObject和readObject方法是序列化机制的隐含契约。 自定义对象序列化 在默认的序列化实现中，Java对象中的所有域都序列化，不管域的可见性，不管是非静态还是非瞬时。这样的话，这些域都被序列化在字节数组中，这样反序列化之后很容易分析出各种信息。 有一种解决办法是，一种解决办法是将域声明为瞬时的，即为transient关键词。 另一种做法是添加一个serialPersistentFields域来声明序列化要包含的域。例如下面只有firstName这个域是被序列化的： private static final ObjectStreamField[] serialPersistentFields = { new ObjectStreamField(\"firstName\", String.class) }; 除此之外，我们可能需要对序列化过程进行更细粒度的控制，这就需要在类中添加writeObject和对应的readObject方法。 更多的自定义序列化操作参考 http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi/ Java中的JSON处理工具 有很多成熟的JSON处理工具，常见的有阿里的fastjson，Google的Gson以及Jackson。它们封装了对Java Bean、集合、Map、日期、Enum对象的序列化和反序列化过程。 其中fastjson的效率最高。也经常使用。下一篇博文总结了使用方法。其他两个知道就好，不常用，毕竟这种都只是工具，用的时候看文档就行。 实践：JavaBean时间参数的序列化和反序列化 一个经常遇到的问题：在借助序列化工具，需要将POJO中的时间参数进行json格式化的时候将其规划话。在实践中遇到了一点麻烦，归根到底是因为将各个序列化工具的配置混为一谈，下面就来总结一下： FastJson 需要在JavaBean中时间参数字段或其set方法上加上@JSONField(format=\"yyyy-MM-dd\") Gson 需要在创建的gson的时候设定时间格式Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Jackson 网上关于jackson的时间对象序列化资料非常多，如果输入“Java json 时间 序列化”，搜到的答案基本是适用于它的，有个地方可以对gson时间格式进行设置： 配置文件中添加：spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT+8 这是工程的全局配置，时间对象在jackson进行序列化的时候被转为yyyy-MM-dd HH:mm:ss格式的字符串。 在JavaBean中时间参数上添加两个注解：@DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm\") //入参，yyyy-MM-dd HH:mm格式的字符串将转为时间类型参数 @JsonFormat(timezone = \"GMT+8\", pattern = \"yyyy-MM-dd HH:mm\") //出参，时间参数序列化时候将格式化为yyyy-MM-dd HH:mm形式 需要注意的是：JsonFormat注释于public类型属性或者get函数才有效，private属性无效，另外 @JsonFormat将会覆盖配置文件中的配置 参考 Java深度历险（十）——Java对象序列化与RMI 序列化和反序列化 Gson - Java-JSON 序列化和反序列化入门 spring boot 返回json数据日期格式化 @JsonFormat和@DateTimeFormat 实践测试 fastjson把Date类型数据转换成一长串数字 序列化和反序列化 Java的Json解析包FastJson使用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 21:06:50 "},"Java基础知识整理/泛型.html":{"url":"Java基础知识整理/泛型.html","title":"泛型","keywords":"","body":"泛型 今天在用Java实现矩阵的三元组存储的时候用到了泛型，但是发现对泛型的使用不是那么清楚，所以特此来记录一笔。 首先，泛型是基于什么样的背景提出的。看下面一段代码： public class GenericTest { public static void main(String[] args) { List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); for (int i = 0; i 如果没有规定List中存储元素的类型，可以往里面加入字符串、数字等对象，这些都是OK的，因此此时list默认的类型是Object，上面这段代码编译通过。程序运行之后，在位置1的地方会抛出java.lang.ClassCastException异常，显示的是java.lang.Integer cannot be cast to java.lang.String。这个错误只有在运行的时候才能发现，在编译的时候不容易发现。 上面的代码存在两个问题： 我们将对象放入集合，集合不会标记这个对象是什么类型，默认是Object，所以当我们取出这个元素的时候，这个元素的编译类型仍然是Object，但是运行的类型仍旧为原类型。 因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。 所以，有没有什么办法，使得集合能够记住元素的类型，在编译的时候就能发现错误，只要编译通过，运行的时候不会出现java.lang.ClassCastException异常呢？有，这个办法就是泛型。 泛型的使用 泛型，即“参数化类型”，即集合的类型能够被参数化规定。使用泛型之后，上面的例子就写成这样了： public class GenericTest { public static void main(String[] args) { List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); //list.add(100); // 1 提示编译错误 for (int i = 0; i 在定义list的时候，规定了这个List的类型是String类型，所以当尝试往里面加入数字100的时候，就会提示编译错误。而且//2处也不用进行类型转化了，因为集合已经记住了参数类型，编译器已经能够知道这些都是String类型了。 泛型是参数化类型的能力。可以在类、接口或方法中声明一个泛型类型，并在使用这个类、接口或方法时指定具体类型。 泛型类型必须是引用类型，不能用int、double或char这样的基本类型来代替，但是在使用具体方法的时候，可以使用基本类型，Java虚拟机会进行自动装箱。 那么List接口是如何定义的呢？看看源码： public interface List extends Collection { //省略一些方法定义； Iterator iterator(); T[] toArray(T[] a); boolean add(E e); boolean containsAll(Collection c); boolean addAll(Collection c); boolean addAll(int index, Collection c); boolean removeAll(Collection c); boolean retainAll(Collection c); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator listIterator(); ListIterator listIterator(int index); List subList(int fromIndex, int toIndex); } 注意其中接口、方法的一些写法。 泛型类、泛型接口和泛型方法 上面的例子已经知道泛型的基本运作过程，那么如何自定使用泛型的类、接口或方法么（比如如何定义上面ArrayList类、add方法）。 泛型类 一个简单的泛型的例子如下： public class GenericTest { public static void main(String[] args) { Box box = new Box(\"corn\"); System.out.println(box.getData()); } } class Box{ private T data; public Box() { //注意构造方法上没有 } public Box(T data){ //注意构造方法上没有 this.data = data; } public T getData(){ return this.data; } public void setData(T data){ this.data = data; } } 可以看到类声明的时候在类名后面写上，表示元素的类型是T（通常用K，P这种大写字母表示泛型类型）。注意！我们在使用泛型的时候，new Box(\"corn\");这种写法可能会让我们误会Box类的构造方法是Box( T data)，但是不是，实际上的写法是Box(T data)，没有尖括号！！！ 泛型类不能作为Java.lang.Throwable类的子类。 泛型类有多种参数的情况下，将所有参数一起放在尖括号中，用逗号分开。 还需要注意一点的是，一个泛型类是由所有实例共享的，即就算用不同的引用类型声明了不同的泛型，但是实际上这个类只加载了一次到JVM中。 看下面这个例子： public class GenericTest { public static void main(String[] args) { Box name = new Box(\"corn\"); Box age = new Box(712); System.out.println(\"name class:\" + name.getClass()); // com.qqyumidi.Box System.out.println(\"age class:\" + age.getClass()); // com.qqyumidi.Box System.out.println(name.getClass() == age.getClass()); // true } } 可以发现，在使用泛型类的时候，虽然传入了不同的泛型参数，但是并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。 为什么呢？因为泛型实际上是Java中的语法糖，Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型接口 泛型接口和泛型类的声明方式是一样的，在接口名后面加上，比如List接口的写法： public interface List extends Collection{} 可以注意到List接口实际上是实现了Collection接口，并且子类List在定义的时候也声明了泛型类型。这是其中一种定义子类的方法，具体的使用参见下面的例子： interface Info{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 } class InfoImpl implements Info{ // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } }; public class GenericsDemo24{ public static void main(String arsg[]){ Info i = null; // 声明接口对象 i = new InfoImpl(\"刘勋\") ; // 通过子类实例化对象 System.out.println(\"内容：\" + i.getVar()) ; } } 另一种是在实现子类的时候没有声明类型，例如： interface Info{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 } class InfoImpl implements Info{ // 定义泛型接口的子类 private String var ; // 定义属性 public InfoImpl(String var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(String var){ this.var = var ; } public String getVar(){ return this.var ; } }; public class GenericsDemo25{ public static void main(String arsg[]){ Info i = null; // 声明接口对象 i = new InfoImpl(\"李兴华\") ; // 通过子类实例化对象 System.out.println(\"内容：\" + i.getVar()) ; } } 这种时候，在实现接口的时候直接直接指定好具体的操作类型即可。如上面例子中声明InfoImpl接口的时候直接继承了Info接口，将类型声明为String类型。 泛型方法 泛型类和泛型接口中不可避免地要用到泛型方法，而泛型方法在声明和调用的写法上有些区别： 声明：将泛型类型至于返回值之前，比如public void max(E o1, E o2)。 调用：需要在方法名前面用尖括号内的实际类型作为前缀，比如GeneriMethodDemo.print(integers);。 下面是一个例子：public class GeneriMethodDemo { public static void main(String[] args) { Integer [] integers = {1,2,3,4,5}; String [] strings = {\"London\", \"Paris\", \"New York\", \"Austin\"}; GeneriMethodDemo.print(integers); GeneriMethodDemo.print(strings); } public static void print(E[] list) { for (int i = 0; i 注意方法声明和调用的写法。 泛型方法所在的类是否是泛型类本身是没有任何关系的。 如果返回的值是一个泛型对象，那也好办，比如E get(int index);。如果参数是一个泛型对象，上面的例子已经很多了。如果返回值是一个泛型的数组呢？注意到List接口中有一个抽象方法是： T[] toArray(T[] a); 说明确实可以返回一个“泛型数组“的。 但是，我在用Java写稀疏矩阵的三元组存储方法的时候，需要在类中定义一个泛型数组，也即是需要初始化一个”泛型数组\"，如下： T[] t = new T[length]; 编译报错。原因是泛型擦除造成的，因为数组在定义之处就要确定类型，所以不能用泛型，这个问题的具体解释见下文，以及这参考http://bbs.csdn.net/topics/370137571。 那有没有解决办法？ 目前找到的办法是： 用集合代替数组（推荐） 强制转换，即T[] t = (T[])new Object[length]，虽然编译通过，但是会隐含ClassCastException。 通过反射取得类型值，参考http://blog.sina.com.cn/s/blog_75130eaf0100vrcl.html 泛型在编译的过程中是会被擦除的： 将所有泛型参数用顶级父类类型替换 擦除所有的参数类型 为什么泛型一定要擦除？这是一个历史问题，Java在版本1.0中是不支持泛型的，这就导致了很大一批原有类库是在不支持泛型的Java版本上创建的。而到后来Java逐渐加入了泛型，为了使得原有的非泛化类库能够在泛化的客户端使用，Java开发者使用了擦除进行了折中。所以Java使用这么具有局限性的泛型实现方法就是从非泛化代码到泛化代码的一个过渡，以及不破坏原有类库的情况下，将泛型融入Java语言。 泛型擦除带来的一个问题就是我们之前说到的在类内部无法判断具体的类型，所以我们连一个基本的new都做不到，所以T[] t = new T[length];就会报错，一个补偿擦除的操作是将类型传入类中，比如： class Building {} class House extends Building {} public class ClassTypeCapture { Class kind; T t; public ClassTypeCapture(Class kind) { this.kind = kind; } public boolean f(Object arg) { return kind.isInstance(arg); } public void newT(){ t = kind.newInstance(); } public static void main(String[] args) { ClassTypeCapture ctt1 = new ClassTypeCapture(Building.class); System.out.println(ctt1.f(new Building())); System.out.println(ctt1.f(new House())); ClassTypeCapture ctt2 = new ClassTypeCapture(House.class); System.out.println(ctt2.f(new Building())); System.out.println(ctt2.f(new House())); } }/* Output: true false true *///:~ 通配符 根据泛型和擦除的原理，我们可以知道Box和Box实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box和Box是否可以看成具有父子关系的泛型类型呢？ 下面是一个测试程序： public class GenericTest { public static void main(String[] args) { Box name = new Box(99); Box age = new Box(712); getData(name); //The method getData(Box) in the type GenericTest is //not applicable for the arguments (Box) getData(age); // 1 } public static void getData(Box data){ System.out.println(\"data :\" + data.getData()); } } 运行程序，代码//1处出现了错误提示信息：The method getData(Box) in the t ype GenericTest is not applicable for the arguments (Box)。显然，通过提示信息，我们知道Box在逻辑上不能视为Box的父类。那么，原因何在呢？ public class GenericTest { public static void main(String[] args) { Box a = new Box(712); Box b = a; // 1 Box f = new Box(3.14f); b.setData(f); // 2 } public static void getData(Box data) { System.out.println(\"data :\" + data.getData()); } } class Box { private T data; public Box() { } public Box(T data) { setData(data); } public T getData() { return data; } public void setData(T data) { this.data = data; } } 这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。 假设Box在逻辑上可以视为Box的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box不能视为Box的父类。 那如果有一种情况我们必须要用这样结构，怎么解决，总不能再定义一个函数吧。这跟Java中很多的理念都是不相符的。所以为了解决类似的问题，就出现了通配符。 通配符一般用?代替具体的类型实参，注意是类型实参而不是类型形参。且Box在逻辑上是Box、Box...等所有Box的父类。上面的问题，可以用下面的代码解决： public class GenericTest { public static void main(String[] args) { Box name = new Box(\"corn\"); Box age = new Box(712); Box number = new Box(314); getData(name); getData(age); getData(number); } public static void getData(Box data) { System.out.println(\"data :\" + data.getData()); } } 如果进一步限制，getData方法只能适用于Box为数值的对象，应该怎么写？这时候就使用到了类型通配上限和类型通配下限。 public class GenericTest{ public static void main(String [] args){ Box name = new Box(\"corn\"); Box age = new Box(712); Box number= new Box(314); getData(name);//编译错误 getData(age); getData(number); } public static void getData(Box data){ System.out.println(\"data : \" + data.getData()); } } 三种通配符的描述见下表： 写法 类型 描述 ? 非受通配符 等同于? extends Object ? extends T 受限通配符上限 表示T或T的一个未知子类 ? Super T 受限通配符下限 表示T或T的一个未知父类 泛型嵌套 泛型比较复杂的使用就是泛型嵌套。比如下面的例子： class Info{ // 接收两个泛型类型 private T var ; private V value ; public Info(T var,V value){ this.setVar(var) ; this.setValue(value) ; } public void setVar(T var){ this.var = var ; } public void setValue(V value){ this.value = value ; } public T getVar(){ return this.var ; } public V getValue(){ return this.value ; } } class Demo{ private S info ; public Demo(S info){ this.setInfo(info) ; } public void setInfo(S info){ this.info = info ; } public S getInfo(){ return this.info ; } } public class GenericsDemo31{ public static void main(String args[]){ Demo> d = null ; // 将Info作为Demo的泛型类型 Info i = null ; // Info指定两个泛型类型 i = new Info(\"刘勋\",20) ; // 实例化Info对象 d = new Demo>(i) ; // 在Demo类中设置Info类的对象 System.out.println(\"内容一：\" + d.getInfo().getVar()) ; System.out.println(\"内容二：\" + d.getInfo().getValue()) ; } } 泛型擦除和反射 泛型在编译的时候被擦除，也就是说List和List在运行的时候是一样的，按理说我们如果使用反射方法getType来获取类型，只能得到List类型，但是实际上，为了获取和泛型相关的信息，Java增加了几种类型来代表不能被归类到Class类中的类型，但又和基本数据类型齐名的类型，通常有以下两个： GenericType: 表示一种元素类型是参数话的类型或者类型变量的数组类型。 ParameterizedType：表示一种参数化的类型。 引入这两种类型的原因就是因为反射中getType只能获取基本类型，不能获取范型类型。看下面这个例子： class Student{ private Map score; } public class ReflectTest{ public static void main(String[] args) throws Exception{ Class clazz = Student.class; Filed f = clazz.getDeclaredFiled(\"score\"); //通过getType方法只能获取到普通类型 System.out.println(\"score的类型是: \" + f.getType()); //打印Map //1. 获取f的泛型类型 Type gType = f.getGenericType(); //2. 如果gType是泛型类型对象 if (gType instanceof ParameterizedType) { ParameterizedType pType = (ParameterizedType)gType; //获取原始类型 Type rType = gType.getRowType() System.out.println(\"原始类型是：\" + rType); //获得泛型类型的泛型参数 Type[] gArgs = pType.getActualTypeArguments(); //打印泛型参数 for (int i = 0; i 执行结果是： score的类型是：interface java.util.Map 原始类型是: interface java.util.Map 第0个泛型类型是：class java.lang.String 第1个泛型类型是：class java.lang.Integer 可以看到，通过反射还是能够获取泛型信息的。但是这就奇怪了，不是说泛型信息都擦除了么，它是怎么获取到泛信息的呢？ 这一点我并没有找到确切的答案，在https://www.cnblogs.com/doucheyard/p/6855823.html 这篇博文中，对以上问题这样解释： Java在编译时会校验泛型参数，生成时会以泛型实参的上限类型替代真实的泛型实参。但，Java虚拟机会以签名的形式保留这些泛型实参类型(包括类的定义、泛型方法、泛型字段都会保留参数的签名信息) 参考 JAVA反射学习之——深入研究(反射与泛型) 泛型的理解及应用（一）：泛型擦除 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-16 14:57:02 "},"Java基础知识整理/空间初始化和增长策略.html":{"url":"Java基础知识整理/空间初始化和增长策略.html","title":"空间初始化和增长策略","keywords":"","body":"空间初始化和增长策略 String StringBuilder和StringBuffer 默认初始化长度为16，如果使用字符串创建对象，则初始长度为字符长度+2，空间增长为2x + 2，其中x为旧空间大小。空间最大值为Integer.MAX_VALUE。 ArrayList 对象数组，默认初始化大小是10。空间增长策略为原来的1.5倍，但是实际上这个值是否被应用还得取决于新容量大小是不是超过可允许的最大值。ArrayList约定的最大容量是Integer.MAX_VALUE - 8，实际上能达到的最大空间是Integer.MAX_VALUE。 PriorityQueue 对象数组，默认初始化大小为11，默认初始化比较器为null，扩容时，当此时容量较小（小于64），则容量增加2倍；当容量较大，则容量增加1倍后再加上2。 HashSet 默认初始化大小为16，默认装载因子为0.75。如果以集合来初始化，则初始化大小为集合大小的4/3倍与16之间的较大值。 LinkedHashSet 默认初始化大小为16，默认装载因子为0.75。如果以集合来初始化，则初始化大小为集合大小的2倍与11之间的较大值。 HashMap 初始默认大小为16，初始默认负载因子为0.75。每次扩容空间增长2倍。空间最大容量为2^{30}。 Hashtable 初始化默认大小为1，初始默认负载因子为0.75。每次扩容空间增长为原来的2倍加1，空间最大容量为Integer.MAX_VALUE - 8。 CharArrayReader 字符数组，默认初始化大小为32。写入时，如果空间不足情况下，在2倍的当前空间大小和所需总空间大小中取较大值。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-22 15:25:11 "},"Java基础知识整理/Java中的语法糖.html":{"url":"Java基础知识整理/Java中的语法糖.html","title":"Java中的语法糖","keywords":"","body":"语法糖 什么是语法糖？ 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 Java中包括但是不限于以下10颗语法糖：泛型与类型擦除、自动装箱和拆箱、遍历循环、变长参数、条件编译、内部类、枚举类、断言语句、对枚举和字符串的switch支持、在try语句中定义和关闭资源。 泛型与类型擦除 泛型出现的目的是为了在编译期间就能发现一些错误，而不是等待运行时候。泛型值存在源码中，也就是在编译器检查正确完之后，会将相关的泛型类型擦除，即在编译后的字节码中，已经被替换为原来的原生类型了，并且在相应的地方插入了强制转换代码。 而对于运行期间的Java来说， ArrayList和ArrayList就是同一个类。所以说泛型技术实际上就是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 自动装箱与拆箱 从JDK 1.5开始，Integer i = 1;和int j = i;这种写法能够正确编译和运行，其背后的原理就是所谓的自动装箱和自动拆箱。每个包装类都有对应的自动装箱方法valueOf方法和自动拆箱方法xxxValue方法。其中valueOf方法还存在缓存的设计，比如整型数值类型的缓存范围是-128, 127，boolean直接将True和False作为静态常量，Character的缓存范围是[0, 127]。具体的细节可以参见另一篇博文《数值包装类型》。 遍历循环 foreach循环是在JDK1.5被加入的，其本质是因为1.5开始加入了Iterable接口。一个类如果要支持foreach接口，就必须实现Iterable接口。foreach虽然不能完全代替for循环，但是在数组遍历、集合遍历方法给开发人员带来了极大的遍历。具体细节可以参见【源码解读】中的Iterable类。 变长参数 条件编译 内部类 枚举类 断言语句 对枚举和字符串的switch支持 在try语句中定义和关闭资源 参考： Java中的10颗语法糖 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-03 10:36:06 "},"Java基础知识整理/Java中的引用类型.html":{"url":"Java基础知识整理/Java中的引用类型.html","title":"Java中的引用类型","keywords":"","body":"Java中的引用类型 有四种引用，强引用、软引用、弱引用和虚引用。 这么多引用类型的目的，第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。 强引用 是指创建一个对象并把这个对象赋给一个引用变量。这是我们代码中普遍存在的，比如 Object object =new Object(); String str =\"hello\"; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。 但是要注意对象的生存周期，比如： public static void main(String[] args) { new Main().fun1(); } public void fun1() { Object object = new Object(); Object[] objArr = new Object[1000]; } 这段代码中，当fun1结束的时候，object和objArr都会被GC。 想要中断强引用，方法是将强引用赋值为null。这样一来的话，JVM就可以回收该对象。 软引用(SoftReference) 软引用对象回收与否完全要看内存的脸色。如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可用来实现内存敏感的高速缓存，比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。 SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。 也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。 随即，我们可以结束aReference对这个MyObject实例的强引用: aRef = null; 这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。 Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待：软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。 也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: MyObject anotherRef=(MyObject)aSoftRef.get(); 弱引用(WeakReference) 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。 public static void main(String[] args) { WeakReferencereference=new WeakReference(new People(\"zhouqian\",20)); System.out.println(reference.get()); System.gc();//通知GVM回收资源 System.out.println(reference.get()); } } class People{ public String name; public int age; public People(String name,int age) { this.name=name; this.age=age; } @Override public String toString() { return \"[name:\"+name+\",age:\"+age+\"]\"; } } 以上代码的输出结果是： [name:zhouqian,age:20] null 第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。上面的代码做出一点变动： public class test { public static void main(String[] args) { People people=new People(\"zhouqian\",20); WeakReferencereference=new WeakReference(people);//关联强引用 System.out.println(reference.get()); System.gc(); System.out.println(reference.get()); } } class People{ public String name; public int age; public People(String name,int age) { this.name=name; this.age=age; } @Override public String toString() { return \"[name:\"+name+\",age:\"+age+\"]\"; } }//结果发生了很大的变化 运行结果将是： [name:zhouqian,age:20] [name:zhouqian,age:20] 虚引用(PhantomReference) 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 public class Main { public static void main(String[] args) { ReferenceQueue queue = new ReferenceQueue(); PhantomReference pr = new PhantomReference(new String(\"hello\"), queue); System.out.println(pr.get()); } } 参考 Java对象的四种引用类型 Java的四种引用方式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 21:44:48 "},"JVM/运行时内存区域.html":{"url":"JVM/运行时内存区域.html","title":"运行时内存区域","keywords":"","body":"运行时内存区域 运行时内存区域划分 我们将Java虚拟机划分的内存区域叫做“运行时的数据区域”。 根据《Java虚拟机规范（Java SE 7版）规定》规定，Java虚拟机所管理的内存包括以下几个运行时候数据区域： 程序计数器【线程私有】 较小的一块内存，可以看做是 当前线程 所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程回复等基础功能。 每条线程都需要一个程序计数器，各条线程之后的计数器互不影响，独立存储。所以，线程计数器是 线程私有的。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码地址；如果正在执行的是Native方法，这个计数器则为空。 程序计数器没有规定任何OutOfMemoryError情况。 Java虚拟机栈【线程私有】 Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个 栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。 局部变量表: 存放 编译期可知的各种基本数据类型[boolean|byte|char|short|int|float|long|double]、对象引用(reference类型)和returnAddress类型（执行一条字节码指令的地址）。 局部变量表所需要的内存空间在 编译期 完成分配，当进入一个方法时，这个方法在帧中分配多大的局部变量空间是确定的，在方法的运行期间不改变局部变量表的大小。 该区域规定了两种异常情况： 线程请求的栈深度大于虚拟机所允许的深度->抛出StackOverflowError异常。 扩展时无法申请到足够的内存->抛出OutOfMemoryError异常。 本地方法栈 【线程私有】 与Java虚拟机栈相似，只是Java虚拟机栈为java方法（字节码）服务，而本地方法栈为Native方法服务。 会抛出StackOverflowError异常和OutOfMemoryError异常。 Java堆 【线程共享】 \"The heap is the runtime data area from which memory for allclass instancesadn arrays is allocated\" \"所有的对象实例以及数组都要在堆上分配\"——Java虚拟机规范 是Java虚拟机所管理的内存中最大的一块，负责存放几乎所有的对象实例。 是垃圾收集器管理的主要区域，因此也被称为\"GC堆\"。 Java堆可以处于物理上不连续的空间，逻辑上是连续的。 会抛出OutOfMemoryError异常。 方法区 【线程共享】 Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是为了区分两者，方法区还要一个名字叫“No-Heap”(非堆)。 用来存储已经被虚拟机加载的类信息、常量、静态变量（JDK7中被移入到了Java堆中）、即时编译器编译后的代码等数据。由于这些数据一般都是不变的，所以方法区也被称为“永久代”。 其中一个重要的部分是： 运行时常量池。Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内存将在类加载后进入方法区的运行出事常量池中存放。 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，即并非置如Class文件中常量池的内容才能进入方法去运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是String类的intern()方法。 会抛出OutOfMemoryError异常。 方法区中很重要的一部分就是常量池，用于存放编译时期生成的各种字面量和符号引用（其实就是八大基本类型的包装类和String类型数据），其中非常重要的一点是，JDK7将字符串常量池移入到Java堆中。 从JDK7开始永久代的移除工作，贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。随着JDK8的到来，JVM不再有PermGen。但类的元数据信息（metadata）还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中。 直接内存* 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分被频繁使用，也会出现OutOfMemoryError异常。 JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以利用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。 该区域的内存大小会收到本机总内存基于处理器寻址空间的限制，导致动态扩展时出现OutOfMemoryError异常。 举个例子来说，对于语句Object obj = new Object()来说，假设这句话出现在了方法体中，那么Object obj这部分将会反映到Java栈的本地变量表中，作为一个reference变量数据出现，而new Object()将会反映到Java堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 注意，reference类型在Java中只是一个指向对象的引用，至于如何定位、以及访问到Java堆中的对象的具体位置，不同的Java虚拟机的实现方式是不同的。这就是下面的内容——对象的访问定位。 对象的访问定位 对象存储在堆区域，Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference是指向对象的引用，但是没有定义这个引用应该通过何种方式去定位、访问堆中对象的具体位置，由虚拟机决定。现在主流的方式由以下两种： 句柄访问 在堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据和类型数据各自的具体地址信息。如下图所示： 该方式的优势在于，reference中保存的是稳定的句柄地址。 直接指针访问 reference中存储的直接就是对象地址，Java堆对象的布局必须要考虑如何访问类型数据的相关信息。如下图所示： 该方法的优势在于，访问更快，节省了一次指针定位的时间开销。 参考 深入理解JVM—JVM内存模型 JVM内存结构 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 15:51:40 "},"JVM/内存模型、指令重排和内存屏障.html":{"url":"JVM/内存模型、指令重排和内存屏障.html","title":"内存模型、指令重排和内存屏障","keywords":"","body":"内存模型、指令重排和内存屏障 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 15:52:18 "},"JVM/内存泄漏和垃圾回收.html":{"url":"JVM/内存泄漏和垃圾回收.html","title":"内存泄漏和垃圾回收","keywords":"","body":"内存泄漏和垃圾回收 JVM共享内存区域划分 上一篇了解了Java虚拟机运行时内存的划分情况：大致分为程序计数器、JVM栈、本地方方法栈、方法区和Java堆。其中最后两者是线程共享的。又可以具体细分，所以JVM共享内存可以划分为如下图所示的内存分布模型： 大体上分为三个区域： 新生代（Young Generation）：存在于Java堆区域。\"新生\"就是刚刚创建的意思，所以对象刚刚被创建的时候，内存首先在新生代进行分配，但是并非全都如此，大对象可以在老年代直接进行分配。新生代又可以划分为以下两个个区域： Eden区：大部分的对象都是在这个区域生成的。当该区域满的时候，就将这个区域中还存活的对象复制到另外一个Survivor区，当这个Survivor区满的时候，就将该区域中还存活的对象复制到另外一个Survivor，如果这个区域也满了，那么从前一个Survivor区域复制过来并且还存活的对象将可能被赋值到老年区。 Survivor区域：存货区，一共有两个，也称为S0和S1，是对称的，没有先后关系，所以同一个Survivor区域中可能同时存在从Eden区域复制过来的对象，和从另一个Survivor区复制过来的对象那个，而复制到老年区的只有从另一个Survivor区过来的独享。而且，因为需要交换的原因，Survivor区域至少有一个是空的。 特殊情况下，根据程序需要，Survivor可以配置多个，至少2个，这样就可以增加对象存在于新生代的时间，减少被放到老年代的可能。 针对新生代的垃圾回收叫做Young GC，也叫做Minor GC。 老年代（Old Generation）：存在于Java堆区域。在新生代中经历了N次（可配置）垃圾回收之后仍旧存活的对象，将被复制到这个区域。因此这个区域存放的对象都是一些生命周期很长的对象。针对老年代的垃圾回收叫做Full GC。能够触发Full GC的操作有（这个知识点参考full GC触发的条件可能有哪些： 旧生代空间不足 旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 Permanet Generation空间满 PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。 CMS GC时出现promotion failed和concurrent mode failure 对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。 promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间 这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。 直接调用System.gc 持久代（Permanent Generation）：就是我们之前所说的方法区，用于存放静态类型变量。如果持久代满了，将会触发Full GC。 所以根据上面的接受，当一组对象生成的时候，内存申请过程如下： JVM试图为相关的JAVA对象在新生代的Eden区域初始化一块内存区域。 当Eden区域的空间足够时，内存申请结束，否则进行下一步。 JVM试图释放Eden区中的所有不活跃对象，此时触发Young GC。如果释放后Eden区仍旧内存不足，那么JVM视图将部分的Eden区中的活跃对象复制到Survivor区。 Survivor区被用来作为Eden区和老年代的中建交换区域。当老年代空间足够时，Survivor将存活了一定次数的对象移到老年代。 当老年代空间不足的时候，会触发Full GC。 Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”，即OOM。OOM和StackOverFlow会在下一篇博客中讲到。 注意“内存泄漏”和“内存溢出”是不同的概念，前者是因为有很多资源没有释放，导致了很多内存黑洞，而后者是因为空间不够用了。当然，前者也是造成后者的一种原因。 垃圾回收机制 上文说到GC的概念，即垃圾回收，那么我们需要关注三个重要的问题： 如何确定某个对象是垃圾？ 有哪些垃圾收集算法？ 有哪些垃圾收集器？ 如何确定某个对象是垃圾？ 垃圾回收的是垃圾对象，那总得有一个评判标准，才能说明为何一个对象是垃圾，另一个对象为什么不是垃圾。一般有两类评判标准： 引用计数 Java是通用引用来访问对象的，当没有任何引用指向某一个对象的时候，说明这个对象就没用了，是垃圾对象，可以被回收了。所以自然而然可以想到这种办法：通过一个计数器来记录指向某个对象的引用个数，当这个计数器的计数变为0，那么这个对象就可以被回收了。这种方法叫做“引用计数收集法”。 我们在程序中常常将某个不用的对象置为null，以帮助GC程序回收垃圾，这种做法是对的。对于Java语言而言，引用计数收集法无法解决循环引用的问题，例如下面这段代码： public class Main { public static void main(String[] args) { MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; } } class MyObject{ public Object object = null; } main方法的最后两句分别将object1和object2赋值为null，即这两个指向的对象都不再被访问了，但是它们之间相互引用，导致计数不为0，那么垃圾收集器将永远不能回收它们。所以Java不使用这收集方法，而python却在使用这种方法。 可达性分析 Java中采取的是可达性分析方法，思路是这样的：通过一系列的\"GC Roots\"对象作为起点进行搜索，如果\"GC Roots\"和一个对象之间没有可达路径，那么这个对象就是不可达的。但是需要注意，不可能并不等于是可回收垃圾，还需要经过至少两次的判断，如果几次的搜索都判断这个对象是不可达的，那么这个对象就真的是垃圾了，要被回收的。 那么哪些对象能够作为GC Root呢？ 在Java语言中，可以作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。 典型的垃圾收集算法 在分清楚哪些对象是垃圾回收对象之后，垃圾回收器要做的就是进行垃圾回收了。有人要问了，都确定哪些是垃圾了，回收不就完了，为什么还有算法？话是这样讲没错，我们的算法的目的不仅仅是回收垃圾，还要是高效地回收垃圾。JVM并没有对垃圾收集器作出明确的规定，因此JVM厂商可以采取不同的办法进行垃圾回收。下面就是集中常见的垃圾垃圾回收算法的核心思想。 Mark-Sweep（标记-清除）算法 最简单的算法，分为标记和清除两个阶段。标记阶段就是标记出所有要被回收的对象，这个评判标准呢就是我们之前说到的可达性分析，清除阶段就是释放内存呗。这没什么好说的。但是它会产生一个严重的问题，那就是内存空间将被释放地“千疮百孔”，造成“内存碎片”，带来的后果是可能导致后序过程中大对象的空间分配遇到困难，从而触发新一轮的垃圾收集动作。 Copying（复制）方法 Coping方法解决标记-清除算法造成的内存碎片的问题。它将内存按照容量分为了大小相等的两块，每次只是用一块。如果其中一块用完，就将其中存活的对象复制出来到另一块上面，然后把之前的一块的内存全部清除。 碎片问题是解决了，但是这个方法将导致每次只能是用内存的一半空间，很是浪费。当然，这也跟存活对象的数目有很大关系，如果每次都存活很多，那么这种算法的效率是非常低的。 Mark-Compact（标记-整理）算法 这个方法就是将前两个算法结合起来了，分为标记和整理两个阶段。标记阶段不变，但是整理阶段，不是直接清理可回收对象，而是将存活对象都向内存的一端移动，然后清除掉边界以外的内存，这部分内存中存储的都是垃圾对象。 Generational Collection(分代收集)算法 这是目前最主流的垃圾收集算法。核心思想是按照对象存活的生命周期将内存划分为若干个不同的空间。比如堆区划分为老年代和新生代，前者每次只有少量的对象被回收，后者有大量的对象回收。根据它们的特点再指定相应的回收算法。 目前新生代采取的是Copying算法，因为每次都有大量的垃圾对象被回收，即赋值的操作次数比较少，但是不同于上面1:1的比例划分，我们划分为1个较大空间的Eden空间和2个较小空间的Survivor空间。每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。 目前老年代采取的是Mark-Compact算法，因为每次只回收少量的对象。 另外还需要注意的是持久代，对这部分的回收主要有两个部分：废弃常量和无用的类。 典型的垃圾收集器 算法的基础也有了，下面就要造出各种工具来进行实现了。这种工具就是垃圾回收器。下面介绍7种HotSopt（JDK 7）JVM提供的垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。 注意：各个垃圾收集器出现的时间为： Serial(1.3)、 ParNew(1.4)、Parallel Scavenge(1.4)、CMS(1.5)、Serial Old(1.5)、Parallel Old(1.6)、G1(1.7)，其中G1已经商用。 这些垃圾收集器又可以分为四大类： 串行垃圾收集器 串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序。 通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。 典型的串行垃圾收集器有以下两种： Serial收集器（新生代——串行GC） 最基本、最悠久的收集器，他是一个单线程的收集器，而单线程是指当他在进行垃圾收集的时候，必须暂停其他所有的工作线程，被称为”Stop The World”。 优点：简单而高效（与其他收集器的单线程相比），在限于单个CPU的环境，没有额外的线程交互的开销，所以能获得最高效率。 适用：运行在Client模式下的虚拟机。 Serial Old收集器（老年代——串行GC） Serial Old是Serial收集器的年老代版本，同样是一个单线程收集器，使用”标记-整理”算法。 适用：Client模式下虚拟机使用；在Server模式有两大用途：与Parallel Scavenge收集器搭配使用，作为CMS收集器的后备预案。 并行垃圾收集器 并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，它也会冻结所有的应用程序线程当执行垃圾回收的时候。 典型的并行垃圾收集器有以下三种： ParNew收集器（新生代 – 并行GC） ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余的和Serial所有控制参数一样。在配置为CMS GC的情况下默认的新生代收集器，可以用-XX:+UseParNewGC强制指定。 优点：在多CPU的环境下可以发挥更高而效率，并且是唯一一个可以和CMS收集器搭配工作的新生代并行GC。 适用：运行在server模式下的虚拟机首选的新生代收集器。 Parallel Scavenge收集器（新生代 – 并行GC） 看上去和ParNew没什么区别，但是Parallel Scavenge最大的特点就是他的关注点在于CPU的吞吐量，吞吐量=运行代码时间/（运行代码时间+垃圾收集时间）。较高的吞吐量可以最好的利用CPU的效率。-XX:MaxGCPauseMillis配置最大垃圾收集停顿时间，-XX:GCTimeRatio配置吞吐量大小。 优点：被称为”吞吐量优先”收集器，有一个自适应调节参数（-XX:+UseAdaptiveSizePolicy），当这个参数打开后，无需手动指定新生代大小（-Xmn）、Eden和Survivor比例（-XX:SurvivorRatio）、晋升老年代年龄限制（-XX:PretenureSizeThreshold）等细节参数，虚拟机会动态调节这些参数来提供最适合的停顿时间或最大吞吐量。 适用：本身是Server级别多CPU机器上的默认GC方式，也可以通过-XX:+UseParallelGC来指定，并且可以采用-XX:ParallelGCThread来指定线程数。 Parallel Old收集器（老年代 – 并行GC） Parallel Old是Parallel Scavenge收集器的老年代版本，为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合。 适用：在注重吞吐量以及CPU资源敏感的场合采用。 并发标记扫描垃圾回收器 并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。 当标记的引用对象在tenured区域； 在进行垃圾回收的时候，堆内存的数据被并发的改变。 相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。 通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。 典型的并发垃圾收集器是CMS收集器： CMS收集器（老年代 – 并发GC） CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于”标记-清除”算法，整个过程分为4个步骤：初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）和并发清除（CMS concurrent sweep）。 其中初始标记、重新标记仍然是”Stop The World”，初始标记仅仅是标记一下GC Roots能直接关联的对象，并发标记进行GC Roots Tracing的过程，重新标记为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那部分对象，这个阶段停顿时间比初始标记阶段稍长一些，但比并发标记时间短。 优点：并发收集、低停顿。 适用：重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。 G1垃圾回收器 G1垃圾回收器适用于堆内存很大的情况，它将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域 通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器。 G1（Garbage First）收集器是当前收集器技术最前沿成果，与之前的CMS相比有两个显著改进：基于”标记-整理”算法实现收集器和精确控制停顿。能够在基本不牺牲吞吐量的前提下完成低停顿的内存回收。 新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。 这四种类型的垃圾收集器可以用下面这张图来概括： 这些垃圾回收器可以相互组合： 默认的GC组合是： 可选择的GC组合： 默认的垃圾收集器又是什么呢？这个问题既简单又复杂。如果你运行在JVM的客户端模式（Client）下，JVM默认垃圾收集器是串行垃圾收集器（Serial GC，-XX:+USeSerialGC）；在JVM服务器模式（Server）下默认垃圾收集器是并行垃圾收集器（Parallel GC，-XX:+UseParallelGC）。至于是运行在JVM的客户端模式还是服务器模式，取决于下面情况： 如何查看JVM当前的GC情况？ // 方法1 打印虚拟机所有参数 // 第3列如果是=表明使用的是JVM默认值，如果是:=表明是用户指定 [root@localhost ~]# java -XX:+PrintFlagsFinal -version | grep : uintx InitialHeapSize := 258689024 {product} uintx MaxHeapSize := 4139778048 {product} bool PrintFlagsFinal := true {product} bool UseCompressedOops := true {lp64_product} bool UseParallelGC := true {product} // 方法2 ➜ Java-learning git:(master) ✗ java -XX:+PrintCommandLineFlags -version -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version \"1.8.0_141\" Java(TM) SE Runtime Environment (build 1.8.0_141-b15) Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode) // 方法3 import java.lang.management.GarbageCollectorMXBean; import java.lang.management.ManagementFactory; import java.util.List; public class x { public static void main(String args[]) { List l = ManagementFactory.getGarbageCollectorMXBeans(); for(GarbageCollectorMXBean b : l) { System.out.println(b.getName()); } } } // 输出 [root@localhost ~]# java x PS Scavenge PS MarkSweep 参考 JVM 堆内存设置原理 JVM内存堆布局图解分析 JVM内存管理及GC机制 Java GC系列（3）：垃圾回收器种类 深入JVM读书笔记（四）——Java的垃圾收集器 以下哪些jvm的垃圾回收方式采用的是复制算法回收 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 10:28:59 "},"JVM/内存溢出和参数调优.html":{"url":"JVM/内存溢出和参数调优.html","title":"内存溢出和参数调优","keywords":"","body":"内存溢出和参数调优 参数调优 在讲解内存溢出和测试程序之前，先学习下各数据区域内存大小的参数设置。 栈(Java虚拟机栈和本地方法栈): -Xss128k Java堆：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError， 其中-XX参数可以让虚拟机在出现内存溢出时Dump出当前内存堆转储快照以便事后进行分析。 方法区和运行时常量池:-XX:PermSize=10M -XX:MaxPermSize=10M。 常量池被分配到永久代中，通过上面两个参数，限制方法去的大小，从而间接限制其中常量池的容量。 直接内存:-XX: MaxDirectMemorySize=10m 如果不设定，则默认与Java堆最大值(-Xmx)一致。 各个内存区域的参数设置参见这张图 －Xms：设置java应用程序启动时的初始堆大小 －Xmx：设置java应用程序能获得的最大堆大小 －Xss：设置线程栈的大小 －XX:MinHeapFreeRatio:设置堆空间的最小空间比例。当堆空间的空闲内存小于这个数值时，jvm便会扩展堆空间。 －XX:MaxHeapFreeRatio:设置堆空间的最大空间比例。当堆空间的空闲内存大于这个数值时，jvm便会缩小堆空间。 -XX:NewSize : 设置新生代的最小空间 -XX:MaxNewSize: 设置新生代最大空间 -XX:NewRatio:设置老年代与新生代的比例，即老年代除以新生代大小 -XX:SurviorRatio:新生代中eden区与survivior 区的比例 －XX：PermSize:设置永久区的大小 －XX：TargetSurvivorRatio:设置survivior 的使用率。当达到这个空间使用率时，会将对象送入老年代。 ”内存溢出”的通俗理解就是”内存空间不够”。以发生内存溢出时，Java虚拟机抛出的异常的类型来划分，可以大致分为StackOverFlow和OutOfMemory两种类型。 JVM性能调优2：JVM性能调优参数整理 内存溢出 StackOverFlow 这种异常会出现在Java虚拟机栈溢出和本地方法栈溢出时。 栈溢出抛出StackOverflowError错误，出现此种情况是因为方法运行的时候栈的深度超过了虚拟机容许的最大深度所致。 出现这种情况，一般情况下是程序错误所致的，比如写了一个死递归，就有可能造成此种情况。 下面我们通过一段代码来模拟一下此种情况的内存溢出。 /** * VM Argus: -Xss128k */ public class JVMStackSOF { private int stackLength = 1; public void stackLeak(){ stackLength ++; stackLeak(); } public static void main(String[] args) { JVMStackSOF oom = new JVMStackSOF(); try { oom.stackLeak(); }catch (Throwable e){ System.out.println(\"stack length: \" + oom.stackLength); throw e; } } } 结果如下： objc[29963]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/bin/java (0x10db174c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10dbf34e0). One of the two will be used. Which one is undefined. Exception in thread \"main\" java.lang.StackOverflowError at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) at outOfMemoryDemo.JVMStackSOF.stackLeak(JVMStackSOF.java:15) ... OutOfMemory Java虚拟机规范中规定：除了程序计数器之外，其他区域都定义了OutOfMemory异常。各个区域的异常情况不同。 堆溢出(OutOfMemoryError:java heap space) 这种情况可能是堆内存溢出或者堆内存泄漏，需要根据内存溢出的时候产生的dump文件来具体分析。 如果内存泄露，我们要找出泄露的对象是怎么被GC ROOT引用起来，然后通过引用链来具体分析泄露的原因。 ROOT引用起来，然后通过引用链来具体分析泄露的原因。 如果出现了内存溢出问题，这往往是程序本生需要的内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题。下面我们通过如下的代码来演示一下此种情况的溢出：内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题。下面我们通过如下的代码来演示一下此种情况的溢出： /** * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */ public class HeapOOM{ public static void main(String[] args) { List buffer = new ArrayList(); while (true){ buffer.add(new byte[10*1024*1024]); }k } } 结果如下： Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at outOfMemoryDemo.HeapOOM.main(HeapOOM.java:24) 持久带溢出(OutOfMemoryError: PermGen space) 持久带溢出有可能是运行时常量池溢出，也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。 Java中字符串常量是放在常量池中的，String.intern()这个方法运行的时候，会检查常量池中是否存和本字符串相等的对象，如果存在直接返回对常量池中对象的引用，不存在的话，先把此字符串加入常量池，然后再返回字符串的引用。那么我们就可以通过String.intern方法来模拟一下运行时常量区的溢出.下面我们通过如下的代码来模拟此种情况： /** * VM Args: -XX:PermSize=10m --XX:MaxPermSize=10m */ public class RuntimeConstantPoolOOM { public static void main(String[] args) { //使用List保持着常量池引用，避免Fulk GC回收常量池的行为 List list = new ArrayList(); //10MB的PermSize在Integer范围内足够产生OOM了 int i = 0; while (true){ list.add(String.valueOf(i++).intern()); } } } 结果如下： Exception in thread \"main\" java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at outOfMemoryDemo.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java.26) 直接接内存溢出(OutOfMemoryError) 由DirectMemory导致的内存泄漏，一个明显的特征是在Heap Dump文件中不会看见明显的异常。如果发现在OOM之后Dump文件很小，而程序中直接或间接使用了NIO，那就可以考虑一下是不是这方面的原因。 /** * VM Args: -Xmx20m -XX:MaxDirectMemorySize=10m */ public class DirectMemoryOOM { private static final int _1MB = 1024 * 1024; public static void main(String[] args) { Field unsafeField = Unsafe.class.getDeclaredField()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); while (true){ unsafe.allocateMemory(_1MB); } } } 结果如下： Exception in thread \"main\" java.lang.OutOfMemoryError at sum.misc.Unsafe.allocateMemory(Native Method); at outOfMemoryDemo.DirectMemoryOOM.main(DMOOM.java:27) OutOfMemoryError:unable to create native thread 出现这种错误的原因可能有以下两种情况： 程序创建的线程数超过了操作系统的限制。对于Linux系统，我们可以通过ulimit -u来查看此限制。 给虚拟机分配的内存过大，导致创建线程的时候需要的native内存太少。 我们都知道操作系统对每个进程的内存是有限制的，我们启动Jvm,相当于启动了一个进程，假如我们一个进程占用了4G的内存，那么通过下面的公式计算出来的剩余内存就是建立线程栈的时候可以用的内存。 线程栈总可用内存=4G-（-Xmx的值）- （-XX:MaxPermSize的值）- 程序计数器占用的内存 通过上面的公式我们可以看出，-Xmx 和 MaxPermSize的值越大，那么留给线程栈可用的空间就越小，在-Xss参数配置的栈容量不变的情况下，可以创建的线程数也就越小。因此如果是因为这种情况导致的unable to create native thread，那么要么我们增大进程所占用的总内存，或者减少-Xmx或者-Xss来达到创建更多线程的目的。 参考 JVM 堆内存设置原理 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 13:40:04 "},"源码解读/introduction.html":{"url":"源码解读/introduction.html","title":"源码解读","keywords":"","body":"Introduction 要深入学习Java，纸上得来还是太浅显了，阅读源码才是正途。之前也阅读过源码的计划，但是总是有这样那样的事牵绊着，浪费了太多的时间和精力，渐渐地计划也就搁置了。趁着放假，重新开始。 制定的学习路线如下： lang-->util-->io-->nio-->sql-->math-->text-->security 各个包的内容概述如下： 包名 内容概述 java.lang 提供java语言程序设计的基础类 java.util 提供处理日期、时间、随机数生成等各种使用工具的类 java.io 提供与输入输出相关的类 java.nio 为输入输出提供缓冲区的类 java.text 提供了对显示对象格式化的接口、类及异常处理 java.sql 提供使用 JavaTM 编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。 java.math 提供用于执行任意精度整数算法 (BigInteger) 和任意精度小数算法 (BigDecimal) 的类 java.security 为安全框架提供类和接口 我都用的JDK版本是1.8。 Java 8 Doc API https://docs.oracle.com/javase/8/docs/api/ 不求每天都读1个Java源文件，但是有空的时候还是顺带过来瞄一眼吧。 现在开始吧！ Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 23:12:52 "},"源码解读/java.lang/java-lang.html":{"url":"源码解读/java.lang/java-lang.html","title":"java.lang","keywords":"","body":"java.lang Java语言包（java.lang）是Java语言体系中其他所有类库的基础（没有它什么都干不了），已经内嵌到Java虚拟机中，而且以对象的形式建好了。所以在使用的时候不需要再使用import将其导入，可以直接使用java.lang包中所有的类及直接引用某个类中的常量、变量和操作方法。 其中包含的类及相应的功能说明如下： 类名 功能 Boolean 封装了boolean类型的值以及一些操作该类型的方法 Byte 封装了byte类型的值以及一些操作该类型的方法 Character 封装了char类型的值以及一些操作该类型的方法 Double 封装了double类型的值以及一些操作该类型的方法 Float 封装了float类型的值以及一些操作该类型的方法 Integer 封装了int类型的值以及一些操作该类型的方法 Long 封装了long类型的值以及一些操作该类型的方法 Short 封装了short类型的值以及一些操作该类型的方法 String 封装了与字符串类型相关的操作方法 Void 表示对Java中的void关键字的声明，这个类不可以实例 Class 用于描述正在运行的Java应用程序中的类和接口的状态 ClassLoader 用于加载类的对象 Enum 用于定义枚举类型 Math 实现基础的数学计算 Object 是所有Java类的根类 Package 封装了有关Java包的实现和规范的版本信息 Runtime Runtime类对象使Java应用程序与其运行环境相连接 StrictMath 用于实现基本的数学运算 StringBuffer 用于可变字符串的操作 StringBuilder 创建可变的字符串对象 System 封装了一些与Java虚拟机系统相关的方法 Thread 创建和控制线程 ThreadGroup 创建和控制线程组 Throwable 定义了Java中的所有错误或者异常的父类 Process 定义一个进程process对象，通过Runtime类中的exec方法启动该进程对象 其中包含的主要接口和相应的功能说明如下： 接口 功能 Appendable 用于追加字符串 Cloneable 用于复制类对象 Runnable 用于实现类对象具有线程功能 Comparable 用于类对象的排序 2017.10.29 更新。从10月初到今天为止，lang包中除了Package、Runtime、StrictMath和Process没有看， 上表中的其他类都看完了并完成了记录和相应专题的记录。当然其中线程和IO不是lang包能独立完成的，所以这部分还得在后面学习其他包的时候进一步完善和巩固。这些最基础的类的设计确实让我感受良多，到今天初步完成让我有小小的成就感，算是一个里程碑。接下来的任务就是非常非常重要的util包，其中重点是集合类，这部分我将和数据结构的复习放到一起学习。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 14:40:10 "},"源码解读/java.lang/Object.html":{"url":"源码解读/java.lang/Object.html","title":"Object","keywords":"","body":"Object 从JDK1.0起，Object是所有类的父类，每个类都使用它作为超类。注意，所有类，包括arrays。 Object类的结果如下： 可以看到，Object类没有任何的属性，只有12种方法，而且这些方法都被其子类继承覆盖，非常重要。 严格来说，Object有13个方法，没有在structure中显示出来的是默认构造方法public Object()。这是因为，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会生成一个无参数的构造函数。Object作为所有类的基类，自然要反映出此特性，在源码中虽然没有给出定义，但是这个方法实际上是存在的。 当然，并不是所有的类都是以这种方法去构建的，也并不是所有的类构造函数都是public的。 private static native void registerNatives()； registerNatives含义是本地注册的意思，方法被static和navtive两个关键词修饰。被static修饰的方法是静态方法。native关键词修饰的函数表明该方法的实现并不是在Java中完成，而是由C/C++去完成，并被编译了.dll，由Java调用。方法的具体实现体在.dll文件中，对于不同的平台，其具体的使用应该有所不同。用native修饰，即表示操作系统，需要提此方法，Java本身需使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。 通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。对于java.lang.Object,registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives，通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。相关的C代码可以参考http://www.linuxidc.com/Linux/2015-06/118676.htm 注意到，registerNatives的修饰符为private，而且无方法体，那么怎么达到作用呢？在源码中，该方法后面跟了紧接着一段静态代码块： private static native void registerNatives(); static { registerNatives(); } 根据Java初始化的加载顺序：静态代码块在类被加载的时候执行且仅执行一次，一般用来初始化静态变量和调用静态方法。在这里，Object在被构造之前先执行了静态代码块，其中调用的registerNatives方法。 public final native Class getClass()； getClass也是一个由 native修饰的方法，由final修饰表示不能被继承。返回的是此Object对象的类对象/运行时类对象Class，效果与Object.class相同。 上面这段话中，注意到一个词：“类对象”，那么什么是”类对象”呢？在Java中，类是对具有一组相同特征或行为的实例的抽象并进行描述，对象是此类所描述的特征或行为的具体实例。而作为概念层次的“类”，其本身也具有某些共同的特性，比如都具有类名称，由类加载器去加载，都具有包，具有父类、属性和方法等。所以，Java中有专门定义的一个类——Class，去描述其他类所具有的这些特征。因此，从这个角度看，类本身也是属于Class类的对象。为了与经常意义上的对象相区别，在此称为\"类对象\"。 这个方法常常与“反射”联系到一起，至于反射的相关知识点会有一个专题去学习，在此不做记录。 public boolean equals(Object obj){...} 用来判断两个对象是否相等，需要注意的是，这个方法的参数是Object类的对象，在其子类重写该方法时候，别忘记了这个点！有面试的时候让手写过。 说到equals，不得不提的一个运算符就是==。==表示的是变量值完全相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址），equals表示的是对象的内容完全相同，此处多指对象的特征/属性。 在Object中，equals()方法定义如下： public boolean equals(Object obj) { return (this == obj); } 可见，在Object中，判断是否相等的“标尺”仅仅是\"==\"，但是在更复杂类中，判断的标尺没有这么简单了，需要按照实际的需求对标尺的含义重新定义。如在String类中，可以将字符串的类型作为标尺。如果子类没有重新定义equals()方法，那么它会继承其父类的的equals()方法，直到Object。 提到equals()方法，有一句话需要谨记：重新equals()方法必须重写hashCode()方法！！！。 public native int hashCode(); hashCode()返回一个整型数值，表示该对象的哈希码值。源码中对该方法做了如下约定： 在Java应用程序执行期间，对于同一个对象多次调用hashCode()方法，其返回值是相同的，前提是将对象进行equals比较时候所用的标尺信息未做修改。在Java应用程序的一次执行到另一次执行，同一个对象的hashCode()返回的哈希码无须保持一致。 如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等。 反之，如果两个对象调用的hashCode()不相等，那么他们一定不相等。 由此可见， hasCode()、equals()方法和\"两个对象相等\"常常联系到一起，他们之间严格的数学逻辑是： 两个对象相等 equals()相等 => hashCode()相等。 因此，重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立，同时可以推理出： hasCode()不相等 => equals（）不相等 两个对象不相等。 可以看出，“两个对象是否相等”等价于\"equals()\"是否相等，那么hasCode()是否还有存在的必要呢？ hashCode()的存在主要是增强哈希表的性能。举个例子，以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）。 这里有一个常见错误： 对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。 上面说到，重写equals方法时一定要重写hashCode方法，下面是一个例子： public class User { private int uuid; private String name; private int age; public User() { } public User(int uuid, String name, int age) { this.uuid = uuid; this.name = name; this.age = age; } public int getUuid() { return uuid; } public void setUuid(int uuid) { this.uuid = uuid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj){ if (obj == null || !(obj instanceof User)){ return false; } if (((User) obj). getUuid() == this.getUuid()){ return true; } return false; } @Override public int hashCode(){ int result = 17; result = 31 * result + this.getUuid(); return result; } public static void main(String[] args) { User user = new User(1, \"baoxiaofang\", 18); User user1 = user; System.out.println(user.hashCode()); System.out.println(user1.hashCode()); System.out.println(user.equals(user1)); } } 注：上述hashCode()的重写中出现了result * 31，是因为result * 31 = (result。之所以选择31，是因为左移运算和减运算计算效率远大于乘法运算。当然，也可以选择其他数字。 protected native Object clone() throws CloneNotSupportedException; clone()方法返回一个引用，指向的是新的clone出来的对象，此对象和原来对象占据了不同的堆空间。既然这样，我就可以写出下面这段程序了: public class ObjectCloneTest{ public static void main(String[] args) { Object object = new Object(); Object object1 = object.clone(); } } 实际上，如果在IDE中写这段程序，发现写最后一条语句时，自动提示中并没有clone()方法，当然这个程序编译通过，会提示你“Error:(14, 33) java: clone()可以在java.lang.Object中访问protected”。好，问题知道了，Object中clone()方法用protected修饰，即同一个包内或者不同包内的子类可以访问，ObjectCloneTest和Object不在一个包内，但是前者继承了后者，为什么不能访问？ 关键在于对\"不同包中的子类可以访问\"没有正确理解！ \"不同包中的子类可以访问\"，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外） 改成下面这样就可以正常编译了： public static void main(String[] args) { ObjectCloneTest objectCloneTest = new ObjectCloneTest(); try { ObjectCloneTest objectCloneTest1 = (ObjectCloneTest)objectCloneTest.clone(); }catch (Exception e){ e.printStackTrace(); } } 因为此时clone方法主调已经是子类的引用了。这里又有一个知识点了，clone()方法返回值是Object类型，需要强制转化。 但是运行该main方法抛出了异常，如下: java.lang.CloneNotSupportedException: JavaLangJarTest.ObjectCloneTest at java.lang.Object.clone(Native Method) at JavaLangJarTest.ObjectCloneTest.main(ObjectCloneTest.java:17) 问题在于，Java语法规定： clone()正确调用需要实现Cloneable接口，如果没有实现，并且子类直接调用Object类的clone()方法，就会抛出CloneNotSupportedException异常。 所以代码改成下面这种就可以完美执行啦： public class ObjectCloneTest implements Cloneable{ public static void main(String[] args) { ObjectCloneTest objectCloneTest = new ObjectCloneTest(); try { ObjectCloneTest objectCloneTest1 = (ObjectCloneTest)objectCloneTest.clone(); System.out.println(\"o1: = \" + objectCloneTest1); }catch (Exception e){ e.printStackTrace(); } } } public String toString(){...} Object中的toString()方法定义如下： public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } 返回了一个字符串，构成是“对象所属类名@哈希值的十六进制”。 toString()经常被用到，但是很多时候不是显式调用，比如System.out.println(obj)时，其内部也是通过toString()来实现的。 protected void finalize() throws Throwable{} finalize()方法主要和垃圾回收机制有关，在Object类中该方法的定义如下： protected void finalize() throws Throwable { } 方法体为空，为什么为空？ finalize具体的调用时机在：JVM准备对此对象所占用的内容空间进行垃圾回收之前，该方法被调用。所以一般来说，这个方法不是我们主动去调用的。当然你可以主动调用，这个时候，重新的这个方法就与其他自定义犯法没有什么区别，如下面这个例子： public class ObjectFinalizeTest { @Override public void finalize(){ System.out.println(\"This is from finalize method\"); } public static void main(String[] args) { ObjectFinalizeTest obj = new ObjectFinalizeTest(); obj = null; System.gc(); } } 上面这个例子重写了finalize()方法，之后在main方法中，先得到一个实例，在将null赋值给它，目的是为了让他在下一轮的垃圾回收过程中被回收，System.gc()主动触发垃圾回收机制【注意，触发之后并不是立即执行垃圾回收，什么时候回收是由JVM决定的】。程序运行之后将会打印出\"This is from finalize method\"。 wait | notify | notifyAll 这三种方法用于Java多线程之间的协作。Object中一共重载了三种wait方法，一种notify方法，一种notifyAll方法。各自的定义和含义如下： public final void wait() throws InterruptedException 调用此方法的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 public final void wait() throws InterruptedException { wait(0); } 方法体中调用了有一个参数的wait方法。 wait(long timeout)/wait(long timeout, int nanos) 调用此方法所在的当前线程等待，直到其他线程上调用此方法的主调（某一对象）的notify()/notifyAll方法，或者超过指定的超时时间量。 public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos > 0) { timeout++; } wait(timeout); } 注意两个参数的这个wait方法，第一个参数timeout的单位是毫秒，参数nanos的单位是纳秒， 1毫秒 = 1000 微秒 = 1000 000 纳秒， 处理时候，由于纳秒时间太短（猜测），所以对参nanos采取了近似处理。这个方法在JDK1.6中的定义与上面的定义不同，1.6中的定义方法如下： public final void wait(long timeout, int nanos) throws nterruptedException { if (timeout 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } // nanos 大于 500000 即半毫秒 就timout 加1毫秒 // 特殊情况下: 如果timeout为0且nanos大于0,则timout加1毫秒 if (nanos >= 500000 || (nanos != 0 && timeout == 0)) { timeout++; } wait(timeout); } 这对于半毫秒的加1毫秒，小于1毫秒的舍弃（特殊情况下，参数timeout为0时，参数nanos大于0时，也算1毫秒），器租用应该在能更精确控制等待时间（尤其在高并发时，毫秒的时间节省也是值得的）。 public final native void notify(); 作用是唤醒在此对象监视器上等待的随机单个线程。 public final native void notifyAll(); 作用是唤醒在此对象监视器上等待的所有线程。 以上三种方法都是配套使用的，下面是一个简单的例子： public class ThreadTest { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub MyRunnable r = new MyRunnable(); Thread t = new Thread(r); t.start(); synchronized (r) { try { System.out.println(\"main thread 等待t线程执行完\"); r.wait(); System.out.println(\"被notity唤醒，得以继续执行\"); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"main thread 本想等待，但被意外打断了\"); } System.out.println(\"线程t执行相加结果\" + r.getTotal()); } } } class MyRunnable implements Runnable { private int total; @Override public void run() { // TODO Auto-generated method stub synchronized (this) { System.out.println(\"Thread name is:\" + Thread.currentThread().getName()); for (int i = 0; i 执行结果为： main thread 等待t线程执行完 Thread name is:Thread-0 执行notif后同步代码块中依然可以继续执行直至完毕 执行notif后且同步代码块外的代码执行时机取决于线程调度 //此行输出位置有具体的JVM线程调度决定，有可能最后执行 被notity唤醒，得以继续执行 线程t执行相加结果45 既然是作用于多线程中，为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(...)/notify()|notifyAll()方法只能在同步代码块中才能使用。 从上述例子的输出结果中可以得出如下结论： wait(...)方法调用后当前线程将立即阻塞，且释放其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行； notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。 多线程是一块很难啃的骨头，具体的还是在以后的专题中整理吧。 参考： Java总结篇系列：java.lang.Object Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 14:59:46 "},"源码解读/java.lang/Boolean.html":{"url":"源码解读/java.lang/Boolean.html","title":"Boolean","keywords":"","body":"Boolean Boolean是最简单的数值包装类型，其结果如下： 包装类最重要的作用就是提供类型转换，从上图可以看到，大部分的属性和方法都是为了这个目的存在的。 public final class Boolean implements java.io.Serializable, Comparable 首先注意到的是类声明，被final修饰，说明该类不可被继承。第二这个类实现了Serializable和Comparable接口，说明该类可被序列化和比较。 private static final long serialVersionUID = -3665804199014368530L; serialVersionUID是做什么的呢？前面说到这个类实现了Serializable接口，那么这个常量用来进行序列化类的时候使用。具体怎么用，暂时不关心，看看就好，可以参考 http://blog.csdn.net/yuexuanyu/article/details/30035153 private final boolean value; 这就是包装类的值，没什么好说的，在实例化的时候，将基本类型的boolean值赋值给这个属性就可以了。 public static final Class TYPE = (Class) Class.getPrimitiveClass(\"boolean\"); 又用到了反射的知识了，基本数据类型和其包装类怎么取得联系呢？就是靠这句话了。 public static final Boolean FALSE = new Boolean(false); public static final Boolean TRUE = new Boolean(true); 这两个量在自动装箱函数valueOf()中用到，到时候再说。 public Boolean(boolean value){..} 和 public Boolean(String s){...} 两个重载的构造函数，可以接受一个boolean型的参数和一个String型的参数， 前者定义如下： public Boolean(boolean value) { this.value = value; } 将布尔值赋值给value属性，初始化就完成了。后者定义如下： public Boolean(String s) { this(parseBoolean(s)); } 这里调用了一个parseBoolean(..)方法，得到一个boolean值，再调用之前的那个构造函数。parseBoolean这个方法的定义如下： public static boolean parseBoolean(String s) { return ((s != null) && s.equalsIgnoreCase(\"true\")); } 可见，字符串为\"true\"的一些大小写变体时会得到true，其他情况（包括null）将会得到false。 可见Boolean类没有无参构造函数，Boolean b = new Boolean()这种事编译不通过的。 public static boolean parseBoolean(String s) {...} 将String类型转为boolean基本数值类型的，前面讲过，不多说了。 public boolean booleanValue(){...} 获取对象的基本数值，很简单，直接返回value属性值，定义如下： public boolean booleanValue() { return value; } public static Boolean valueOf(boolean b){...} public static Boolean valueOf(String s){...} valueOf是基本包装类中最重要的方法，涉及到\"自动装箱\"的概念，即如何由基本数值类型获得其包装类型。诶，new一个对象出来不就行了么？说的没错，但是跟这边将的不是一个概念。我们在使用基本数值包装类的时候，往往并没有那么刻意去new，而多是采取Boolean b = false;这种写法，这里没有new，没有调用构造函数啊，怎么就获得到一个对象呢？因为这种写法偷偷调用的valueOf方法，得到一个包装类的对象，这就是“自动装箱”。 Boolean定义了两个valueOf方法，前者定义如下： public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } 这里返回的TRUE和FALSE是前面说到的私有静态常量。如果多次调用valueOf方法，只要参数一样，得到的实际上是同一个对象！注意，是同一个对象。看下面这段程序： public class BooleanTest { public static void main(String[] args) { Boolean b1 = false; Boolean b2 = false; Boolean b3 = new Boolean(false); System.out.println(b1 == b2 ); System.out.println(b2 == b3); } } 注意==运算符比较的是数值，当两个参数都是对象引用的时候，比较的是引用的地址，所以上例输出： true false 还有一个以String类型对象作为参数的valueOf方法，定义如下： public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; } 调用了parseBoolean方法，很简单，不再赘述。 public String toString(){...} 和 public static String toString(boolean b){...} 一个非静态，一个静态，方法体都很简单，前者： public String toString() { return value ? \"true\" : \"false\"; } 后者： public static String toString(boolean b) { return b ? \"true\" : \"false\"; } 没什么好说的。 public boolean equals(Object obj){...} 定义如下： public boolean equals(Object obj) { if (obj instanceof Boolean) { return value == ((Boolean)obj).booleanValue(); } return false; } 先比较类型，再比较数值。注意，equals方法没有进行类型转化哦。 public static int hashCode(boolean value){...} 和 public int hashCode(){...} 一个静态，一个非静态，前者调用后者，前者定义： @Override public int hashCode() { return Boolean.hashCode(value); } 后者定义： public static int hashCode(boolean value) { return value ? 1231 : 1237; } 可见，true的哈希值为1231，false的哈希值为1237。 public static boolean getBoolean(String name){...} 这里的name是某个系统属性的名称，定义如下： public static boolean getBoolean(String name) { boolean result = false; try { result = parseBoolean(System.getProperty(name)); } catch (IllegalArgumentException | NullPointerException e) { } return result; } 如果没有叫叫这个名字的系统属性，或者值为空，返回false。 public int compareTo(Boolean b){..} 两个Boolean对象的比较，实际上比较的是两个对象的值，定义如下: public int compareTo(Boolean b) { return compare(this.value, b.value); } 这里调用的compare是一个静态方法，定义如下： public static int compare(boolean x, boolean y) { return (x == y) ? 0 : (x ? 1 : -1); } x.compareTo(y)，如果两者相等，返回0。否则当x不为0的时候返回1，为0的时候返回-1。 public static int compare(boolean x, boolean y){...} 上面将多了，不多说。 public static boolean logicalAnd(boolean a, boolean b){...} 和 public static boolean logicalOr(boolean a, boolean b){...} 和 public static boolean logicalXor(boolean a, boolean b){...} 逻辑位运算，分别返回x & y， x | y， x ^ y。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-14 16:47:42 "},"源码解读/java.lang/Byte.html":{"url":"源码解读/java.lang/Byte.html","title":"Byte","keywords":"","body":"Byte Byte是最最基本的整型数值包装类，其结构如下： 有些内容很好理解，也与Boolean的内容重复了，这里只挑不同的或者比较重要的来讲。 public final class Byte extends Number implements Comparable 类声明被final修饰，表示不能被继承。本身继承了Number类，实现了Comparable接口。 属性变量 public static final byte MIN_VALUE = -128; public static final byte MAX_VALUE = 127; @SuppressWarnings(\"unchecked\") public static final Class TYPE = (Class) Class.getPrimitiveClass(\"byte\"); public static final int SIZE = 8; public static final int BYTES = SIZE / Byte.SIZE; private final byte value; private static final long serialVersionUID = -7183698231559129828L; 前两句话定义了Byte类型对象表示的范围是[-128,127]。 被注解为对将警告保持静默的这句话是获得该类的原始类，这里用到了反射。之后定义了Byte的大小为8位，1字节。 public Byte(byte value) {...} 和 public Byte(String s) throws NumberFormatException {...} 两种构造方法，分别支持byte型基本数值类型和String类型，后者定义如下： public Byte(String s) throws NumberFormatException { this.value = parseByte(s, 10); } 这里做了限制，传入的必须是能转为数字的字符串，不满足条件则抛出异常。这里调用了parseByte方法，以10进制转换数值，定义如下： public static byte parseByte(String s, int radix) throws NumberFormatException { int i = Integer.parseInt(s, radix); if (i MAX_VALUE) throw new NumberFormatException( \"Value out of range. Value:\\\"\" + s + \"\\\" Radix:\" + radix); return (byte)i; } 先将该数值转化为10进制的int型，如果该值超不在[-128, 127]内，则重新抛出异常。 public static String toString(byte b){...} 和 public String toString(){..} 前者定义如下： public static String toString(byte b) { return Integer.toString((int)b, 10); } 后者重写从Object继承的toString方法，定义如下： public String toString() { return Integer.toString((int)value); } 它们实则都是在调用Integer的toString方法。 public static Byte valueOf(byte b) {...} 和 public static Byte valueOf(String s) throws NumberFormatException {..} 和 public static Byte valueOf(String s, int radix) throws NumberFormatException {..} 三种自动装箱方法，第一种组重要，很重要！！！定义如下： public static Byte valueOf(byte b) { final int offset = 128; return ByteCache.cache[(int)b + offset]; } 从Byte开始，基本整型数值包装类都使用了缓存的方法。这里ByteCache是Byte中的内部静态类，而cache是ByteCache中的静态常量数组，定义如下: private static class ByteCache { private ByteCache(){} static final Byte cache[] = new Byte[-(-128) + 127 + 1]; static { for(int i = 0; i 当Byte类被加载的时候，这个内部类不会初始化，什么时候初始化呢？在valueOf被调用的时候，这个内才被加载、初始化。可见，如果传入valueOf方法的参数相同，最终取到的对象值是同一个！ 后两者接收字符串作为被转化的量，其中一个默认进制是10， 另一种方法可指定进制，其定义分别如下： public static Byte valueOf(String s) throws NumberFormatException { return valueOf(s, 10); } public static Byte valueOf(String s, int radix) throws NumberFormatException { return valueOf(parseByte(s, radix)); } public static Byte decode(String nm) throws NumberFormatException{...} decode 用来分析数字，定义如下： public static Byte decode(String nm) throws NumberFormatException { int i = Integer.decode(nm); if (i MAX_VALUE) throw new NumberFormatException( \"Value \" + i + \" out of range from input \" + nm); return valueOf((byte)i); } 又是在调用Integer类的静态decode方法得到int型变量后在判断是否在Byte的表示范围内，不再则抛出异常。哎，数值类型Integer还是老大哥啊，很多关键的问题还要靠他来解决。 public xxx xxxValue(){...} 这一类都是重写了其父类Number的方法，进行强制转化后返回相应的值，这一系列有哪些呢？byteValue()、shortValue、intValue、longValue、floatValue、doubleValue，比如intValue定义如下： public long longValue() { return (long)value; } Byte是最基本的数值包装类型，所以这样的强制转化没有什么精度损失。 public int hashCode{..} 和 public static int hashCode(byte value) {..} 前者调用后者，后者定如下： public static int hashCode(byte value) { return (int)value; } 将其value值转为int型然后返回了，就是这么简单。 public int compareTo(Byte anotherByte){...} 和 public static int compare(byte x, byte y){..} 前者调用后者，后者定义如下： public static int compare(byte x, byte y) { return x - y; } 这次是真的在比小大了，返回的是主调与参数的差值。 public static int toUnsignedInt(byte x){...} 和 public static long toUnsignedLong(byte x){...} 从名字就能看出来了，转化为无符号的int型和long型，前者定义如下： public static int toUnsignedInt(byte x) { return ((int) x) & 0xff; } 后者定义如下： public static long toUnsignedLong(byte x) { return ((long) x) & 0xffL; } 用到位与运算。 & 运算：两个操作数都为1，结果才为1，否则为0。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-02 15:08:02 "},"源码解读/java.lang/Short.html":{"url":"源码解读/java.lang/Short.html","title":"Short","keywords":"","body":"Short Short类的结构如下： Short和Byte类大部分都是类似的，这里只挑拣几个不同的地方讲。 public static Short valueOf(short s){..} 和Byte一样，Short类也采取了缓存，但是稍微有点不一样。valueOf方法的定义如下： public static Short valueOf(short s) { final int offset = 128; int sAsInt = s; if (sAsInt >= -128 && sAsInt 其中内部静态类ShortCache的定义如下： private static class ShortCache { private ShortCache(){} static final Short cache[] = new Short[-(-128) + 127 + 1]; static { for(int i = 0; i 乍一看好像和Byte没什么不一样，但是就是不一样，因为Short占16位，但是只缓存了[-128,127]，所以在自动装箱的时候就有了区别，例如下面这段程序： public class ShortTest { public static void main(String[] args) { Short s1 = 100; Short s2 = 100; System.out.println(s1 == s2); Short s3 = 200; Short s4 = 200; System.out.println(s3 == s4); } } 输出结果如下： true false 为什么两个输出结果不一样呢？因为s1和s2的值都是100，在[-128, 127]范围内，所以自动装箱返回的其实是cache数组中的同一个对象，而s3和s4的值都是200，不在[-128, 127]范围内，每次返回的都是新new出来的对象。 public static short reverseBytes(short i){..} 这个方法在Byte中没有，用来干什么的呢？字面上翻译就是\"位翻转\"，就是讲int党委二进制，左边的位与右边的位进行互换，reverse是按位进行互换，reverseBytes是按照byte进行互换，看它的定义： public static short reverseBytes(short i) { return (short) (((i & 0xFF00) >> 8) | (i 该方法返回的值是得到2的补码表示指定的字节的顺序颠倒过来的short值。额其实我没看懂移位运算怎么回事，看来要想读懂源码还得恶补位运算，/(ㄒoㄒ)/~~ 位运算真的好烦躁啊 public xxx xxxValue(short s){...} 还是强制转换，这里注意byteValue方法会损失精度，别的方法倒不会。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-02 22:37:42 "},"源码解读/java.lang/Integer.html":{"url":"源码解读/java.lang/Integer.html","title":"Integer","keywords":"","body":"Integer 终于到了最重要的一个基本数值包装类了，还是先看下结构： 这么多的方法我一屏都截不下来，它之所以重要，并不是因为方法多，而是Byte、Short、Long中很多方法都是直接调用Integer中的方法的，这一点在之前看Byte和Short类的时候应该深有体会。 任务很艰巨，还是挑重点来吧，条条都是重点啊！ valueOf方法 三种valueOf方法，当然还是第一种方法最重要了，其定义如下： public static Integer valueOf(int i) { if (i >= IntegerCache.low && i 又是熟悉的配方：缓存。但是这次的缓存类没有那么简单了。复杂在什么地方，可以看到，之前Byte和Short直接规定了范围是[-128, 127]，但是Integer中没有直接这么做的，而是用内部缓存类的静态属性low和high来限定范围。内部静态缓存类IntegerCache的定义如下： private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k = 127; } private IntegerCache() {} } 可见Integer只限定了下界为-128,上界只设定了默认值为127但是可以被修改。如何修改呢？可以看到代码String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");，这是是通过读取VM参数赋值给integerCacheHighPropValue，之后取127与该值得最大值赋值给i,但是这个值与-128的距离不能超过Integer能表示的范围。我们可以通过VM参数 -XX:AutoBoxCacheMax= 可以配置缓存的最大值。 但是呢，一般来说好像没人这么无聊去设置这个参数，所以一般情况下，Integer的缓存区间还是[-128,127]， 超出这个范围的每次都是返回新new的对象。 toXxxString(..) 这个真的有好几种转换为String的方法，最厉害的也是最基本的是这种： public static String toString(int i) { if (i == Integer.MIN_VALUE) ① return \"-2147483648\"; int size = (i ① 先判断这个数字是不是最小值，如果是则直接返回字符串，省去了下面的步骤。 ② 再判断这个值的长度，怎么做的呢？如果是负数，就将这个数取反，得到stringSize方法的结果加上1【因为有一个负号，所以长度加1】，如果是正数则直接返回方法的结果。那么 stringSize方法是怎么实现的呢，定义如下： static int stringSize(int x) { for (int i=0; ; i++) if (x 这个方法巧妙地借助了一个数组，这个数组存储了数组下标加1后表示的位数能够存储的最大正数值。如sizeTable[0] = 9，表示位数为0 + 1 = 1的整数的最大值为9，通过比较x的值得到x的位数。厉害了，要是我来设计的话，我可能要用递归的方法每次除以10直到商为0，虽然复杂度一样，但是这样太消耗栈空间了。学习了！ ③ 构造该数字长度的字符数组。 ④ 依次填充字符数组，这里利用到了一个方法是getChars，定义如下： static void getChars(int i, int index, char[] buf) { int q, r; int charPos = index; char sign = 0; if (i = 65536) { ① q = i / 100; // really: r = i - (q * 100); r = i - ((q >> (16+3); r = i - ((q ① 当i >= 65536的时候每一次从后往前获取两个最低位数。使用移位操作快速计算出q*100（因为2^6+2^5+2^2=64+32+4=100)，此时r的值就是后两位。现在需要构造两个数组，要求只根据r的值就能快速得到个位和十位上的字符。怎么设计？ 假如现在r = 65，个位上是 5，要得到个位上的5，这时候不管十位是多少个位上一定是5，所以数组DigitOnes的 05，15，25，35，45，55，65，75，85，95位置上都是 5，这样不管是25，还是35 都能得到个位上的5。在来看看如何得到十位上的数，还是65，十位是6，所以DigitTens 的60，61，62，63，64，……69 位置上都是6。 final static char [] DigitTens = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '5', '5', '5', '5', '5', '5', '5', '5', '5', '5', '6', '6', '6', '6', '6', '6', '6', '6', '6', '6', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '8', '8', '8', '8', '8', '8', '8', '8', '8', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', } ; final static char [] DigitOnes = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', } ; ` ② 当i q = (i * 52429) >>> (16+3);这段代码其实就是q=i/10 ,其中 (double)52429/(1也就是在int型的时候计算一个数的十分之1的精度是够的，可以看出开发者的这种优化意识是非常强的。同样是这个时候需要借助的是digits数组，其内容如下： final static char[] digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' }; ` 当时我就觉得奇怪了，digits这个数组中为什么还有字母呢？看上面的过程应该用不到字母才对，后来接着看别的方法的时候才知道这个数组被非10进制的toString方法复用了，大写的服！ 最后判断如果这个数是负数，将数组的第一个元素置为‘-’。 有一个问题，为什么用65535作为分界线呢，为什么不一直两位两位取值或者干脆一位一位取值呢？或者两位取值一定快，如果奇数位的时候判断一下做下处理不就行了么? 一位一位取值胜在精度。开发者做了两全的办法，大数范围内，求快，小数范围内，求准，至于为什么是65535，我才因为Integer是32位的，按照该概率来讲，平分才有最好的效果，所以取16位。猜测而已。 以上方法输出的是数字十进制表示的字符串，如果需要的不是十进制怎么办？比如想要得到100这个数字的二进制表示。重载了支持指定进制的toString方法，定义如下： public static String toString(int i, int radix) { if (radix Character.MAX_RADIX) radix = 10; /* Use the faster version */ if (radix == 10) { return toString(i); } char buf[] = new char[33]; boolean negative = (i 首先限定了最终的进制的值，即小于2大于36的一律作为10进制输出，如果是十进制，则调用无参方法。否则从低位开始计算该进制下的值，这里同样借助了digits数组。但是这里有一个问题，为什么要将数字转为负数后再进行除法运算？ 其他的一些方法并不是那么常用，这里也不做介绍了，有兴趣看源码吧。 parseInt 有好几种重载的paraseInt方法，区别在于进制、有无符号，最重要的是下面这种： public static int parseInt(String s, int radix) throws NumberFormatException { /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ // 下面三个判断好理解，其中表示进制的 radix 要在（2~36）范围内 if (s == null) { throw new NumberFormatException(\"null\"); } if (radix Character.MAX_RADIX) { throw new NumberFormatException(\"radix \" + radix + \" greater than Character.MAX_RADIX\"); } /** * 表示结果， 在下面的计算中会一直是个负数 * 假如说 我们的字符串是一个正数 \"7\",那么在返回这个值之前result保存的是 -7 * 这个可能是为了保持正数和负数在下面计算的一致性 */ int result = 0; boolean negative = false; int i = 0, len = s.length(); /** * limit 默认初始化为 最大正整数的 负数 ，假如字符串表示的是正数 * 那么result(在返回之前一直是负数形式)就必须和这个最大正数的负数来比较，判断是否溢出 */ int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len > 0) { char firstChar = s.charAt(0); //首先是对第一个位置判断，是否含有正负号 if (firstChar result = 0 ; result -= digit --> result = -1 * 第二次result *= radix --> result = -10; result -= digit --> result = -12 * 第三次result *= radix --> result = -12; result -= digit --> result = -123 * 此时，negative = false，则返回 -result，即最终结果为：123 */ /** * 再来个假设：一开始输入一个数字字符串为-123，那么对应的radix=10(因为是10进制的)，digit = -123 / 10 计算得到的 * 第一次result *= radix --> result = 0 ; result -= digit --> result = -1 * 第二次result *= radix --> result = -10; result -= digit --> result = -12 * 第三次result *= radix --> result = -12; result -= digit --> result = -123 * 此时，negative = true，则返回 result，即最终结果为：-123 */ } } else { throw NumberFormatException.forInputString(s); } return negative ? result : -result; } 其实进制转化这个算法是很好写的，但是这个方法的厉害之处就在于它将正数和负数统一处理了，并且考虑到了各种边界条件。这个算法被面试到过，所以要特别注意。另外还需要注意，这个只会抛出NumberFormatException异常，没有别的异常抛出。 public static int hashCode(int value){..} 定义如下： public static int hashCode(int value) { return value; } 简单地返回了value的值而已。 public static int compare(int x, int y){...} 这次不是返回差值了，定义如下： public static int compare(int x, int y) { return (x 主调较小的时候返回-1， 相等时候返回0，主调较大的时候返回1。 public static Integer decode(String nm) throws NumberFormatException 作用是解码字符串转化为正数。这个字符串可以是十进制、十六进制和八进制 public static Integer decode(String nm) throws NumberFormatException { int radix = 10; int index = 0; boolean negative = false; Integer result; if (nm.length() == 0) throw new NumberFormatException(\"Zero length string\"); char firstChar = nm.charAt(0); // Handle sign, if present if (firstChar == '-') { negative = true; index++; } else if (firstChar == '+') index++; // Handle radix specifier, if present if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) { index += 2; radix = 16; } else if (nm.startsWith(\"#\", index)) { index ++; radix = 16; } else if (nm.startsWith(\"0\", index) && nm.length() > 1 + index) { index ++; radix = 8; } if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index)) throw new NumberFormatException(\"Sign character in wrong position\"); try { result = Integer.valueOf(nm.substring(index), radix); result = negative ? Integer.valueOf(-result.intValue()) : result; } catch (NumberFormatException e) { // If number is Integer.MIN_VALUE, we'll end up here. The next line // handles this case, and causes any genuine format error to be // rethrown. String constant = negative ? (\"-\" + nm.substring(index)) : nm.substring(index); result = Integer.valueOf(constant, radix); } return result; } 重要的是前面判断进制的过程，0x和#开头的是十六进制，0开头的是八进制，默认十进制。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 15:00:27 "},"源码解读/java.lang/Long.html":{"url":"源码解读/java.lang/Long.html","title":"Long","keywords":"","body":"Long 看过了最重要的Integer之后，Long就不怕了，其结构如下： 看着虽然很多，但是很多内容直接调用了Integer的方法或者一样的套路，还是挑不同的记录。 public static Long valueOf(long l) {...} 自动装箱方法，定义如下： public static Long valueOf(long l) { final int offset = 128; if (l >= -128 && l 没有Integer那么婆婆妈妈的，直接约定缓存范围是[-128, 127]，超出部分直接new新对象。 public static String toString(long i){...} public static String toString(long i) { if (i == Long.MIN_VALUE) return \"-9223372036854775808\"; int size = (i 套路差不多一样，但是由于Long类型占的长度是Integer的两倍，所以不能用数组了（否则写到天荒地老），所以stringSize和getChars方法有所不同，其中stringSize方法定义如下： static int stringSize(long x) { long p = 10; for (int i=1; i Long能表示的最大值是2的64次方，十进制表示的时候是19位数字。 其中getChars方法如下： static void getChars(long i, int index, char[] buf) { long q; int r; int charPos = index; char sign = 0; if (i Integer.MAX_VALUE) { q = i / 100; // really: r = i - (q * 100); r = (int)(i - ((q = 65536) { q2 = i2 / 100; // really: r = i2 - (q * 100); r = i2 - ((q2 >> (16+3); r = i2 - ((q2 这里的过程和Integer中的getChars方法一样，只是将过程分为了三个阶段，分为以Integer.MAX_VALUE和65535为界。 public static int hashCode(long value){..} 定义如下： public static int hashCode(long value) { return (int)(value ^ (value >>> 32)); } 由于hashCode返回值是int类型，最多32位，而Long类型有64位，所以Long类型需要砍掉一半，这就是value >>> 32，但是为了不丢失这砍掉的一半的信息，会将值得高32位和低32位进行exclusive OR操作，这样就保证结果均会收到前后32位的影响，不丢失信息。如果直接将Long转为int，将会丢失高32位的信息。 为什么hashCode返回int型而不是long型？ 因为在Java中，一个Array的最长长度是： Integer.MAX_VALUE Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-04 12:10:08 "},"源码解读/java.lang/Float.html":{"url":"源码解读/java.lang/Float.html","title":"Float","keywords":"","body":"Float 来到浮点数的范畴了，虽然float不是经常用，但是还是要好好看看的，结构如下： 常量 Float中有一些特殊的常量定义，如下： /** * A constant holding the positive infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0x7f800000)}. */ public static final float POSITIVE_INFINITY = 1.0f / 0.0f; /** * A constant holding the negative infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0xff800000)}. */ public static final float NEGATIVE_INFINITY = -1.0f / 0.0f; /** * A constant holding a Not-a-Number (NaN) value of type * {@code double}. It is equivalent to the value returned by * {@code Double.longBitsToDouble(0x7ff8000000000000L)}. */ public static final float NaN = 0.0f / 0.0f; /** * A constant holding the largest positive finite value of type * {@code float}, (2-2-23)&middot;2127. * It is equal to the hexadecimal floating-point literal * {@code 0x1.fffffeP+127f} and also equal to * {@code Float.intBitsToFloat(0x7f7fffff)}. */ public static final float MAX_VALUE = 0x1.fffffeP+127f; // 3.4028235e+38f /** * A constant holding the smallest positive normal value of type * {@code float}, 2-126. It is equal to the * hexadecimal floating-point literal {@code 0x1.0p-126f} and also * equal to {@code Float.intBitsToFloat(0x00800000)}. * * @since 1.6 */ public static final float MIN_NORMAL = 0x1.0p-126f; // 1.17549435E-38f /** * A constant holding the smallest positive nonzero value of type * {@code float}, 2-149. It is equal to the * hexadecimal floating-point literal {@code 0x0.000002P-126f} * and also equal to {@code Float.intBitsToFloat(0x1)}. */ public static final float MIN_VALUE = 0x0.000002P-126f; // 1.4e-45f /** * Maximum exponent a finite {@code float} variable may have. It * is equal to the value returned by {@code * Math.getExponent(Float.MAX_VALUE)}. * * @since 1.6 */ public static final int MAX_EXPONENT = 127; /** * Minimum exponent a normalized {@code float} variable may have. * It is equal to the value returned by {@code * Math.getExponent(Float.MIN_NORMAL)}. * * @since 1.6 */ public static final int MIN_EXPONENT = -126; INFINITY主要是为了解决除数为0的情况。NaN即\"NOT A NUMBER\"， 表示非数字，它与任何值都不相等， 甚至不等于自己，所以要判断一个数是否NAN需要用isNAN方法。VALUE定义了最大最小值，EXPONENT定义了最大最小指数。下面是一个测试程序： public static void main(String[] args) { float NAN1 = Float.NaN; float NAN2 = 0.0f / 0 ; System.out.println(Float.isNaN(NAN1)); //true System.out.println(Float.isNaN(NAN2)); //true System.out.println(NAN1 == NAN1); // false System.out.println(NAN1 == NAN2);//false double Inf1 = Double.POSITIVE_INFINITY; double Inf2 = Double.NEGATIVE_INFINITY; float Inf3 = Float.POSITIVE_INFINITY; float Inf4 = Float.NEGATIVE_INFINITY; System.out.println(Double.isInfinite(Inf1)); //true System.out.println(Float.isInfinite(Inf3)); //true System.out.println(Inf1 == Inf3); //true System.out.println(Inf2 == Inf4); //true System.out.println(Inf1 * 0); //NaN System.out.println(Inf1 + 1); //Infinity System.out.println(Inf1 * 0.4); //Infinity System.out.println(Inf1 / 0); //Infinity } 从上面的测试代码中可以得出结论： double或者float判断是不是INFINITY都使用isInfinite方法。 double中的INFINITY与float中的INFINITY是相等的。 INFINITY乘以0得到NAN。 INFINITY做除了乘以0以外的任何四则运算，得到的结果仍然是INFINITY。 public static Double valueOf(double d){...} 浮点型可不好做缓存，所以自动装箱的时候都是返回一个新new的对象。定义如下： public static Float valueOf(float f) { return new Float(f); } public static int hashCode(float value){..} 定义如下： public static int hashCode(float value) { return floatToIntBits(value); } 调用的floatToIntBits方法定义如下： public static int floatToIntBits(float value) { int result = floatToRawIntBits(value); // Check for NaN based on values of bit fields, maximum // exponent and nonzero significand. if ( ((result & FloatConsts.EXP_BIT_MASK) == FloatConsts.EXP_BIT_MASK) && (result & FloatConsts.SIGNIF_BIT_MASK) != 0) result = 0x7fc00000; return result; } 首先调用了floatToRawIntBits方法，该方法的定义如下： public static native int floatToRawIntBits(float value); 这个方法返回位代表的浮点数，具体的解释如下： 根据IEEE 754浮点“单一格式”位布局，返回指定浮点值的表示，保留非数字（NaN）值。它包括以下要点： If the argument is positive infinity, the result is 0x7f800000. If the argument is negative infinity, the result is 0xff800000. 如果参数是NaN，那么结果是整数，表示实际NaN值。从floatToIntBits方法不同，floatToRawIntBits不可折叠所有的位模式将NaN编码为一个“规范”NaN值. 好吧，读了一遍还是没有懂，后面的代码也不是很懂，在网上抄了一段结论： 该方法根据 IEEE 754 浮点“单一格式”位布局，返回指定浮点值的表示形式：第31位（掩码0x80000000选定的位）表示浮点数的符号，第30～23位（掩码0x7f800000选定的位）表示指数，第22～0位（掩码0x007fffff选定的位）表示浮点数的有效位数（有时也称为尾数）。如果参数为正无穷大，则结果为0x7f800000；如果参数为负无穷大，则结果为0xff800000；如果参数为NaN，则结果为0x7fc00000。 在所有情况下，结果都是一个整数，将其赋予intBitsToFloat(int)方法将生成一个浮点值，该浮点值与floatToIntBits的参数相同（而所有NaN值则会生成一个“规范”NaN值）。看下面的例子： float f = 123.456f; int i = Float.floatToIntBits(f); System.out.println(i); 将打印出 1123477881 public boolean equals(Object obj) {...} 浮点数不太好比较大小，怎么办呢，前面说到的函数floatToIntBits又用到了： public boolean equals(Object obj) { return (obj instanceof Float) && (floatToIntBits(((Float)obj).value) == floatToIntBits(value)); } 从上面所有的例子可以看出来，Float这个类最重要的是floatToIntBits这个方法，而这个方法调用floatToRawIntBits这个本地实现的方法，将浮点数化成int型进行比较，被应用于equals、hashCode、max等方法的中。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-02 21:56:08 "},"源码解读/java.lang/Double.html":{"url":"源码解读/java.lang/Double.html","title":"Double","keywords":"","body":"Double 浮点型默认为double，所以Double也比Float常用，其结构如下： 和Float没差多少。 public static Double valueOf(double d){...} 同样没有缓存，每次自动装箱都返回一个新new的对象。 public static int hashCode(double value){...} 定义如下： public static int hashCode(double value) { long bits = doubleToLongBits(value); return (int)(bits ^ (bits >>> 32)); } 和Float类似，调用doubleToLongBits方法得到一个long类型值，返回让该值的高32位和低32位做OR运算得到哈希值。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-02 21:41:43 "},"源码解读/java.lang/Character.html":{"url":"源码解读/java.lang/Character.html","title":"Character","keywords":"","body":"Character 学习这个类的时候真的好想死一死，因为列表真的好长啊，哎： 只看一些常用的。 常量 public static final int MIN_RADIX = 2; public static final int MAX_RADIX = 36; public static final char MIN_VALUE = '\\u0000'; public static final char MAX_VALUE = '\\uFFFF'; 前两个量常常在之前的几个数值包装类中见过，常用来限定进制的范围，不小于2不大于36的2的倍数。后面两个就是Character能表示的范围，可以看出Character占16位。 public static Character valueOf(char c) {...} Character同样采取了缓存的自动装箱方式，定义如下： public static Character valueOf(char c) { if (c 其中静态内部缓存类的定义如下： private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i 可见，缓存的范围是[0,127]，超出这个范围时，返回一个新new的对象。 public static int hashCode(char value){...} public static int hashCode(char value) { return (int)value; } Character的hashCode也很简单粗暴，直接返回其value的int值。 public String toString(){...} public String toString() { char buf[] = {value}; return String.valueOf(buf); } 这个初始化了一个字符数字，然后用String类的valueOf方法返回字符串。 几个常用方法 剩下的方法太多也不常用，我这里就偷懒先不看了，下面列出的是几个常用的方法，在脑子里有个印象，知道有这么个事就行了。 public static boolean isUpperCase(char ch)：判断给定的字符是否是大写字符 public static boolean isLowerCase(char ch)：判断给定的字符是否是小写字符 public static boolean isDigit(char ch)：判断给定的字符是否是数字字符 public static char toUpperCase(char ch)：把给定的字符转换为大写字符 public static char toLowerCase(char ch)：把给定的字符转换成小写字符 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-02 23:04:10 "},"源码解读/java.lang/String.html":{"url":"源码解读/java.lang/String.html","title":"String","keywords":"","body":"String 好吧 终于到了重头戏了 String一定要好好看！结构如下： 方法虽然多，但是大部分都是重载。 public final class String implements java.io.Serializable, Comparable, CharSequence 首先看这个类声明，String类被final修饰，不可继承。类实现了Serializable、Comparable接口和CharSequence接口，最后这接口的结构如下 之后我们会在String中看到接口方法的实现。 private final char value[]; 字符数组用来存储字符串中的字符，这就是String内部的实现。特别需要注意的是，这里用final修饰，也就是说，一旦String的实例被创建，即value被填充，那么不可再更改，如果需要更改，那将是创建一个新对象，用新的内容赋值。这就是所谓的字符串永久性。 private int hash; String和之前遇到的类不同的一点在于，对象属性保存了其哈希值，默认为0。 private static final ObjectStreamField[] serialPersistentFields private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; String类中还定义了一个属性，从名字上看起来跟序列化有关吧，可能比serialVersionUID有更多的用处，这里不做过多了解了，更详细的情况参考：http://www.infoq.com/cn/articles/cf-java-object-serialization-rmi/ public static final Comparator CASE_INSENSITIVE_ORDER 这个静态常量CASE_INSENSITIVE_ORDER是一个比较器，定义如下： public static final Comparator CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator implements Comparator, java.io.Serializable { // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) { int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i 这里定义了内部类CaseInsensitiveComparator并实现了Comparator中compare(String s1, String s2)接口,这里是按照字典序进行比较。 首先确定了也比较的范围min，然后就逐个字符比较呗，分别转为大小和小写后，如果还都不相等，就返回两个char字符的差值。如果在可比较范围之内都相等，那么就返回长度的差值。 刚看到这个源码的时候我很困惑，为什么要分别进行大小写两次转换呢？看到后面才明白这个方法被应用于比较方法compareToIgnoreCase中，意思就是忽略大小写的比较。 看到这个发现一个有趣的现象，String类本身被final，属性中除了hash外都被final修饰，真的是一旦建立就无法改变。 构造函数 String最多的就是构造函数，数了一下有16个，其中两个已经废弃了。那就按照顺序一个个来学习下吧。 public String() {..} 空参数表，定义如下： public String() { this.value = \"\".value; } 把空字符串的值赋值给当前的value。 有一个问题，这个空字符串是存放在哪里么？是堆中还是常量池？学习到后面会知道，用双引号创建的字符串对象是存放在常量池中的。 public String(String original){...} 接收String类型的参数用来构造另一个String对象，定义如下： public String(String original) { this.value = original.value; this.hash = original.hash; } 有一道面试题是这样的：String str = new String（\"hello world\"）； 一共创建了几个对象？ 答案是2个对象，\"hello world\"用双引号的方式创建了一个对象，然后以这个对象为参数，又new了一个对象。 String 用双引号就可以创建对象，背后的原理就是常量池了，具体的在intern方法中有说明。 public String(char value[]){...} 接收一个字符数组作为参数，定义如下： public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } 这个地方调用了java.util.Arrays中的静态方法copyOf，该方法定义如下： public static char[] copyOf(char[] original, int newLength) { char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 而这个方法里面呢，又调用了java.lang.System中的arraycopy方法，这是一个native方法，定义如下： public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 好吧，不追究了，了解到这里就好。 public String(char value[], int offset, int count){..} 接收参数，就是拷贝出一个字符数组的一部分，定义如下: public String(char value[], int offset, int count) { if (offset >>1. if (offset > value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset+count); } 先是做了参数检查以防止越界，最后调用的是Arrays类的copyOfRange方法，该方法定义如下： public static char[] copyOfRange(char[] original, int from, int to) { int newLength = to - from; if (newLength \" + to); char[] copy = new char[newLength]; System.arraycopy(original, from, copy, 0, Math.min(original.length - from, newLength)); return copy; } 和上面的copyOf差不多过程，多了参数检查。 public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException{...} 接收四个参数，第一个是byte数组，最后一个指定编码格式，定义如下： public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException { if (charsetName == null) throw new NullPointerException(\"charsetName\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length); } 中间调用的checkBounds用来做越界检查，定义如下： private static void checkBounds(byte[] bytes, int offset, int length) { if (length bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); } public String(byte bytes[], int offset, int length, Charset charset) {...} 这个方法和上面的方法差不多，但是最后一个参数是Charset类型，这样就避免了抛出UnsupportedEncodingException异常，定义如下： public String(byte bytes[], int offset, int length, Charset charset){ if (charset == null) throw new NullPointerException(\"charset\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); } public String(byte bytes[], String charsetName){..} 这个函数省去了offset和length，实际上是默认了拷贝这个bytes数组，定义如下： public String(byte bytes[], String charsetName) throws UnsupportedEncodingException { this(bytes, 0, bytes.length, charsetName); } public String(byte bytes[], Charset charset) {..} 同样的，默认拷贝整个bytes数组，定义如下： public String(byte bytes[], Charset charset) { this(bytes, 0, bytes.length, charset); } public String(byte bytes[], int offset, int length) {..} 这个方法没有接受指定编码格式的参数，就按照默认的“ISO-8859-1”格式进行编码。 public String(byte bytes[], int offset, int length){ checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length); } public String(byte bytes[]) {..} 使用默认字符编码，拷贝整个bytes数组，定义如下： public String(byte bytes[]) { this(bytes, 0, bytes.length); } public String(StringBuffer buffer){...}和 public String(StringBuilder builder){...} StringBuffer和StringBuilder本身非常相似，区别在于前者是线程安全的，而后者不是。这一点在上面两个方法的定义中也可以体现： public String(StringBuffer buffer) { synchronized(buffer) { this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); } } public String(StringBuilder builder) { this.value = Arrays.copyOf(builder.getValue(), builder.length()); } 可以看到，前者使用了synchronized关键词，是线程安全的，而后者并没有。 String(char[] value, boolean share){...} 这里第二个参数的总是接受true，注意到之前同样有一个单接受字符数组的构造函数，但是不同的是，那个构造函数重新拷贝了一份数组再对value进行赋值，此时实例变量value和形参value指向的就是不同的两个地址，而在这个方法中，直接将形参的值赋值给实例变量，即两者的指向是相同的，这就是所谓的\"share\"。 String(char[] value, boolean share) { // assert share : \"unshared not supported\"; this.value = value; } public int length() {...} 方法用于得到String的长度，实现很简单，返回字符数组的长度即可： public int length() { return value.length; } public boolean isEmpty() {...} 用于判断字符串是否为空，实现如下： public boolean isEmpty() { return value.length == 0; } public char charAt(int index){...} 得到索引index上的字符，先要进行越界判断，然后返回字符数组下标为index上的字符，index的大小范围是[0, value.length - 1]，实现如下： public char charAt(int index) { if ((index = value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index]; } 和charAt方法类似的还有codePointAt(..)、codePointBefore(...)、codePointCount(...)之类的，很少用到，先不看了。 void getChars(char dst[], int dstBegin){...} 给定的这个方法用来拷贝字符数组的一部分，指定起点。实现如下： void getChars(char dst[], int dstBegin) { System.arraycopy(value, 0, dst, dstBegin, value.length); } public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin){...} 这个就厉害了，不光可以指定原字符数组的起点和终点，还可以指定目的字符数组的起点。当然给定这么多的参数，方法一开始先要做参数检查： public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) { if (srcBegin value.length) { throw new StringIndexOutOfBoundsException(srcEnd); } if (srcBegin > srcEnd) { throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); } System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); } public byte[] getBytes(String charsetName)throws UnsupportedEncodingException {...} 和 public byte[] getBytes(Charset charset) {...} 和 public byte[] getBytes(){...} 三个方法目的都是拷贝出byte数组。参数决定编码而已，很简单不具体说了。 public boolean equals(Object anObject){...} 有朋友面试的时候被问过手写String的equals方法，所以好好看一眼吧。 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 这里套路是这么走的：先判断是不是同一个引用，然后判断是不是String类型的实例【记住了，继承Object类的equals方法的参数是Object类型】，都OK了之后就应该判断内容是不是一致了。怎么判断呢？先判断长度，然后从前往后逐个字符比较，一旦不容就返回false。很简单，可以注意下这个比较的顺序安排，越轻松不费事的判断越要放到前面。 public int hashCode(){...} 重申那句话：重写equals方法一定也要重写hashCode方法，看看String是怎么定义hashCode方法的： public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i 用数学表达式来说就是这样的：hashCode = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]其中，n为字符串的长度，s[i]是各个位置上的字符。空字符串的hash值为0。 这个有一个问题，字符串在创建的时候，其属性hash默认为0，之后也没有看到什么地方给赋值了，只有在这个hashCode方法中给hash属性赋值了，难道这个方法如果一直不调用，hash属性就一直等于0? 在源码中打断点试验了以下，确实是这样的。没调用hashCode方法之前hash属性一直是0。 public int compareTo(String anotherString){..} 两个字符串的比较，要么返回开始不相同的位置上的字符的差值，要么返回两者的长度差值，定义如下： public int compareTo(String anotherString) { int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k public int compareToIgnoreCase(String str){...} 也是字符串的比较，但是这次忽略了两个字符串的大小写，怎么实现呢？用到了前面说的比较器 public int compareToIgnoreCase(String str) { return CASE_INSENSITIVE_ORDER.compare(this, str); } regionMatches方法 用来比较两个字符串部分区域是否一样，实现思路很简单，逐字符比较。后面的方法比前面多一个参数，意思是是否选择忽略大小写，如果不忽略，和前面的方法效果是一样的，两个函数的实现过程如下： public boolean regionMatches(int toffset, String other, int ooffset, int len) { char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1>>>1. if ((ooffset (long)value.length - len) || (ooffset > (long)other.value.length - len)) { return false; } while (len-- > 0) { if (ta[to++] != pa[po++]) { return false; } } return true; } public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) { char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1>>>1. if ((ooffset (long)value.length - len) || (ooffset > (long)other.value.length - len)) { return false; } while (len-- > 0) { char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) { continue; } if (ignoreCase) { // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) { continue; } // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) { continue; } } return false; } return true; } startsWith方法 用来判断字符串是不是以特定的字符串开头，后者调用前者。注意这里\"开头\"的意思可不一定是从0开始的，前者offset指定了偏移位置，后者则默认从0开始，前者的定义如下： public boolean startsWith(String prefix, int toffset) { char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1>>>1. if ((toffset value.length - pc)) { return false; } while (--pc >= 0) { if (ta[to++] != pa[po++]) { return false; } } return true; } public boolean endsWith(String suffix){...} 聪明的我已经猜到了，这个肯定是调用了有两个参数的startsWith方法，事实上就是这么做的。不多说了。 indexOf 和 lastIndexOf方法 套路差不多的四个函数，重载的方法之间，单个参数的调用了两个参数的方法。所以只选择一个来看下： public int indexOf(int ch, int fromIndex) { final int max = value.length; if (fromIndex = max) { // Note: fromIndex might be near -1>>>1. return -1; } if (ch 可以看到，类型检查方法决定：如果指定的起点小于0则默认从0开始，如果超出字符串上就返回-1表示找不到。然后在ch合法的情况系一个个比较字符，找到就返回下标，注意的起点是fromIndex，包含这个位置。如果字符不合法就调用indexOfSupplementary，这个方法不重要，不看了。 lastIndexOf方法差不多，不同的地方就是从后往前比较。 indexOf和lastIndexOf方法 重载了一堆，最终调用的是它： static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex 实现过程很简单，不多说了。 substring方法 取得子串，最后一个方法是实现了CharSequence接口的方法，直接调用了第二个方法。实际上第一个也是调用了第二个方法，所以来看第二个方法的定义： public String substring(int beginIndex, int endIndex) { if (beginIndex value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen 注意看的是在一些列边界检查之后，最后为了优化效果，做了一个判断，当取得的子串就是字符串本身的时候直接返回了本身的引用，而不是再去new一个新的字符串。这种优化可以学习下。 public String concat(String str){...} 在本身后面再拼接字符串，之前说过本身的属性value被final修饰，是不可改变的，所以本身不能拼接，只能往一个新的字符串数组中赋值，之后再new一个新的String。定义如下： public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); } public String replace(char oldChar, char newChar){...} 用newChar替换字符串中的oldChar，实现如下： public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i 由过程很容易看到，原来字符串本身不会有变化，方法将会返回一个替换了之后的字符串数组的副本。还可以看到，这种替换是全局的。 public boolean matches(String regex){...} 参数是正则表达式，判断字符串中是否有满足正则表达式的子串。实现如下： public boolean matches(String regex) { return Pattern.matches(regex, this); } 这里直接调用的是Pattern的静态方法matches，等看到这个类再说吧。 public boolean contains(CharSequence s){...} 判断字符串是不是含有某个子串，那好办，前面不是有indexOf方法么， 有就返回开始位置，没有就返回-1。这里只需要判断返回值是不是大于-1就行。不多说了。 replaceFirst、replaceAll和replace方法 public String replaceFirst(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceFirst(replacement); } public String replaceAll(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceAll(replacement); } public String replace(CharSequence target, CharSequence replacement) { return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString())); } 需要注意的是，这个方法的第一个参数是正则表达式，而不是字符串，有道笔试题就是用.作为第一个参数，问你结果是什么？.在正则中表示任何字符，所以当然是全部替换啦。 split方法 后者调用前者，设置第二个参数为0。前者方法中第二个参数的含义是，定义如下： public String[] split(String regex, int limit) { /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters \".$|()[{^?*+\\\\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 && \".$|()[{^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 && regex.charAt(0) == '\\\\' && (((ch = regex.charAt(1))-'0')|('9'-ch)) Character.MAX_LOW_SURROGATE)) { int off = 0; int next = 0; boolean limited = limit > 0; ArrayList list = new ArrayList<>(); while ((next = indexOf(ch, off)) != -1) { if (!limited || list.size() 0 && list.get(resultSize - 1).length() == 0) { resultSize--; } } String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); } return Pattern.compile(regex).split(this, limit); } 这里有一个快速的路径，需要满足下面几个条件： ①如果这个分隔符是单个字符串并且这个字符串是.$|()[{^?*+\\这中间的某一个 或者 ②如果这个分隔符是两个字符，并且这两个字符中第一个字符是反斜杠\"\\\"，第二个字符不是数字也不是字母也不是unicode的范围内的字符（?） 以上两种情况，满足任何一种都能够进入“快速通道”，快速通道怎么处理呢？就是匹配分隔符然后将被分割得到的子串放到list表中。那么方法的第二个参数limit是做什么的呢？ 官方的解释是： limit 参数控制模式应用的次数，因此影响所得数组的长度。如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n，而且数组的最后一项将包含所有超出最后匹配的定界符的输入。如果 n 为非正，那么模式将被应用尽可能多的次数，而且数组可以是任何长度。如果 n 为 0，那么模式将被应用尽可能多的次数，数组可以是任何长度，并且结尾空字符串将被丢弃。 为什么是这样么，我们结合一个例子来看一下： public static void main(String[] args) { String str = \"boo:and:foo\"; System.out.println(Arrays.toString(str.split(\":\", 2))); ① System.out.println(Arrays.toString(str.split(\":\", 5)));② System.out.println(Arrays.toString( str.split(\":\", -2)));③ System.out.println(Arrays.toString(str.split(\"o\", 5)));④ System.out.println(Arrays.toString(str.split(\"o\", -2)));⑤ System.out.println(Arrays.toString(str.split(\"o\", 0)));⑥ } 以上程序的输出结果是： [boo, and:foo] [boo, and, foo] [boo, and, foo] [b, , :and:f, , ] [b, , :and:f, , ] [b, , :and:f] 逐条分析： ① split是\":\"，limit是2，由于分隔符满足条件②，所以进入\"快速通道\"。在while第一次循环中，取得next是3，进入if判断，满足第二个条件，往list中存放子串boo，并将off置为next的下一个位置，即4。这时候list的长度是1。进入下一次循环，取得next的大小是7，进入if判断，两个条件都不满足，这时候进入else块，将剩下的子串一股脑地都放到list中，off也变成了原字符串的总长度，退出循环。所以最终产生的数组为[boo, and:foo]。 ② 与①不同的是，此时limit是5，在本例中list的大小最大是3，所以不会超过5-1,所以不会进入else块，而是很顺利的一直取得放到list中，最后一次分割后，退出循环，剩下的尾巴也会放到list中。 ③ 当limit是负数的时，在while循环中的if判断里，会一直满足第一个条件，永远不会进入else块，一直不断取得子串，这个过程和②差不多，最后一次分割后，退出循环，剩下的尾巴也会放到list中。 ④ split是\"o\"，limit是5， 由于分隔符满足条件②，所以进入\"快速通道\"。在while第一次循环中，取得next是1，进入if块，执行substring(0, 1)，取得\"b\"，将off置为2，下一次取得next为2，再执行substring(2, 2)，取得空字符串，将off置为3，下一次取得next为9, 执行substring(3, 9) ，取得“:and:f”，将off置为10，下一次取得next为10，执行substring(10, 10),取得空字符串，将off置为11。下一次取得next为11,执行substring(11,11)，取得空字符串；下一次取得next为-1，循环结束。 ⑤ 这个过程和④没有区别，只是if判断满足的条件不同而已。 ⑥ 前面几个过程都和一样，不一样的地方出现在if (limit == 0){...}这个判断的地方，这时候，会从后往前遍历list，碰到空字符串舍去，直到碰到一个非空字符串，所以结果是[b, , :and:f]，比起⑤的结果，少了后面的两个空字符串。 有了上面的例子，就很能理解官方解释的那段话是什么意思了，不用背下来啊，对源码有个印象就行。 join 方法 这个方法用来将多个字符串用特定的分隔符拼接起来，比如String message = String.join(\"-\", \"Java\", \"is\", \"cool\");得到的message是“Java-is-cool”。 前者接受一个不定长参数，定义如下： public static String join(CharSequence delimiter, CharSequence... elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString(); } 这里有几个类很陌生，Objects和StringJoiner都是java.util中的类，学到的时候再说。总之，不定长参数可以被解析成数组的，遍历添加到StringJoiner实例中，最后返回字符串即可。 后者接受一个迭代器Iterable，实现过程仍旧是遍历 public static String join(CharSequence delimiter, Iterable elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString(); } 过程一模一样，不说了。 toLowerCase 和 toUpperCase 方法 用来转换大小写的，源码实现不太重要，先不看了。 public String trim(){...} 这个方法返回一个去掉头尾空白格的副本字符串，实现过程很简单： public String trim() { int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st 0) || (len 这里说去掉的是“空格”好像不太严谨，源码告诉我们，去掉的字符实际上是ascii码小于等空格的字符，那哪些字符是小于这个空格的呢？参考http://www.asciima.com/， 发现是一些行开始符、换行符这种的。所以严格来说，trim方法是不仅仅去掉空格（空白的ascii码是32），而是一些看不见的字符。 public String toString(){..} 当然返回this就行了啊~ public char[] toCharArray(){...} 返回一个字符数组，诶，String类不是有一个字符数组的属性么？返回这个属性？当然不行，属性私有的，况且不可操作，当然是用System.arraycopy来复制一个副本啊。定义如下： public char[] toCharArray() { // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; } format 格式化，都是调用了java.util.Format中的方法，各自定义如下： public static String format(String format, Object... args) { return new Formatter().format(format, args).toString(); } public static String format(Locale l, String format, Object... args) { return new Formatter(l).format(format, args).toString(); } 就是用“%s”作为占位符，然后在第二个参数中指定参数。注意，由于占位符是用百分号写的，所以如果这个字符串中本来就有百分号的话怎么办呢？用转义，即\"%%\"。 valueOf方法 这个方法重载太多了并且实现很简单，所以就放到一起说了. 方法参数 内容 Object obj return (obj == null) ? \"null\" : obj.toString(); char data[] return new String(data); char data[], int offset, int count return new String(data, offset, count); boolean b return b ? \"true\" : \"false\"; char c char data[] = {c}; return new String(data, true); int i Integer.toString(i); long l return Long.toString(l); float f return Float.toString(f); double d return Double.toString(d); public native String intern(); 最厉害的来了！无数题的考点啊！【敲黑板！！！】而且是native方法，不追踪了，有精力可以参考http://www.importnew.com/14142.html 研究下。 这个方法有一段注释我觉得有必要贴上来： /** * Returns a canonical representation for the string object. * * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * The Java&trade; Language Specification. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ 讲的很明白了，String维护这一个常量池，最开始是空的。当intern方法被触发的时候，会先常量池中根据equals方法先寻找是不是存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。那什么时候创建的对象放到常量池中，什么时候创建的对象放到堆中呢？ 以下两种情况创建的字符串对象会放到常量池中： 直接使用双引号声明出来的String对象会直接存储在常量池中。 直接使用intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。 诶，到这里就想起来一道题目，问String hello = \"dog\"; String lili = \"dog\";那么hello == lili的值是什么？有了上面的知识储备，答案很显然是true，因为helo是用双引号的方式创建的字符串，对象放在常量池中，当仍用双引号创建对象，所以会从常量池中找，发现“dog”这个值已经被创建过了，所以返回引用。所以啊hello和lili指向的是常量池中的同一个对象，结果当然是true。 注意啊，intern这个方法是一个实例方法，这个方法最后返回的是常量池中的引用，那么问题来了例如： String s = new String(\"1\"); s.intern(); 执行之后，s引用指向的到底是堆地址呢还是常量池中的地址呢？堆地址！此时s指向的是堆中的地址，而该地址中存储的string的内容指向了常量池。有点绕，可以打开下面链接，里面的图画的很明白了。 JDK1.6和1.7版本对intern方法的解释不一样，归根到底是由于1.7调整了常量池的位置，http://www.importnew.com/14142.html 这篇博文讲的很详细了。我就不再抄一遍了。 看到链接的博客评论里有一个实例，我模仿写了下面的代码（环境1.8）： String string=new String(\"ttt\" ) ;① string.intern();② String adString=\"ttt\"; ③ System.out.println(string==adString); // false String s5 = new String(\"aa\") + new String(\"a\");④ s5.intern(); ⑤ String s6 = \"aaa\"; ⑥ System.out.println(s5 == s6); //true 为什么打印出false 和true呢。 对于①，最终会创建出两个对象：常量池中的\"ttt\"和堆中的\"ttt\"。②的作用是去常量池中寻找是否存在\"ttt\"，结果是存在。③用双引号创建，去常量池中寻找\"ttt\"，找到了，所以adString引用的是常量池中的地址。所以string和adString分别指向了堆和常量池，当然不相等。 对于④，最终创建了三个对象：常量池中的“aa”、常量池中的\"a\"和堆中的\"aaa\"。当⑤去常量池中寻找”aaa\"的时候发现没有，但是堆中有啊，所以直接引用了堆中的地址。当⑥用双引号创建对象的时候在常量池中找到了这个引用的地址，所以最终s5和s6引用的对象是同一个，所以相等返回true。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 10:54:23 "},"源码解读/java.lang/StringBuilder.html":{"url":"源码解读/java.lang/StringBuilder.html","title":"StringBuilder","keywords":"","body":"StringBuilder 和 AbstractStringBuilder 趁着刚学习完String的热乎劲，接着学StringBuilder吧。老规矩先上结构图： 终于可以截全了（其实没有，还差一个serialVersionUID，不过这个不要紧了） 可以看到除了构造方法之外，其他方法都是覆盖了其父类AbstractStringBuilder的方法。所以在学习StringBuilder之前还是先学习下AbstractStringBuilder抽象类，其结构图如下: abstract class AbstractStringBuilder implements Appendable, CharSequence AbstractStringBuilder是一个抽象类，实现了Appendable接口和CharSequence接口。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 定义了能接受的最大字符数目。 char[] value; 这个是真正用来存储字符的地方，一开始没有分配存储空间。 int count; 用来计数，计算当前已经存储了多少个字符。 AbstractStringBuilder(){...} 和 AbstractStringBuilder(int capacity){...} 两个重载的构造方法，前者方法体是空的，后者接受参数指定初始化空间大小，定义如下： AbstractStringBuilder(int capacity) { value = new char[capacity]; } public int length(){...} 用来返回字符长度，直接返回count值就可以了。 才注意到，value和count都没有修饰符，包内访问。 public int capacity() {...} 返回的是空间总长度，定义如下： public int capacity() { return value.length; } 这个时候要搞清楚count和value.length的区别了，前者是真正存储的字符的个数，后者是分配的总空间大小。 public void ensureCapacity(int minimumCapacity){...} 这个方法确保容量至少等于指定的最小值。定义如下： public void ensureCapacity(int minimumCapacity) { if (minimumCapacity > 0) ensureCapacityInternal(minimumCapacity); } 当参数为正数的时候，调用ensureCapacityInternal方法，否则什么也不做就返回。ensureCapacityInternal方法定义如下： private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code if (minimumCapacity - value.length > 0) { value = Arrays.copyOf(value, newCapacity(minimumCapacity)); } } 如果这个方法接受的参数是负数，那么会抛出OutOfMemoryError错误，当然在现在我们讨论的这个范围内，不会有这个错误。从定义中可以看出，当实际的长度小于参数的时候，会给value重新分配地址，这个调用的newCapacity方法定义如下： private int newCapacity(int minCapacity) { // overflow-conscious code int newCapacity = (value.length 从这个方法可以看出，容量的增长呈现1，4，10，22，...这种趋势，乘法和加法一块使用，可以在前期增长的快一些，后期则基本是两倍关系。这里还调用了hugeCapacity，定义如下： private int hugeCapacity(int minCapacity) { if (Integer.MAX_VALUE - minCapacity MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE; } 什么作用？前面说道，value的最大空间大小不能超过MAX_ARRAY_SIZE的大小。 public void trimToSize() {...} 用于该字符序列的方法尝试减少存储。如果缓冲区大于必要保持其当前的字符序列，那么它可能会调整大小，以成为更有效的空间。 简单来说，就是讲value.length的值变成count，怎么变？拷贝一个副本赋值给value就行，定义如下： public void trimToSize() { if (count public void setLength(int newLength) {...} 设置的字符序列的长度。该序列被改变到一个新的字符序列的参数所指定的长度。定义如下： public void setLength(int newLength) { if (newLength 这里调用了前面介绍的ensureCapacityInternal方法，扩充之后，用'\\0'填充字符数组，然后将count置为新长度。 public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin){...} 和 public void setCharAt(int index, char ch) {...} 这两个方法和String的就很像了，都是在进行越界检查后把字符数组中的某位返回或置位。方法略。 append方法 重载太多了，最重要的是下面这种: public AbstractStringBuilder append(String str) { if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; } 如果传入了null对象的话，调用appendNull方法，定义如下： private AbstractStringBuilder appendNull() { int c = count; ensureCapacityInternal(c + 4); final char[] value = this.value; value[c++] = 'n'; value[c++] = 'u'; value[c++] = 'l'; value[c++] = 'l'; count = c; return this; } 嗯？直接在后面加上字符串\"null\"，我以为会啥也不添加就返回，这是什么骚操作？？？为什么要这样？ 这个方法中还发现一个考点啊。value用final修饰但是居然可以改变值！不是说final修饰的量不变么？诶这里就对”不变“这个词没有弄明白意思了，final修饰的是对象引用的话，引用的地址不能变，但是没有说这个地址里的内容不能改变啊。那既然这样，为什么还要中间定义一个value的局部变量呢？直接给this.value添加四个字符不就完了？？？ 没有弄明白这个设计的用意。 append重载的方法太多了，套路都是一个：改变长度，保障长度，数组拷贝赋值。不一一列出了。 public AbstractStringBuilder deleteCharAt(int index){...} 方法用于删除某个位置上的字符，定义如下： public AbstractStringBuilder deleteCharAt(int index) { if ((index = count)) throw new StringIndexOutOfBoundsException(index); System.arraycopy(value, index+1, value, index, count-index-1); count--; return this; } 可以看到arraycopy方法的源数组和目的数组都是value本身，厉害了。贪吃蛇式的赋值。 public AbstractStringBuilder replace(int start, int end, String str) {...} 替换某段位置上的字符，定义如下： public AbstractStringBuilder replace(int start, int end, String str) { if (start count) throw new StringIndexOutOfBoundsException(\"start > length()\"); if (start > end) throw new StringIndexOutOfBoundsException(\"start > end\"); if (end > count) end = count; int len = str.length(); int newCount = count + len - (end - start); ensureCapacityInternal(newCount); System.arraycopy(value, end, value, start + len, count - end); str.getChars(value, start); count = newCount; return this; } 注意这里的arraycopy和getChars方法配合的很巧妙，比如原来value的值是['h', 'e', 'l', 'l', 'o']，想要在'e'和两个'l'的位置换成\"me\"，那么就是怎么调用的： System.arraycopy(value, 4，value, 1 + 2, 1);结果value变成['h', 'e', 'l', 'o', 'o']; 接着执行str.getChars(value, 1),就是讲str复制到value数组中1开始的位置，最后变成['h', 'm', 'e', o, 'o']， 接着count值就变成 5 + 2 - （4 - 1） = 4，只取字符数组前4个就行。这样避免了数组元素的移动，很奇妙。 public String substring(int start, int end){...} 以字符串形式返回部分字符数组的内容，定义如下： public String substring(int start, int end) { if (start count) throw new StringIndexOutOfBoundsException(end); if (start > end) throw new StringIndexOutOfBoundsException(end - start); return new String(value, start, end - start); } insert方法 往字符数组中插入字符，重载的方法很多，大都是转为String类型后调用下面这个方法的： public AbstractStringBuilder insert(int offset, String str) { if ((offset length())) throw new StringIndexOutOfBoundsException(offset); if (str == null) str = \"null\"; int len = str.length(); ensureCapacityInternal(count + len); System.arraycopy(value, offset, value, offset + len, count - offset); str.getChars(value, offset); count += len; return this; } 这里同样学习下arraycopy和getChars两者配合使用的奇妙之处。 indexOf 和 lastIndexOf 方法本质上和String中的同名方法一样，不细说了。 public AbstractStringBuilder reverse(){...} 这应该是非常有用的方法了：倒置。 实现如下：（不知道那个版本的，反正不是1.8） public AbstractStringBuilder reverse() { //是否含代理字符 //高代理highSurrogate和低代理lowSurrogate概念请另查询char与Unicode字符 boolean hasSurrogate = false; //定义一个变量表示长度-1 int n = count - 1; //j初始化，长度-2再算术右移一位 j = (count-2)/2 //偶数长度，遍历一半次数，对调替换 //奇数长度，遍历一半-1次数，对调替换，中间值不用替换 for (int j = (n-1) >> 1; j >= 0; --j) { char temp = value[j]; char temp2 = value[n - j]; //如果无代理 if (!hasSurrogate) { hasSurrogate = (temp >= Character.MIN_SURROGATE && temp = Character.MIN_SURROGATE && temp2 平常也有经常遇到倒置的问题，从这个源码中希望可以获得启发。 public abstract String toString(); 没有方法体。 final char[] getValue(){...} 返回字符数组value就行。略。 StringBuilder StringBuilder除了构造方法和不常用的两个方法(writeObject和readObject)外，其他方法都是覆盖了AbstractStringBuilder，并且实现很简单，多是调用父类方法。这里只介绍下构造方法就行。 public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 还是从类声明开始，类被final修饰，表示不能被继承。类继承了AbstractStringBuilder抽象类，实现了Serializable接口和CharSequence接口。 构造方法 StringBuilder定义了四种构造方法， public StringBuilder() {..} 无参数构造方法，定义如下： public StringBuilder() { super(16); } 无参的StringBuilder构造方法默认了初始大小为16。 为什么用16这个数字呢？ public StringBuilder(int capacity){...} 接收指定空间大小初始化，定义如下： public StringBuilder(int capacity) { super(capacity); } public StringBuilder(String str) {...} 接收字符串为参数，定义如下： public StringBuilder(String str) { super(str.length() + 16); append(str); } 将初始化的空间大小定位字符串的长度再加上16。 public StringBuilder(CharSequence seq) {...} 接收CharSequence对象作为参数，定义与上面的方法类似，不多说了。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 15:26:31 "},"源码解读/java.lang/StringBuffer.html":{"url":"源码解读/java.lang/StringBuffer.html","title":"StringBuffer","keywords":"","body":"StringBuffer StringBuffer经常和StringBuilder混到一起讲，先来看看结构： 从结构可以看出来StringBuffer和StringBuilder确实师承一脉，那么两者的区别在什么地方。 public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence 和StringBuilder 一样，继承AbstractStringBuilder，实现Serializable和CharSequence接口。 构造函数 三个构造函数，分别接受无参、初始容量和String类型参数，默认的初始容量是16。 private transient char[] toStringCache; 注意到StringBuffer中的这个成员变量，在StringBuilder中并没有，那么这个变量的作用是什么？官方解释是：由toString返回的最后一个值得缓存。每当StringBuffer被修改的时候清空。 从哪里体现呢？看看toString方法的定义： @Override public synchronized String toString() { if (toStringCache == null) { toStringCache = Arrays.copyOfRange(value, 0, count); } return new String(toStringCache, true); } 可以看到，在返回字符串之前，先在toStringCache中缓存了值。 那么在一些需改StringBuffer内容的函数中，比如append、replace、delete等，toStringCache都是被置为null，比如： @Override public synchronized void setCharAt(int index, char ch) { if ((index = count)) throw new StringIndexOutOfBoundsException(index); toStringCache = null; value[index] = ch; } 线程安全 StringBuffer和StringBuilder最重要的区别在什么地方？常听到这样的回答： \"StringBuffer是线程安全的，而StringBuilder不是线程安全的\" 答案正确，那么源码中哪里有体现呢？ 虽然StringBuffer和StringBuilder师承一脉，但是StringBuffer大部分对内容进行修改的方法上都有synchronized关键词的修饰，当然有些操作并没有synchronized修饰，为什么搞特殊？这些方法都有是三行特别的注释，比如： public StringBuffer insert(int dstOffset, CharSequence s) { // Note, synchronization achieved via invocations of other StringBuffer methods // after narrowing of s to specific type // Ditto for toStringCache clearing super.insert(dstOffset, s); return this; } 这里解释说这些方法的同步化是通过调用其他StringBuffer方法来实现的。但是我看着这源码，调用的是父类的方法，并没有实现同步啊？怎么肥四？？？ Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 15:30:37 "},"源码解读/java.lang/Class.html":{"url":"源码解读/java.lang/Class.html","title":"Class","keywords":"","body":"Class Class真的很重要啊，年少无知的我听到\"反射\"一词就很烦躁，但是反射基本是所有厉害的Java框架的基础，结构如： 在阅读源码之前，我们了解下基本概念，Class到底是什么？Class是一个类，跟Java API中定义的诸如Thread、Integer没有什么两样。类是对一类事物的抽象，那么Class抽象了什么呢？它的实例又代表了什么呢？ 在一个运行的程序中，会有许多的类和接口存在。我们用Class来表示对这些类和接口的抽象，而Class类的每个实例则代表了运行中的一个类。例如，运行的程序有ABC三个类，那么Class类就是对ABC三个类的抽象。所谓抽象，就是提取这些类的一个公共特征，比如这些类都有类名，都有对应的hashcode方法，可以判断类型是属于class、interface、enum还是annotation，这些可以封装成Class类的域，另外可以定义一些方法，比如获取某个方法、获取类型名字等等，这样就封装了一个表示类型(type)的类。 Java中，每个类class都有一个相应的Class，也就是说，当我们编写一个类，编译完成之后，在生成的.class文件中，就会产生一个Class对象，用于表示这个类的信息。运行程序时，JVM首先检查是否要加载的类对应的Class对象是否已经加载，如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。虚拟机只会产生一份字节码，用这份字节码可以产生多个实例对象。 特别的是，8种基本数据类型和void关键字也都对应了一个Class对象；每个数组属于被映射为Class对象的一个类，所有具有相同元素类型和维数的数组都共享该Class对象。 一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。 public final class Class implements java.io.Serializable, GenericDeclaration,Type, AnnotatedElement 看到类声明，Class是一个终类，且是一个泛型类。实现了Serializable、GenericDeclaration、Type和AnnotatedElement接口。 后三个接口有点陌生啊，他们都在java.lang.reflect子包中，这个包与反射机制密切相关。GenericDeclaration可以声明类型变量的实体的公共接口，也就是说，只有实现了该接口才能在对应的实体上声明（定义）类型变量，这些实体目前只有三个：Class（类）、Constructor(构造器)、Method(方法) 这个接口只有一个方法： public TypeVariable[] getTypeParameters(); 用来返回实体声明（定义）的所有类型变量，测试程序参考 http://blog.csdn.net/a327369238/article/details/52710827 Type接口是Java变成语言中所有类型的公共高级接口。也只有一个方法： default String getTypeName() { return toString(); } 这里的default是可访问性修饰符么，相当于为空？？？ AnnotatedElement接口表示目前正在此 VM 中运行的程序的一个已注释元素。定义的方法如下： java.lang.reflect这个子包很重要，详情见专门的博客，这里就不喧宾夺主了。 private static native void registerNatives(); 这句话就很熟悉了，在Object中看到过，当时是通过静态初始块来执行这个私有方法的，同样的，在Class类中也是这样，后面跟着一个静态初始块。 private static native void registerNatives(); static { registerNatives(); } private Class(ClassLoader loader){...} 诶这就怪了，网上看到的大部分说Class没有构造方法，不能手动创建，为什么源码里明明就有构造方法啊？ 网上的说法不准确，Class不能手动创建对象的原因并不是没有构造方法，而是因为构造方法是private，不能调用。准确的说是：“Class类没有公共构造方法”。Class对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass方法自动构造的。这个私有的构造方法怎么定义的呢？ /* * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */ private Class(ClassLoader loader) { // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; } 接收一个ClassLoader类型的参数，赋值给自己的属性classLoader，它是这么声明的： // Initialized in JVM not by private constructor // This field is filtered from reflection access, i.e. getDeclaredField // will throw NoSuchFieldException private final ClassLoader classLoader; 那么这个参数又是怎么回事呢?等下回我们分析ClassLoader这个类的时候再说吧。 说道这里，我们知道ClassLoader对象由自己创建，但是反射机制就是通过类对象来操作类啊，我们还必须得得到这个类对象才行!既然不能自己创建，那么能不能获取呢。可以的，有三种来获取Class对象。 通过某个对象的getClass()方法 还记得Object类的源码么？里面的getClass方法就是用来获取类对象的。比如Class userClass = new User().getClass(); 通过Class类的静态方法forName方法来获取 这个方法的定义如下：@CallerSensitive public static Class forName(String className) throws ClassNotFoundException { Class caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); } 这里有个JVM注解@CallerSensitive，作用可以参考http://blog.csdn.net/hel_wor/article/details/50199797 还有 http://blog.csdn.net/aguda_king/article/details/72355807， 这个方法中调用了Reflection的静态方法，具体怎么实现我也不追究了（主要是好复杂啊 (⊙﹏⊙)b）。反正可以获取到就行了，注意这里可能会抛出异常。 forName还有两个重载的方法，不常用就不说了。 通过类名。如果T是一个Java类型，那么T.class就代表了匹配的类对象。 例如： public class ClassTest { public static void main(String[] args) { Class userClass = User.class; System.out.println(userClass.getName());//JavaLangJarTest.User Class cls1 = int.class; System.out.println(cls1.getName()); //int Class cls2 = double.class; System.out.println(cls2.getName()); //double Class cls3 = Double[].class; System.out.println(cls3.getName()); //Ljava.lang.Double; Double[] doubleArr = new Double[10]; Class cls4 = doubleArr.getClass(); System.out.println(cls4.getName());//Ljava.lang.Double; System.out.println(cls4 == cls3); // true Double[] doubleArr2 = new Double[11]; Class cls5 = doubleArr2.getClass(); System.out.println(cls4 == cls5); //true } } 上面的测试程序可以验证这几点： ①基本数据类型也对应了各自的类对象，也就是说Class对象实际上描述的只是类型，而这类型未必是类或接口。 ②相同类型的数组对象的类对象是同一个； ③由于历史原因，数组类型的getName方法会返回奇怪的名字，比如上面的Ljava.lang.Double; public String getName(){...} 这个方法在前面用到了，方法将以字符串的行驶返回此Class对象所表示的实体(类、接口、数组类、基本类型或void)完整 名称。方法定义如下: public String getName() { String name = this.name; if (name == null) this.name = name = getName0(); return name; } 这里this.name可以看到Class本身有一个属性，定义如下： private transient String name; 这个属性被transient关键词修饰，说明不参与序列化。而当this.name是null的时候，调用了getName0方法，这个方法的定义如下： private native String getName0(); 又是一个native方法，好吧不管这么多了，反正最后一定可以得到name。 记住Enum是类，而Annotation是接口。 public T newInstance() throws InstantiationException, IllegalAccessException{...} 这个方法就常用了，使用类对象来创建对象，←_← 嗯 好像是没有说错。定义如下： @CallerSensitive public T newInstance() throws InstantiationException, IllegalAccessException { if (System.getSecurityManager() != null) { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false); } // NOTE: the following code may not be strictly correct under // the current Java memory model. // Constructor lookup if (cachedConstructor == null) { if (this == Class.class) { throw new IllegalAccessException( \"Can not call newInstance() on the Class for java.lang.Class\" ); } try { Class[] empty = {}; final Constructor c = getConstructor0(empty, Member.DECLARED); // Disable accessibility checks on the constructor // since we have to do the security check here anyway // (the stack depth is wrong for the Constructor's // security check to work) java.security.AccessController.doPrivileged( new java.security.PrivilegedAction() { public Void run() { c.setAccessible(true); return null; } }); cachedConstructor = c; } catch (NoSuchMethodException e) { throw (InstantiationException) new InstantiationException(getName()).initCause(e); } } Constructor tmpConstructor = cachedConstructor; // Security check (same as in java.lang.reflect.Constructor) int modifiers = tmpConstructor.getModifiers(); if (!Reflection.quickCheckMemberAccess(this, modifiers)) { Class caller = Reflection.getCallerClass(); if (newInstanceCallerCache != caller) { Reflection.ensureMemberAccess(caller, this, null, modifiers); newInstanceCallerCache = caller; } } // Run constructor try { return tmpConstructor.newInstance((Object[])null); } catch (InvocationTargetException e) { Unsafe.getUnsafe().throwException(e.getTargetException()); // Not reached return null; } } private volatile transient Constructor cachedConstructor; private volatile transient Class newInstanceCallerCache; 哎好长好烦躁，总之这个方法是调用了默认构造器（无参数）构造器初始化新建对象。这里需要注意两点：① 如果类本身没有定义无参构造方法但是定义的有参构造方法，这时候是无法默认产生无参构造方法的，所以这时候用newInstance方式来创建对象的话，会抛出InstantiationException异常。所所以一个好的编程习惯是给类手动定义一个无参的构造方法。②newInstance方法返回的是Object对象，需要进行类型转换。 public String toString() {...} public String toString() { return (isInterface() ? \"interface \" : (isPrimitive() ? \"\" : \"class \")) + getName(); } isPrimitive方法是判断是不是基本类型。 在类名之前加上类型，是类的就加上\"class\"，是接口的就加上\"interface\", 是基本类型的就什么都不加。前面说到Enum是类，Annotation是接口，我们来验证一下： Class cls1 = Enum.class; System.out.println(cls1.toString()); //class java.lang.Enum Class cls2 = Annotation.class; System.out.println(cls2.toString()); //interface java.lang.annotation.Annotation 结果很明显啦~ public ClassLoader getClassLoader(){...} 用来获取该类的类加载器，至于获得了之后干什么，母鸡啊~ @CallerSensitive public ClassLoader getClassLoader() { ClassLoader cl = getClassLoader0(); if (cl == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); } return cl; } // Package-private to allow ClassLoader access ClassLoader getClassLoader0() { return classLoader; } // Initialized in JVM not by private constructor // This field is filtered from reflection access, i.e. getDeclaredField // will throw NoSuchFieldException private final ClassLoader classLoader; 其他一些常用的方法 还有一些常用的方法，源码实现就略过了，只是讲下作用和使用示例。 方法 作用 使用示例 public Field[] getFields() throws SecurityException{...} 反射中获得public域成员，包括父类 Field[] fields = String.class.getFields();for (Field field : fields){ System.out.print(field.toString()); //public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER } public Field getField(String name) throws NoSuchFieldException, SecurityException{..} 反射中获得特定名称public域成员，可能会抛出异常 public Field[] getDeclaredFields() throws SecurityException{...} 反射中获得所有域成员，不限访问控制符，但只能是自己的，不包括父类， public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException{...} 反射中获得特定名称的域成员，可能会抛出异常 public Method[] getMethods(){...} 获得方法 getConstructors() {...} 获得所有的构造方法 public Method getDeclaredMethod(String name, Class... parameterTypes){...} 加个Declared代表本类，继承，父类均不包括。 public native Class getSuperclass(); 获取类的父类，继承了父类则返回父类，否则返回java.lang.Object。返回Object的父类为空-null。 Class superClass = String.class.getSuperclass(); System.out.println(superClass.getName()); // java.lang.Object public Package getPackage() {...} 反射中获得package Package classPackage = String.class.getPackage(); System.out.println(classPackage.toString()); //package java.lang, Java Platform API Specification, version 1.8 public Class[] getInterfaces(){...} 获得类实现的接口 Class[] classImplements = String.class.getInterfaces(); for (Class cls : classImplements){System.out.print(cls.getName() + \" \"); //java.io.Serializable java.lang.Comparable java.lang.CharSequence } public native int getModifiers(); 反射中获得修饰符，如public， static ,void等， 注意这里的返回类型是int int modifier = String.class.getModifiers(); System.out.println(modifier); // 17 public boolean isEnum() 判断是否是枚举类型 public native boolean isArray() 判断是否是数组类型 public native boolean isPrimitive() 判断是否是基本类型 public boolean isAnnotation() 判断是否是注解类型 网上找到一些具体是操作例子可以参考下： http://blog.csdn.net/sd4000784/article/details/7448221 http://blog.csdn.net/liushuijinger/article/details/15378475 参考： 深入研究java.lang.Class类 java Class类 java Class 类简介 理解java.lang.Class类 我眼中的Java-Type体系（1） 菜鸟学Java（十五）——Java反射机制（二) 菜鸟学Java（十四）——Java反射机制（一) Java基础加强--17.利用反射操作泛型VI Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 14:17:49 "},"源码解读/java.lang/ClassLoader.html":{"url":"源码解读/java.lang/ClassLoader.html","title":"ClassLoader","keywords":"","body":"ClassLoader 在阅读Class类的时候看到Class类的私有构造方法的参数是一个ClassLoader对象，这到底是个什么东西，感觉很高大上，这个类的结构如下： Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-04 17:46:30 "},"源码解读/java.lang/Throwable.html":{"url":"源码解读/java.lang/Throwable.html","title":"Throwable","keywords":"","body":"Throwable Throwable是Java中异常类的顶级父类，有必要看看源码实现。类的结构如下： public class Throwable implements Serializable 首先看到类的声明，实现了Serializable，表示可以序列化，实现这个接口的类通常还会有一个常量serialVersionUID。 private transient Object backtrace; 这个变量上面有一行注释Native code saves some indication of the stack backtrace in this slot.，表明本地代码在这个变量中保存了堆栈回溯的一些指示。注意到的是这个变量被关键词transient修饰，表示在序列化的时候序列该变量。transient一般用来修饰一些敏感的变量，比如用户的密码，内存堆栈信息等。 private String detailMessage; 这个变量描述此异常的信息，比如如果抛出FileNotFoundException，那么这个变量就会是未找到的文件的名字。 private Throwable cause = this; 表示当前异常由那个Throwable引起，在初始化的时候指向了自己本身。如果为null表示此异常不是由其他Throwable引起的或者原因未知，如果此对象与自己相同,表明此异常的起因对象还没有被初始化 private static final StackTraceElement[] UNASSIGNED_STACK = new StackTraceElement[0]; 对这个变量的解释是:空堆栈的共享值。而对于StackTraceElement这个类，其结构如下： 可以看到其定义的成员变量：declaringClass、methodName、fileName、lineNumber共同定义堆栈轨迹。 private StackTraceElement[] stackTrace = UNASSIGNED_STACK; 这是真正保存栈轨迹的地方，初始化成上面提到的UNASSIGNED_STACK，可以使用实例getStackTrace()获取该数组，使用实例方法etStackTrace或者fillInStackTrace来填充数组。 私有静态内部类SentinelHolder Throwable中定义了一个内部类，如下： private static class SentinelHolder { /** * {@linkplain #setStackTrace(StackTraceElement[]) Setting the * stack trace} to a one-element array containing this sentinel * value indicates future attempts to set the stack trace will be * ignored. The sentinal is equal to the result of calling: * {@code new StackTraceElement(\"\", \"\", null, Integer.MIN_VALUE)} */ public static final StackTraceElement STACK_TRACE_ELEMENT_SENTINEL = new StackTraceElement(\"\", \"\", null, Integer.MIN_VALUE); /** * Sentinel value used in the serial form to indicate an immutable * stack trace. */ public static final StackTraceElement[] STACK_TRACE_SENTINEL = new StackTraceElement[] {STACK_TRACE_ELEMENT_SENTINEL}; } 这个类暂时还没有搞清楚是怎么回事。 private static final List SUPPRESSED_SENTINEL = Collections.unmodifiableList(new ArrayList(0)); private List suppressedExceptions = SUPPRESSED_SENTINEL; 这个变量是从JDK1.7开始加入的。 一些静态常量 /** Message for trying to suppress a null exception. */ private static final String NULL_CAUSE_MESSAGE = \"Cannot suppress a null exception.\"; /** Message for trying to suppress oneself. */ private static final String SELF_SUPPRESSION_MESSAGE = \"Self-suppression not permitted\"; /** Caption for labeling causative exception stack traces */ private static final String CAUSE_CAPTION = \"Caused by: \"; /** Caption for labeling suppressed exception stack traces */ private static final String SUPPRESSED_CAPTION = \"Suppressed: \"; 构造函数 Throwable有四种构造函数， public Throwable(){..} 无参构造函数，定义如下： public Throwable() { fillInStackTrace(); } 发现直接调用了成员方法fillInStackTrace，其定义如下： public synchronized Throwable fillInStackTrace() { if (stackTrace != null || backtrace != null /* Out of protocol state */ ) { fillInStackTrace(0); stackTrace = UNASSIGNED_STACK; } return this; } 方法用synchronized修饰，所以是线程同步的。方法中首先判断stackTrace和backtrace其中有没有不是null的，任何一个方法非null表明什么呢？说明栈中已经有内容，然后调用具有参数的fillInStackTrace方法，定义如下： private native Throwable fillInStackTrace(int dummy); 这是一个native方法，dummy这个参数的意思目前还不了解。总之是调用了吧，然后给stackTrace赋值，最后返回的是对象本身，但是在调用者那里，并没有使用到这个返回值。 public Throwable(String message){...} public Throwable(String message) { fillInStackTrace(); detailMessage = message; } 多了一个给detailMessage赋值的过程。 public Throwable(String message, Throwable cause){...} public Throwable(String message, Throwable cause) { fillInStackTrace(); detailMessage = message; this.cause = cause; } public Throwable(Throwable cause) {... 定义如下自己看： public Throwable(Throwable cause) { fillInStackTrace(); detailMessage = (cause==null ? null : cause.toString()); this.cause = cause; } 其中toString的定义如下： public String toString() { String s = getClass().getName(); String message = getLocalizedMessage(); return (message != null) ? (s + \": \" + message) : s; } 其中getLocalizedMessage方法定义如下： public String getLocalizedMessage() { return getMessage(); } 而getMessage实际上直接返回成员变量detailMessage： public String getMessage() { return detailMessage; } protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {...} JDK 1.7 中引入的构造方法， protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { if (writableStackTrace) { fillInStackTrace(); } else { stackTrace = null; } detailMessage = message; this.cause = cause; if (!enableSuppression) suppressedExceptions = null; } public synchronized Throwable getCause() {...} 该方法是一个同步方法，用来获取造成Throwable的cause，定义如下： public synchronized Throwable getCause() { return (cause==this ? null : cause); } 方法会返回造成Throwable的cause或者null，后者是因为原因未知或者不存在。cause什么时候被赋值呢？这个变量是私有成员变量，在初始化的时候赋值为this，即指向自己本身。后面可以通过构造方法或者initCause()方法进行赋值。所以如果cause仍旧等于自己，说明变量这个引起异常的对象并没有被初始化，这个时候返回null。 public synchronized Throwable initCause(Throwable cause){...} 这就是上面getCause方法中提到的initCause方法，定义如下： public synchronized Throwable initCause(Throwable cause) { if (this.cause != this) throw new IllegalStateException(\"Can't overwrite cause with \" + Objects.toString(cause, \"a null\"), this); if (cause == this) throw new IllegalArgumentException(\"Self-causation not permitted\", this); this.cause = cause; return this; } 提到当一个Throwable对象初始化的时候，cause是被赋值为this的，并且后面只能再被赋值一次，这个方法就解释为什么只能赋值一次：this.cause != this就会抛出异常，此时说明cause已经被赋值过了，必能再赋值进行覆盖。并且这次赋值不能再把自身作为参数。所以，这个方法最多只能被调用一次，通常在构造函数中被调用，如果调用的是Throwable(Throwable)或者Throwable(String,Throwable)这种构造方法，由于在构造方法中已经对cause进行赋值，所以这个方法不会再被调用。这个方法有到底怎么用呢？可以看下面这个例子： 首先定义三个异常类 public class ExceptionA extends Exception { public ExceptionA(String str) { super(); } } public class ExceptionB extends ExceptionA { public ExceptionB(String str) { super(str); } } public class ExceptionC extends ExceptionA { public ExceptionC(String str) { super(str); } } 执行下面这个程序： public class NeverCaught { static void f() throws ExceptionB{ throw new ExceptionB(\"exception b\"); } static void g() throws ExceptionC { try { f(); } catch (ExceptionB e) { ExceptionC c = new ExceptionC(\"exception a\"); throw c; } } public static void main(String[] args) { try { g(); } catch (ExceptionC e) { e.printStackTrace(); } } } 结果是： /* exception.ExceptionC at exception.NeverCaught.g(NeverCaught.java:12) at exception.NeverCaught.main(NeverCaught.java:19) */ 发现只打印了ExceptionC而没有打印出ExceptionB呢？原因是在实例化ExceptionC的时候调用的方法是Exceotion(String)方法。这种情况叫做“异常链”丢失，少了一个异常，在我们的排错过程中非常不利。这时候就用到了initCause方法：保存异常信息，在抛出另一个异常的同时不丢失原来的异常： public class NeverCaught { static void f() throws ExceptionB{ throw new ExceptionB(\"exception b\"); } static void g() throws ExceptionC { try { f(); } catch (ExceptionB e) { ExceptionC c = new ExceptionC(\"exception a\"); //异常链 c.initCause(e); throw c; } } public static void main(String[] args) { try { g(); } catch (ExceptionC e) { e.printStackTrace(); } } } 其中c.initCause保持了异常链的完整性，当然其实可以采取ExceptionC c = new ExceptionC(\"exception a\", e)这种构造方法来使异常链完整的。注意 Throwable中cause只能被赋值一次。 printStackTrace方法 定义了三种printStackTrace方法，第一种无参数： public void printStackTrace() { printStackTrace(System.err); } 其中调用了以PrintStream对象作为参数的printStackTrace方法，定义如下： public void printStackTrace(PrintStream s) { printStackTrace(new WrappedPrintStream(s)); } 其中调用了以WrappedPrintStream对象作为参数的printStackTrace方法，定义如下： private void printStackTrace(PrintStreamOrWriter s) { // Guard against malicious overrides of Throwable.equals by // using a Set with identity equality semantics. Set dejaVu = Collections.newSetFromMap(new IdentityHashMap()); dejaVu.add(this); synchronized (s.lock()) { // Print our stack trace s.println(this); StackTraceElement[] trace = getOurStackTrace(); for (StackTraceElement traceElement : trace) s.println(\"\\tat \" + traceElement); // Print suppressed exceptions, if any for (Throwable se : getSuppressed()) se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, \"\\t\", dejaVu); // Print cause, if any Throwable ourCause = getCause(); if (ourCause != null) ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, \"\", dejaVu); } } 输出到System.err，首先第一行调用toString方法，输出异常的类名和message(如果有的话)。接着调用getOurStackTrace，这个方法是做什么的？ private synchronized StackTraceElement[] getOurStackTrace() { // Initialize stack trace field with information from // backtrace if this is the first call to this method if (stackTrace == UNASSIGNED_STACK || (stackTrace == null && backtrace != null) /* Out of protocol state */) { int depth = getStackTraceDepth(); stackTrace = new StackTraceElement[depth]; for (int i=0; i 其中getStackTraceDepth方法是一个native方法，可以看到实际上它是拷贝了一份StackTraceElement的内容，之后循环打印出内容然后调用了getSuppressed方法，定义如下： public final synchronized Throwable[] getSuppressed() { if (suppressedExceptions == SUPPRESSED_SENTINEL || suppressedExceptions == null) return EMPTY_THROWABLE_ARRAY; else return suppressedExceptions.toArray(EMPTY_THROWABLE_ARRAY); } 这里将会返回一个包含所有被抑制的异常数组，如果没有被一直的异常或者这个异常本身由Throwable(String, Throwable, boolean, boolean)方法创建，倒数第二个参数是false，也就是被抑制的异常不显示出来，此时返回的是一个空数组。 这之后的printEnclosedStackTrace又是怎么回事， private void printEnclosedStackTrace(PrintStreamOrWriter s, StackTraceElement[] enclosingTrace, String caption, String prefix, Set dejaVu) { assert Thread.holdsLock(s.lock()); if (dejaVu.contains(this)) { s.println(\"\\t[CIRCULAR REFERENCE:\" + this + \"]\"); } else { dejaVu.add(this); // Compute number of frames in common between this and enclosing trace StackTraceElement[] trace = getOurStackTrace(); int m = trace.length - 1; int n = enclosingTrace.length - 1; while (m >= 0 && n >=0 && trace[m].equals(enclosingTrace[n])) { m--; n--; } int framesInCommon = trace.length - 1 - m; // Print our stack trace s.println(prefix + caption + this); for (int i = 0; i 过程好复杂看不懂，反正就是打印了呗。 最后打印cause，同样是一个复杂的过程，不看了。 可以看到除了第一行，后面的打印形式是依据具体的实现的，下面有几种典型的情况： class MyClass { public static void main(String[] args) { crunch(null); } static void crunch(int[] a) { mash(a); } static void mash(int[] b) { System.out.println(b[0]); } } 执行程序打印出以后的结果： java.lang.NullPointerException at MyClass.mash(MyClass.java:9) at MyClass.crunch(MyClass.java:6) at MyClass.main(MyClass.java:3) 可以看到这里抛出了空指针异常，后面打印了StackTraceElement的内容。 再看下面这个例子： public class Junk { public static void main(String args[]) { try { a(); } catch(HighLevelException e) { e.printStackTrace(); } } static void a() throws HighLevelException { try { b(); } catch(MidLevelException e) { throw new HighLevelException(e); } } static void b() throws MidLevelException { c(); } static void c() throws MidLevelException { try { d(); } catch(LowLevelException e) { throw new MidLevelException(e); } } static void d() throws LowLevelException { e(); } static void e() throws LowLevelException { throw new LowLevelException(); } } class HighLevelException extends Exception { HighLevelException(Throwable cause) { super(cause); } } class MidLevelException extends Exception { MidLevelException(Throwable cause) { super(cause); } } class LowLevelException extends Exception { } 执行main方法将出现以下结果： HighLevelException: MidLevelException: LowLevelException at Junk.a(Junk.java:13) at Junk.main(Junk.java:4) Caused by: MidLevelException: LowLevelException at Junk.c(Junk.java:23) at Junk.b(Junk.java:17) at Junk.a(Junk.java:11) ... 1 more Caused by: LowLevelException at Junk.e(Junk.java:30) at Junk.d(Junk.java:27) at Junk.c(Junk.java:21) ... 3 more 可以看到，main方法最终会执行到e()该方法会抛出LowLevelException异常，这个类调用的是父类无参构造方法，也就是其创建的时候没有给cause赋值。而向上抛出异常的过程中，都调用的是以cause为参数的构造方法，将上一个以上当做cause,所以可以看到MidLevelException和HighLevelException的toString方法不单单打印了类名，还有getMessage的值。 注意上面代码中包含...的行，这些表示堆栈跟踪的其余部分。异常匹配是从底部指定的帧数 这个例子打印的是cause数组的值，那么“被抑制的异常”是什么意思呢？suppressedExceptions是Java 7的新特性，在try-with-resources语法中调用close()方法的时候，如果此时出现异常，那么值之前出现的异常被叫做Suppressed Exceptions。Throwable类中有一个addSuppressed方法可以将它保存起来，定义如下： public final synchronized void addSuppressed(Throwable exception) { if (exception == this) throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE, exception); if (exception == null) throw new NullPointerException(NULL_CAUSE_MESSAGE); if (suppressedExceptions == null) // Suppressed exceptions not recorded return; if (suppressedExceptions == SUPPRESSED_SENTINEL) suppressedExceptions = new ArrayList<>(1); suppressedExceptions.add(exception); } 当用户捕捉到close里抛出的异常时，就可以调用Throwable.getSuppressed函数来取出close之前的异常了，这个方法定义如下： public final synchronized Throwable[] getSuppressed() { if (suppressedExceptions == SUPPRESSED_SENTINEL || suppressedExceptions == null) return EMPTY_THROWABLE_ARRAY; else return suppressedExceptions.toArray(EMPTY_THROWABLE_ARRAY); } 一个典型的例子如下： Exception in thread \"main\" java.lang.Exception: Something happened at Foo.bar(Foo.java:10) at Foo.main(Foo.java:5) Suppressed: Resource$CloseFailException: Resource ID = 0 at Resource.close(Resource.java:26) at Foo.bar(Foo.java:9) ... 1 more 如果一个异常兼有一个cause和多个suppressedExceptions，那么它的打印结果可能是这样的： Exception in thread \"main\" java.lang.Exception: Main block at Foo3.main(Foo3.java:7) Suppressed: Resource$CloseFailException: Resource ID = 2 at Resource.close(Resource.java:26) at Foo3.main(Foo3.java:5) Suppressed: Resource$CloseFailException: Resource ID = 1 at Resource.close(Resource.java:26) at Foo3.main(Foo3.java:5) Caused by: java.lang.Exception: I did it at Foo3.main(Foo3.java:8) 同样的,suppressedExceptions也可能含有cause， Exception in thread \"main\" java.lang.Exception: Main block at Foo4.main(Foo4.java:6) Suppressed: Resource2$CloseFailException: Resource ID = 1 at Resource2.close(Resource2.java:20) at Foo4.main(Foo4.java:5) Caused by: java.lang.Exception: Rats, you caught me at Resource2$CloseFailException.&lt;init&gt;(Resource2.java:45) ... 2 more private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException{...} private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); // read in all fields if (suppressedExceptions != null) { List suppressed = null; if (suppressedExceptions.isEmpty()) { // Use the sentinel for a zero-length list suppressed = SUPPRESSED_SENTINEL; } else { // Copy Throwables to new list suppressed = new ArrayList<>(1); for (Throwable t : suppressedExceptions) { // Enforce constraints on suppressed exceptions in // case of corrupt or malicious stream. if (t == null) throw new NullPointerException(NULL_CAUSE_MESSAGE); if (t == this) throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE); suppressed.add(t); } } suppressedExceptions = suppressed; } // else a null suppressedExceptions field remains null /* * For zero-length stack traces, use a clone of * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to * allow identity comparison against UNASSIGNED_STACK in * getOurStackTrace. The identity of UNASSIGNED_STACK in * stackTrace indicates to the getOurStackTrace method that * the stackTrace needs to be constructed from the information * in backtrace. */ if (stackTrace != null) { if (stackTrace.length == 0) { stackTrace = UNASSIGNED_STACK.clone(); } else if (stackTrace.length == 1 && // Check for the marker of an immutable stack trace SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(stackTrace[0])) { stackTrace = null; } else { // Verify stack trace elements are non-null. for(StackTraceElement ste : stackTrace) { if (ste == null) throw new NullPointerException(\"null StackTraceElement in serial stream. \"); } } } else { // A null stackTrace field in the serial form can result // from an exception serialized without that field in // older JDK releases; treat such exceptions as having // empty stack traces. stackTrace = UNASSIGNED_STACK.clone(); } } private synchronized void writeObject(ObjectOutputStream s) throws IOException{...} private synchronized void writeObject(ObjectOutputStream s) throws IOException { // Ensure that the stackTrace field is initialized to a // non-null value, if appropriate. As of JDK 7, a null stack // trace field is a valid value indicating the stack trace // should not be set. getOurStackTrace(); StackTraceElement[] oldStackTrace = stackTrace; try { if (stackTrace == null) stackTrace = SentinelHolder.STACK_TRACE_SENTINEL; s.defaultWriteObject(); } finally { stackTrace = oldStackTrace; } } 接下来所有行输出了由fillInStackTrace方法执行的结果。 参考： Java异常处理机制 Java7里try-with-resources分析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-14 14:27:24 "},"源码解读/java.lang/Exception.html":{"url":"源码解读/java.lang/Exception.html","title":"Exception","keywords":"","body":"Exception 我们经常自定义的类一般都是直接继承这个类，该类结果如下： 结构简单哭了，只有四种构造方法。 public class Exception extends Throwable 类声明，可以看到Exception类直接继承了Throwable类。并且Exception定义的四种构造方法实际上是直接调用了父类的四种构造方法。 源码中有段注释解释了这个类的用途： /** * The class {@code Exception} and its subclasses are a form of * {@code Throwable} that indicates conditions that a reasonable * application might want to catch. * * The class {@code Exception} and any subclasses that are not also * subclasses of {@link RuntimeException} are checked * exceptions. Checked exceptions need to be declared in a * method or constructor's {@code throws} clause if they can be thrown * by the execution of the method or constructor and propagate outside * the method or constructor boundary. * * @author Frank Yellin * @see java.lang.Error * @jls 11.2 Compile-Time Checking of Exceptions * @since JDK1.0 */ 首先第一段里说了Exception是合理的应用程序想要捕获的条件。 第二段里说了，Exception子类中，RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类，RuntimeException的子类需要被写到throws子句中，而除此之外的Exception子类，他们是checked exceptions。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-14 11:12:27 "},"源码解读/java.lang/Error.html":{"url":"源码解读/java.lang/Error.html","title":"Error","keywords":"","body":"Error 结构如下： 和隔壁Exception一样，方法只定义了四种构造方法 public class Error extends Throwable 类声明， Error类直接继承了Throwable类。所以在异常机制中，Error和Exception是同等地位的，两者不同在哪里？注意到，源码中对Error有一段注释解释了Error类的用途： /** * An {@code Error} is a subclass of {@code Throwable} * that indicates serious problems that a reasonable application * should not try to catch. Most such errors are abnormal conditions. * The {@code ThreadDeath} error, though a \"normal\" condition, * is also a subclass of {@code Error} because most applications * should not try to catch it. * * A method is not required to declare in its {@code throws} * clause any subclasses of {@code Error} that might be thrown * during the execution of the method but not caught, since these * errors are abnormal conditions that should never occur. * * That is, {@code Error} and its subclasses are regarded as unchecked * exceptions for the purposes of compile-time checking of exceptions. * * @author Frank Yellin * @see java.lang.ThreadDeath * @jls 11.2 Compile-Time Checking of Exceptions * @since JDK1.0 */ 第一段话的意思是：Error用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然ThreadDeath错误是一个“正规”的条件，但它也是Error的子类，因为大多数应用程序都不应该试图捕获它。在执行该方法期间，无需在其 throws 子句中声明可能抛出但是未能捕获的 Error 的任何子类，因为这些错误可能是再也不会发生的异常条件。 大概的意思就是，Error总是不可控的（unchecked），经常用来用于表示系统错误或低层资源的错误，如何可能的话，应该在系统级被捕捉。 很少用到Error类及其子类，在看源码的过程中有遇到AssertionError。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-19 23:26:47 "},"源码解读/java.lang/RuntimeException.html":{"url":"源码解读/java.lang/RuntimeException.html","title":"RuntimeException","keywords":"","body":"RuntimeException 结构如下： public class RuntimeException extends Exception 类声明， RuntimeException继承了Exception类，四种构造方法全部调用了父类Exception的四种构造方法。 源码对RuntimeException的解释如下： /** {@code RuntimeException} is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine. * {@code RuntimeException} and its subclasses are unchecked exceptions. Unchecked exceptions do not need to be declared in a method or constructor's {@code throws} clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary. * @author Frank Yellin @jls 11.2 Compile-Time Checking of Exceptions @since JDK1.0 */ 可以看到RuntimeException的子在JVM运行的时候会被抛出，它们属于unchecked exceptions，这类异常需要在子句throws中声明。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-14 11:20:33 "},"源码解读/java.lang/Thread.html":{"url":"源码解读/java.lang/Thread.html","title":"Thread","keywords":"","body":"Thread 线程很重要！很重要！很重要！重要的话说三遍，然后我一直以来都闹不明白多线程是怎么回事，看了很多仍然是雾里看花，不知道这次能不能打通任督二脉。 Thread类的结构如上。 public class Thread implements Runnable 首先是类声明，可以看到Thread类实现了Runnable接口，这个接口是做什么的呢 @FunctionalInterface public interface Runnable { /** * When an object implementing interface Runnable is used * to create a thread, starting the thread causes the object's * run method to be called in that separately executing * thread. * * The general contract of the method run is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 一个实现Runnable接口的子类需要重写run方法。但是不能直接调动重写过的run()来实现多线程，因为对于JVM来说，run方法就只是一个普通的方法。那该怎么启动呢？到后面可以看到，Thread类有一个构造方法：public Thread(Runnable targer)，此构造方法接受Runnable的子类实例，也就是说可以通过Thread类来启动Runnable实现的多线程。（start可以协调系统的资源）。 @FunctionalInterface注解表明这是一个函数接口，这是Java 8的新特性，更多内容参见\"Java 8新特性/@FunctionalInterface注解\"。 private static native void registerNatives(); 诶这个就有点熟悉了，在Object类中见到过，本地注册方法，怎么调用这个方法呢？跟Object类中一样的处理方式，在静态构造块中调用。 static { registerNatives(); } 构造方法 Thread类定义了9种构造方法，但是实质都是把形参类别再传递给init方法，所以只用看无参构造方法就够了。定义如下： public Thread() { init(null, null, \"Thread-\" + nextThreadNum(), 0); } 方法中调用的是init方法，该方法定义如下： private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } 而这个方法调用的是是另外一个重载init的方法，定义如下： private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 我们根据上面这个init整个连起来看一下。 首先是对name的赋值，name是Thread类的实例方法，声明如下： private volatile String name; 注意被volatile关键词修饰，说明这个变量值可能被好几个线程更改。 将形参name的值赋给该属性，形参name是字符串\"Thread-\" 和方法 nextThreadNum()返回值的拼接,与这个方法有关的定义如下： private static int threadInitNumber; private static synchronized int nextThreadNum() { return threadInitNumber++; } 注意到这个方法是被synchronized修饰，线程安全，返回的是类变量threadInitNumber的值，之后自增一次，注意是类变量，也就是说，每个进程中开启的线程都会被安排一个整型变量，从0开始编号，最后进行字符串拼接，赋值给name，最终这些name可能是Thread-0、Thread-1...，如果这个形参name是null的话，将会抛出NullPointerException。 接着Thread parent = currentThread();这句话调用了静态方法currentThread： public static native Thread currentThread(); native方法，从名字就能知道这个方法用来获取当前线程。 接下来，SecurityManager security = System.getSecurityManager();获取Java安全管理器，接下来是对变量g的赋值过程，变量g是什么？线程组，一个线程组管理很多线程。g的初始值为null，所以会进入if语句块中，首先尝试让Java安全组件给g赋值，如果不行，那么就将这个新创建的线程加入到当前线程的线程组中。 你说加入就加入？当然不行，后面还有一系列的检查balabala，现在看不懂，学到ThreadGroup的时候再说。 之后就愉快地把g这个值赋值给成员变量group了，这个成员变量定义如下： private ThreadGroup group; 接下来这句this.daemon = parent.isDaemon();，daemon是实例属性，定义为 private boolean daemon = false; 这个变量标识这个线程是否为“守护线程”，什么是守护线程？ 守护线程是指在程序运行的时候再后台提供的一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此当所有的非守护线程结束时，程序也就结束了，同时会杀死进程中所有的守护线程。反过来说，只有任何非守护线程还在运行，程序就不会中止。 更多关于守护线程的内容参考\"Java基础知识整理/多线程\" 可以看到，新建的这个线程的该属性被赋值为当前线程的daemon属性值，那我们可以得出结论：从daemon线程中产生的线程也是daemon线程。 接下来执行this.priority = parent.getPriority();这句话，priority变量声明如下： private int priority; 注意到时int型变量，getPriority方法定义如下： public final int getPriority() { return priority; } 所以新建的线程与当前线程的优先级保持一致？不，优先级这事还没完，后面还有招。 接着往下是给contextClassLoader和inheritedAccessControlContext两个变量赋值，涉及到Java安全体系，看不太懂，先不管了。 接下来给target变量赋值，该变量声明如下： private Runnable target; 自带run方法而来。 接下来就是设定priority了，setPriority方法定义如下： public final void setPriority(int newPriority) { ThreadGroup g; checkAccess(); if (newPriority > MAX_PRIORITY || newPriority g.getMaxPriority()) { newPriority = g.getMaxPriority(); } setPriority0(priority = newPriority); } } 这个方法首先进行参数合法性判断，Thread类定义了三种线程优先级： /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; priority只有三种取值，不得超出范围。接下来，新线程的优先级不得大于线程组中的最大优先级，如果超出了，将会被重新调整为线程组的最大优先级。怎么调整？调用setPriority0方法，这是一个native方法，不多讲了。 接下来设定inheritableThreadLocals这个值不知道在干什么了，/(ㄒoㄒ)/~~ 然后设定stackSize的值，在这个无参构造方法中，将其设置为0。 接下来设定变量tid的值，调用nextThreadID方法，定义如下： private static synchronized long nextThreadID() { return ++threadSeqNumber; } 其中这个threadSeqNumber这个变量是一个静态变量private static long threadSeqNumber; 有一个问题?这个变量和之前说到的threadInitNumber这个变量有什么区别么？现在我能分辨的区别是：threadInitNumber是在name中是从0开始的，而threadSeqNumber在被操作的第一个值是1。做了一个实验： public static void main(String[] args) { Thread thread = new Thread(); System.out.print(thread.toString()); } debug得到的thread的内容如下： 可以看到name值是“Thread-0”，而tid却是12，为什么？？？不应该是从1开始么？ 总结一下，创建一个线程的过程中都做了下面这些事： 命名：Thread-1 加入ThreadGroup，如果在构造方法中指定线程组，那么就加入以当前父线程所在的线程组。父线程的获取方法是currentThread()。 设定是否是守护线程，新线程与父线程的参数保持一致。即父线程如果是守护线程，那么新线程也是守护线程。 设定优先级。新线程的优先级将与父线程保持一致，但是不能超过所在线程组的最高优先级。 void blockedOn(Interruptible b) {...} public synchronized void start(){...} 这个方法太重要了， public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } 开发者调动start方法，然后再由JVM调用run方法，注意这两个方法的调用者是不同的。该方法首先判断线程状态，必须是0否则抛出异常，为什么是0？threadStartFailed这个变量的声明为:private volatile int threadStatus = 0;发现这个变量被volatile关键词修饰，所以这个量将来会多个线程改变。 接着group.add(this)将通知这个线程所属的线程组：这个线程已经准备好了哦，线程组将这个线程添加到线程数组里面，然后把数量加上1，具体的还是学到ThreadGroup的时候看吧。 之后调用了start0方法，这是一个native方法，如果这个方法抛出异常，那么线程组将会移除这个线程，并且将相应的计数器nUnstartedThreads增加1，但是在这个方法中对异常不作处理，把这个异常抛给调用者。 public void run(){...} @Override public void run() { if (target != null) { target.run(); } } run方法才是真正线程执行的逻辑。Thread实现了Runnable接口，所以重写了run方法。但是可以看到Thread的run方法本身调用的target的run方法，target是什么？是实现Runnable接口的类的实例。所以啊，要创建线程实现自己的run逻辑，可以有以下两种方法。 自定义类继承Thread，重写run()方法覆盖父类（强制），实例化该类，调用start方法。 public class ThreadTest { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); for (int j = 0; j 自定义类继承Runnable接口，重写run()方法（非强制），实例化该类，以此为参数创建Thread对象，调用start方法。 public class RunableTest { public static void main(String[] args) { MyThread1 myThread = new MyThread1(); Thread a = new Thread(myThread); Thread b = new Thread(myThread); Thread c = new Thread(myThread); a.start(); b.start(); c.start(); } } class MyThread1 implements Runnable{ @Override public void run() { for (int i = 0; i 上面两种方式都可以创建线程，而且结果相差不多，但是最好是第二种，为什么呢？因为现实问题中创建线程的目的是为了让多个线程来执行同一个任务，并且这多个线程还共享同一个资源，这种需求可以使用实现Runable接口的方式来实现多线程任务，但是不能通过扩展Thread类是无法实现的。比如下面这个例子： public class RunableTest { public static void main(String[] args) { MyThread m=new MyThread(); Thread t1=new Thread(m,\"Thread 1\"); Thread t2=new Thread(m,\"Thread 2\"); Thread t3=new Thread(m,\"Thread 3\"); t1.start(); /*共运行一百次， 三条线程哪条抢到资源就运行哪条 */ t2.start(); t3.start(); } } class MyThread implements Runnable{ private int i=0; @Override public void run() { while(i 两种方式的优劣总结如下： 继承 Thread 类 实现Runnable接口 优点 编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。 线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 缺点 因为线程类已经继承了Thread类，所以不能再继承其他的父类。 编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。 实现Callable接口 Callable是JUC中新加入的接口，主要和线程池一起使用。具体的使用方法可以参见博文\"多线程\"。 Thread对象可以操纵一个线程，而Runable对象代表一个可被运行的对象。 private void exit() {...} 这个方法也是被JVM调用的，在真正退出之前给线程一个清理的机会？为什么清理？垃圾回收啊~ private void exit() { if (group != null) { group.threadTerminated(this); group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; } 可以看到把引用全部置为null，还通知所属的线程组结束掉该线程。 public static native void yield(); yield本身是native方法，实现细节不得而知。那这个方法有什么作用呢？单词\"yield\"的意思是“屈服、放弃”，Thread.yield( )方法经常被翻译成“线程让步”，它会把自己的CPU执行时间让掉，让自己或者其他线程运行。从线程的状态转化角度看，它能够让当前线程从运行状态变为就绪状态，这时候它就和别的处于就绪状态的线程一样了，下一次能不能被调度完全取决于OS，它并没有什么优势。那么这些线程中优先级高的就有优势么？没有，只是被挑中的概率高一点而已，也有可能是优先级低的抢到了。 sleep方法 sleep会导致当前线程进入睡眠状态，即阻塞状态。有两个重载的方法。下面是两个参数的sleep方法： public static void sleep(long millis, int nanos) throws InterruptedException { if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } sleep(millis); } 第一个参数单位是毫秒，第二个参数的单位是纳秒，为什么这么设计？这种写法在之前Object里的wait()方法中见过，为了更精确地控制等待时间。最后调用的是一个参数的sleep方法，定义如下： public static native void sleep(long millis) throws InterruptedException; 这个一个native方法，怎么实现不要深纠了。 sleep这个方法是静态方法，所以方法调用的形式是Thread.sleep()，另外注意，使用该方法需要捕获InterruptedException异常。还有一点非常非常非常重要。在源码中被明确说明： The thread does not lose ownership of any monitors. 当前线程不会失去任何的锁！！！即如果当前线程持有某个对象锁，在它sleep的这段时间内，锁还是由他保有的，不会被释放掉。 join方法 thread.join方法把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。什么意思呢？原来A和B线程是交替进行的，此时在B线程中调用的a.join()，那么直到线程A执行完毕之后，才会继续执行B，这样原本并发的线程就串行了。有三个重载方法，核心是下面这个： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis 从代码中可以可以看到，如果线程被生成了，但是还没有被启动，即isAlive返回false，此时调用join是没有作用的，将直接继续往下执行。 还可以看到，join方法实际上是调用了Object的wait方法实现的。当main线程调用t.join的时候，main线程将会获得线程对象t的锁（wait意味着拿到了该对象的锁），调用该对象的wait(等待时间)，直到该对象唤醒main线程。比如退出后，这就意味着main线程调用t.join时，必须能够拿到线程t对象的锁。 一个非常好的例子可以说明join方法的作用。 首先看下面的程序： public class ThreadTest implements Runnable { public static int i = 0; @Override public void run() { for (int k = 0; k 请问会输出5么？答案是：有可能，但是大部分情况下都不会是5，当然这和机器有很大的关系。为什么？因为这里其实有两个线程，主线程main和main中产生的线程t，当主线程main执行System.out.println(a)这句的时候，线程t还没有真正开始运行，或许正在为它分配资源，这需要时间啊。而主线程执行到打印语句的时候a还没有改变，这时候当然输出0啊？那我怎么才能让程序输出5呢，那当然是让主线程main等待t线程执行完之后再打印。用join方法就可以做到了。 如下： public class ThreadTest implements Runnable { public static int i = 0; @Override public void run() { for (int k = 0; k 由于在main线程中调用了t的join方法，所以主线程必须等待t线程结束后才能继续。 join方法可以有参数，表示等待的时间，无指定的时候默认为0，表示无期限等待下去。做下面这个实验： public class ThreadTest implements Runnable { @Override public void run() { try { System.out.println(\"Begin sleep\"); Thread.sleep(1000); System.out.println(\"End sleep\"); }catch (InterruptedException e){ e.printStackTrace(); } } public static void main(String[] args) throws Exception{ Runnable r = new ThreadTest(); Thread t = new Thread(r); t.start(); try { System.out.println(\"JoinBegin\"); t.join(1000); System.out.println(\"JoinFinish\"); }catch (InterruptedException e){ e.printStackTrace(); } } } 打印的结果是： JoinBegin Begin sleep JoinFinish End sleep 如果run中的sleep的参数改成2000，打印的结果就是下面这种： JoinBegin Begin sleep JoinFinish End sleep 可见，等待是有期限的，到点了我就往下进行了，不管t到什么时候结束。 一个更加复杂的例子： class CustomThread1 extends Thread { public void run() { String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" start.\"); try { for (int i = 0; i 输出的结果如下： main start. //main方法所在的线程起动，但没有马上结束，因为调用t.join();，所以要等到t结束了，此线程才能向下执行。 [CustomThread1] Thread start. //线程CustomThread1起动 [CustomThread1] Thread loop at 0 //线程CustomThread1执行 [CustomThread1] Thread loop at 1 //线程CustomThread1执行 [CustomThread] Thread start. //线程CustomThread起动，但没有马上结束，因为调用t1.join();，所以要等到t1结束了，此线程才能向下执行。 [CustomThread1] Thread loop at 2 //线程CustomThread1继续执行 [CustomThread1] Thread loop at 3 //线程CustomThread1继续执行 [CustomThread1] Thread loop at 4 //线程CustomThread1继续执行 [CustomThread1] Thread end. //线程CustomThread1结束了 [CustomThread] Thread end. // 线程CustomThread在t1.join();阻塞处起动，向下继续执行的结果 main end! //线程CustomThread结束，此线程在t.join();阻塞处起动，向下继续执行的结果。 如果将t.join()注释掉，那么打印结果如下： main start. // main方法所在的线程起动，但没有马上结束，这里并不是因为join方法，而是因为Thread.sleep(2000); [CustomThread1] Thread start. //线程CustomThread1起动 [CustomThread1] Thread loop at 0 //线程CustomThread1执行 [CustomThread1] Thread loop at 1 //线程CustomThread1执行 main end! // Thread.sleep(2000);结束，虽然在线程CustomThread执行了t1.join();，但这并不会影响到其他线程(这里main方法所在的线程)。 [CustomThread] Thread start. //线程CustomThread起动，但没有马上结束，因为调用t1.join();，所以要等到t1结束了，此线程才能向下执行。 [CustomThread1] Thread loop at 2 //线程CustomThread1继续执行 [CustomThread1] Thread loop at 3 //线程CustomThread1继续执行 [CustomThread1] Thread loop at 4 //线程CustomThread1继续执行 [CustomThread1] Thread end. //线程CustomThread1结束了 [CustomThread] Thread end. // 线程CustomThread在t1.join();阻塞处起动，向下继续执行的结果 此外，main线程在调用join方法的时候，必须能够拿到线程t对象的锁，如果拿不到是无法wait的，刚才的例子t.join(1000)不是为了main线程等待1秒，如果在让等待之前，其他线程获取了t对象的锁，那么它等待的时间可就不是1秒了。例如： class RunnableImpl implements Runnable { public void run() { try { System.out.println(\"Begin sleep\"); Thread.sleep(2000); System.out.println(\"End sleep\"); } catch (InterruptedException e) { e.printStackTrace(); } } } class ThreadTest extends Thread { Thread thread; public ThreadTest(Thread thread) { this.thread = thread; } @Override public void run() { synchronized (thread) { System.out.println(\"getObjectLock\"); try { Thread.sleep(9000); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\"ReleaseObjectLock\"); } } } public class JoinTest { public static void main(String[] args) { Thread t = new Thread(new RunnableImpl()); new ThreadTest(t).start(); t.start(); try { t.join(); System.out.println(\"joinFinish\"); } catch (InterruptedException e) { e.printStackTrace(); } } } 输出结果是： getObjectLock Begin sleep End sleep ReleaseObjectLock joinFinish 在main方法中 通过new ThreadTest(t).start()实例化 ThreadTest 线程对象， 它通过synchronized (thread) ，获取线程对象t的锁，并Sleep（9000）后释放，这就意味着，即使main方法t.join(1000)等待一秒钟，它必须等待ThreadTest 线程释放t锁后才能进入wait方法中，它实际等待时间是9000+1000ms。 public void interrupt(){...} 定义如下： public void interrupt() { if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; } } interrupt0(); } 这里面有些变量需要解释一下。blockerLock是Thread类的一个私有常量private final Object blockerLock = new Object();，其实就是一个对象实例，而blocker是一个实例变量：private volatile Interruptible blocker;。而interrupt0是一个native方法。 源码中对该方法有这样的解释 中断线程。 如果当前线程没有中断它自己（这在任何情况下都是允许的），则该线程的 checkAccess 方法就会被调用，这可能抛出 SecurityException。 如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。 如果该线程在可中断的通道上的 I/O 操作中受阻，则该通道将被关闭，该线程的中断状态将被设置并且该线程将收到一个 ClosedByInterruptException。 如果该线程在一个 Selector 中受阻，则该线程的中断状态将被设置，它将立即从选择操作返回，并可能带有一个非零值，就好像调用了选择器的 wakeup 方法一样。 如果以前的条件都没有保存，则该线程的中断状态将被设置。 过程还是看不懂啊，那就先记住结论吧。 interrupt()不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态；如果线程没有被阻塞，这时调用interrupt()将不起作用；否则，线程就将得到异常（该线程必须事先预备好处理此状况），接着逃离阻塞状态。 线程A在执行sleep，wait,join时,线程B调用A的 interrupt方法，的确这一个时候A会有 InterruptedException异常抛出来。但这其实是在sleep，wait，join这些方法内部会不断检查中断状态的值,而自己抛出的InterruptedException。 如果线程A正在执行一些指定的操作时如赋值，for，while，if调用方法等，都不会去检查中断状态,所以线程A不会抛出InterruptedException,而会一直执行着自己的操作。 当线程A终于执行到wait()，sleep()，join()时，才马上会抛出InterruptedException。若没有调用sleep()，wait()，join()这些方法,或是没有在线程里自己检查中断状态自己抛出InterruptedException的话,那InterruptedException是不会被抛出来的. \"中断\"的意思并不是让线程停止（而stop方法则是让线程终止），而只是改变了线程的状态，至于改变了这种状态之后，线程是死亡？继续？还是怎样，完全视线程本身而定。有时候这种中断反而不是阻止，反而是让其继续执行，比如一个正发生死锁的线程，中断它才能让它继续执行。 每个线程实例都有一个boolean类型标记，表示这个线程是否被请求中断，当其interrupt方法被调用的时候，这个boolean状态位会置为true。调用了某个线程a的中断方法interrupt()，一定会让线程a停下来么？不一定，因为这个方法只是把标志位的状态改变了，并没有真正kill掉线程。那么这个状态的变化有什么用呢？当然有用，如果该线程正处于阻塞状态（比如等待阻塞、同步阻塞或者睡眠阻塞等），处于这种状态的线程是会不断检查这个标志位的，一旦检查到了这个标注为被标注为true，则抛出InterruptedException，同时清楚这个标志位为false。这时候线程就从阻塞状态被唤醒了，至于被唤醒之后要做什么，完全看线程本身的实现。如果线程正在运行着，它是不会检查这个标志位的，也就是说，即使标志位设为true，它也能照常运行。 上面说到wait的线程如果发现状态位为true了，将被唤醒，和notify与notifyAll的效果类似，有什么不同呢？不同之处就在于try-catch块了：如果线程是被notify或者notifyAll唤醒的，那么紧接着wait方法之后的语句会照常执行，而如果是被中断唤醒的话，那么就会直接进入catch语句，这就是普通的异常捕获过程，没什么难理解的。 举一个例子：程序开始让一个线程sleep一年，但是你反悔了，那么此时调用interrupted方法将是唤醒这个线程的唯一办法。同理，wait、join也是同样的道理，特别注意的是，synchronized在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断。与synchronized功能相似的reentrantLock.lock()方法也是一样，它也不可中断的，即如果发生死锁，那么reentrantLock.lock()方法无法终止，如果调用时被阻塞，则它一直阻塞到它获取到锁为止。但是如果调用带超时的tryLock方法reentrantLock.tryLock(long timeout, TimeUnit unit)，那么如果线程在等待时被中断，将抛出一个InterruptedException异常，这是一个非常有用的特性，因为它允许程序打破死锁。你也可以调用reentrantLock.lockInterruptibly()方法，它就相当于一个超时设为无限的tryLock方法。这一点要牢记。 interrupt方法是JVM来中断线程的一个武器，有商量的余地，效果还是比较温和的。JVM还提供了几个杀伤力巨大的武器，由于杀伤力太大，会殃及无辜，所以都废弃了，但是还是学习一下。这些武器有：stop、suspend。 首先是stop方法，这个方法已经被废弃了，千万别用了，因为执行这个方法将会立即杀死一个线程，将其锁执有的锁全都释放，导致本该被锁控制同步的所有位置变得无法控制。会产生无法预计的问题，这妥妥的是一场灾难。 其次是suspend方法，这个方法还是可用的但是尽量别用，官方的说法是可能导致死锁。代替这个方法的是wait和notify方法。 其实学习过之后就忘了吧。脑子就这么大，记多了容易混~~~ public static boolean interrupted(){...} public static boolean interrupted() { return currentThread().isInterrupted(true); } 测试当前线程是否已经中断。线程的中断状态也由该方法清除。也就是说，如果连续两次调用该方法，那么第一次调用时，如果当前线程已经处于中断状态，那么该方法会返回true，同时清除当前线程被标记的中断状态。第二次调用时，（第二次调用之前，没有再次调用Thread.currentThread().interrupt();）就会返回false了。 其中isInterrupted方法定义如下： private native boolean isInterrupted(boolean ClearInterrupted); 该方法用来测试线程是否已经中断。线程的中断状态 不受该方法的影响。 如果该线程已经中断，则返回 true；否则返回 false。和interrupted方法不同的是，这个方法不具有清除状态的功能。 要特别注意静态方法interrupted方法和实例方法isInterrupted的区别 比如下面这个例子： public static void main(String[] args) { /** * 这种方式中断线程，因为isInterrupted方法并没有中断线程的功能， * 所以当发生中断的时候，日志会输出异常信息，然后while循环退出， */ new Thread(new Runnable() { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { log.error(\"error\", e); } } System.out.println(\"子线被打断执行\"); } }).start(); } 而正确的做法是： public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { while (!Thread.currentThread().isInterrupted()){ try { TimeUnit.SECONDS.sleep(5); }catch (InterruptedException e){ log.error(\"error\", e); } } System.out.println(\"子线程被打断执行\"); } }); thread.start(); thread.interrupt(); } } public final native boolean isAlive(); 用来检测线程时候还活着，只要线程状态处于start和die之间，都是活着的状态。 public static int activeCount(){...} 获得当前线程组中的活跃的线程数。定义如下： public static int activeCount() { return currentThread().getThreadGroup().activeCount(); } public static int enumerate(Thread tarray[]){...} 将活动线程拷贝到一个数组 public static int enumerate(Thread tarray[]) { return currentThread().getThreadGroup().enumerate(tarray); } ThreadLocalMap和ThreadLocal /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 参考： 创建线程的两种方式区别 Thread.interrupted()与Thread.isInterrupted()的区别 Thread类的interrupt,interrupted,isInterrupted方法的理解 Java多线程sleep(),join(),interrupt(),wait(),notify() Java多线程中join方法的理解!!! Thread的中断机制(interrupt) 线程 Java线程同步小陷阱，你掉进去过吗 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-14 14:39:43 "},"源码解读/java.lang/ThreadGroup.html":{"url":"源码解读/java.lang/ThreadGroup.html","title":"ThreadGroup","keywords":"","body":"ThreadGroup 在学习到Thread类的时候，发现线程实际上分组，即每个线程被创建的时候，会有一个属性threadgroup来表示这个线程是属于哪个组的，如果没有指定，就跟父线程同组。那么这个“线程组”到底是什么作用的呢？今天来学习来这个类，首先看结构： 有一些基本的get set方法的实现其实很简单，就不说了。 public class ThreadGroup implements Thread.UncaughtExceptionHandler 这个类声明，可以看到类实现了Thread类的一个内部接口，定义如下： @FunctionalInterface public interface UncaughtExceptionHandler { /** * Method invoked when the given thread terminates due to the * given uncaught exception. * Any exception thrown by this method will be ignored by the * Java Virtual Machine. * @param t the thread * @param e the exception */ void uncaughtException(Thread t, Throwable e); } 这是一个函数式接口，从注释部分可以看到通过这个方法抛出的所有异常都会被虚拟机忽略。为什么忽略？不知道。 源码中对该类做出了解释：线程组代表了线程的集合。一个线程组也可以包含另一个线程组，也就是说线程组和线程组组成了树，而线程和线程组是元素和集合的关系。除了初始线程组，每个线程组都有父母。线程组可以访问组内线程的信息，但是组内线程，只允许访问有关自己线程的信息，不允许访问其所在线程组的、父线程组和其他线程组信息。 构造方法 一共定义了四种构造方法。 private ThreadGroup(){...} 无参构造方法，定义如下： private ThreadGroup() { // called from C code this.name = \"system\"; this.maxPriority = Thread.MAX_PRIORITY; this.parent = null; } 这个方法创建了一个新的空的线程组，可以看到，线程组的名字叫做“system”，它的最高优先级是线程的最高优先级，即10。而父线程组是null。三个变量的声明如下： private final ThreadGroup parent; String name; int maxPriority; 这个方法是C语言调用的，创建的就是前文提到过的\"初始线程组\"。 public ThreadGroup(String name){...} 指定了线程组的名称name，定义如下： public ThreadGroup(String name) { this(Thread.currentThread().getThreadGroup(), name); } 可以看到，它取得了当前线程所属的线程组作为其父线程。调用的是另一个重载的方法(就是下一个介绍的)，可能会抛出SecurityException异常。 public ThreadGroup(ThreadGroup parent, String name){...} 这就是上面提到的重载的构造函数，定义如下： public ThreadGroup(ThreadGroup parent, String name) { this(checkParentAccess(parent), parent, name); } 这里调用的是下一个重载的构造方法了，第一个参数是checkParentAccess方法的返回值了，这个方法定义如下： private static Void checkParentAccess(ThreadGroup parent) { parent.checkAccess(); return null; } 其中的checkAccess定义如下： public final void checkAccess() { SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkAccess(this); } } 这个方法决定了当前运行的线程是否有修改线程组的权利。该方法可能会抛出SecurityException异常。再回到checkParentAccess这个方法，注意它的返回值是Void,不是void。 这个方法是用来可达性的。 private ThreadGroup(Void unused, ThreadGroup parent, String name){...} 这个构造方法就是最终的大BOSS了。定义如下： private ThreadGroup(Void unused, ThreadGroup parent, String name) { this.name = name; this.maxPriority = parent.maxPriority; this.daemon = parent.daemon; this.vmAllowSuspension = parent.vmAllowSuspension; this.parent = parent; parent.add(this); } 当指定了父线程组的时候，其maxPriority、daemon、vmAllowSuspension就和父线程组保持一致了，vmAllowSuspension看名字就知道含义是虚拟机允许挂起。最后调用了add方法，定义如下： private final void add(ThreadGroup g){ synchronized (this) { if (destroyed) { throw new IllegalThreadStateException(); } if (groups == null) { groups = new ThreadGroup[4]; } else if (ngroups == groups.length) { groups = Arrays.copyOf(groups, ngroups * 2); } groups[ngroups] = g; // This is done last so it doesn't matter in case the // thread is killed ngroups++; } } 其中destroyed就是用来表示线程组的状态的，是不是被销毁了？（诶，线程组被销毁了难道不是真正被销毁了？）如果这个线程组已经是被销毁的状态，那就再不能往里装东西了，抛出异常。如果还没有初始化，即ThreadGroup groups[]这个数组还没初始化呢，那就初始化被，可以看到，它首次分配了4个空间，然后再往里面装东西，有一个ngroups量来标识其中的个数。被分配的空间都装满了怎么办？扩容。扩多少？两倍！其实groups数组和ngroups合起来就是一个线性表。 public final void setMaxPriority(int pri){...} public final void setMaxPriority(int pri) { int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { checkAccess(); if (pri Thread.MAX_PRIORITY) { return; } maxPriority = (parent != null) ? Math.min(pri, parent.maxPriority) : pri; ngroupsSnapshot = ngroups; if (groups != null) { groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot); } else { groupsSnapshot = null; } } for (int i = 0 ; i 这个用来设置线程组的优先级。首先判断了一些可达性（其实我不知道这个是干什么用的），如果参数不合法，即超出了范围（小于1或大于10），那么设置是不成功的，优先级不变，否则将会取参数和父线程的最大优先级的较小值赋值给当前线程组的maxPriority属性，如果当前线程是初始线程，那就没什么比较了，直接设置就行了。注意到，这个方法是递归性的。也就是说，如果一个线程组被重新设定了优先级，其子线程组都会跟着变。那问题来了，会影响其中线程的优先级么？答案是不会，哪些已经有了优先级的线程的优先级不会跟着改变，但是会影响在这个时间点之后被创建出来的、属于这个线程组的线程，还记得Thread类新建线程的时候，新线程的优先级不会大于其所在线程组的maxPriority属性值。所以自创一道题目：线程组中的线程的优先级有可能大于线程组的最大优先级么？现在看来是有可能的。 这里有一个问题，为什么要有复制一份groupsSnapshot,直接对groups操作不是挺好的么？注意，Arrays.copyOf()是浅复制，groupsSnapshot和groups中相应元素实际上是一样的。 public final boolean parentOf(ThreadGroup g){...} 从方法名字就可以看出来，这个方法用来判断这个线程组是不是参数的父线程组。这里说\"父线程组\"不太准确，应该说“祖先线程组”。 public final boolean parentOf(ThreadGroup g) { for (; g != null ; g = g.parent) { if (g == this) { return true; } } return false; } 从方法定义就可以看出来，形参一直找寻着其父线程组，直到初始线程。 public int activeCount(){...} 返回此线程中活动线程数的估计组及其子组。 递归迭代所有子线程组。需要注意的是，这里返回的是所有活动的线程的数量，要和后面activeGroupCount方法区分开来。 public int activeCount() { int result; // Snapshot sub-group data so we don't hold this lock // while our children are computing. int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { if (destroyed) { return 0; } result = nthreads; ngroupsSnapshot = ngroups; if (groups != null) { groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot); } else { groupsSnapshot = null; } } for (int i = 0 ; i 源码对该方法有一个说明：返回的值只是一个估计，因为数量线程可以动态更改，而此方法遍历内部数据结构，并可能受到某些存在的影响系统线程。 此方法主要用于调试和监测目的。 enumerate方法 这又是一个比较重要的方法，一共有6个重载方法。其中一般的作用是复制当前线程的线程组及其子组中的每一个活动线程到指定的数组。另一半的是复制当前线程的线程组及其子组中的每一个活动线程组到指定的数组。 由于过程都差不多，这里就看下前一半。 public int enumerate(Thread list[]){...} 参数list就是制定的数组。最后被复制进去的线程组或活动线程的总个数。 public int enumerate(Thread list[]) { checkAccess(); return enumerate(list, 0, true); } public int enumerate(Thread list[], boolean recurse) {...} public int enumerate(Thread list[], boolean recurse) { checkAccess(); return enumerate(list, 0, recurse); } private int enumerate(Thread list[], int n, boolean recurse){...} 这个此时最终的方法。三个参数，第二个参数都被默认为0，第三个参数recurse如果是true，那么将会递归调用这个子线程组下的所有子线程组，如果超出了list的大小，那么多出的部分将被忽略。如果避免这个问题呢？可以首先调用一些activeCount方法确定一下大概的属性，然后再用这个大小声明list数组就可以了。 private int enumerate(Thread list[], int n, boolean recurse) { int ngroupsSnapshot = 0; ThreadGroup[] groupsSnapshot = null; synchronized (this) { if (destroyed) { return 0; } int nt = nthreads; if (nt > list.length - n) { nt = list.length - n; } for (int i = 0; i public int activeGroupCount(){...} 这个方法返回的是这个线程组下所有活动线程组的个数。注意是线程组的个数。与上面activeCount区分开来。 public int activeGroupCount() { int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { if (destroyed) { return 0; } ngroupsSnapshot = ngroups; if (groups != null) { groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot); } else { groupsSnapshot = null; } } int n = ngroupsSnapshot; for (int i = 0 ; i public final void interrupt(){...} 中断这个线程组中所有的线程。同样采取了递归的方式。 public final void interrupt() { int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { checkAccess(); for (int i = 0 ; i private boolean stopOrSuspend(boolean suspend){...} 从方法名字可以看出，这个方法来停止或停止当前线程组中的除了当前线程之外的所有线程，那到底是挂起还是停止呢，参数suspend如果是true，就表示全部挂起，否则就全部停止。方法返回true当且仅当当前线程属于这个线程组或其子线程组。 @SuppressWarnings(\"deprecation\") private boolean stopOrSuspend(boolean suspend) { boolean suicide = false; Thread us = Thread.currentThread(); int ngroupsSnapshot; ThreadGroup[] groupsSnapshot = null; synchronized (this) { checkAccess(); for (int i = 0 ; i public final void destroy(){...} 用来销毁线程组(除初始线程组)其子线程组，前提条件是该线程组中thread必须得空，意思就是如果该线程组中还要运行着的线程，那么这个线程组就不能被销毁。销毁过程就是将各个属性置为null或0。最后将其从父线程组中移除。 public final void destroy() { int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { checkAccess(); if (destroyed || (nthreads > 0)) { throw new IllegalThreadStateException(); } ngroupsSnapshot = ngroups; if (groups != null) { groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot); } else { groupsSnapshot = null; } if (parent != null) { destroyed = true; ngroups = 0; groups = null; nthreads = 0; threads = null; } } for (int i = 0 ; i 其中remove方法定义如下： private void remove(ThreadGroup g) { synchronized (this) { if (destroyed) { return; } for (int i = 0 ; i list方法 打印出线程组中线程的相关信息，这个方法只在debugging的时候有用。有两个重载方法。无参数方法定义如下： public void list() { list(System.out, 0); } 默认的输出是System.out，缩进为0。被调用的方法定义如下： void list(PrintStream out, int indent) { int ngroupsSnapshot; ThreadGroup[] groupsSnapshot; synchronized (this) { for (int j = 0 ; j public void uncaughtException(Thread t, Throwable e){...} 设置当前线程组的异常处理器（只对没有异常处理器的线程有效）。 public void uncaughtException(Thread t, Throwable e) { if (parent != null) { parent.uncaughtException(t, e); } else { Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler(); if (ueh != null) { ueh.uncaughtException(t, e); } else if (!(e instanceof ThreadDeath)) { System.err.print(\"Exception in thread \\\"\" + t.getName() + \"\\\" \"); e.printStackTrace(System.err); } } } public String toString() {...} 打印出线程组信息。 public String toString() { return getClass().getName() + \"[name=\" + getName() + \",maxpri=\" + maxPriority + \"]\"; } 如何创建一个线程并且加入到一个指定的线程组中？b Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 18:24:41 "},"源码解读/java.lang/Math.html":{"url":"源码解读/java.lang/Math.html","title":"Math","keywords":"","body":"Math 该类封装了基础的数学计算。结构如下： 全部都是静态方法，而且大部分的方法都是借助了StrictMath中的方法，并且实现并不重要，当成工具类会用即可。 类中有两个字符： static double E 这就是double值，该值是比任何其他更近到e，自然对数的基础上。 static double PI 这就是双值，该值是比任何其他更接近到pi，一个圆的圆周比其直径。 下面是该类中常用方法的整理： 方法 描述 static double abs(double a) 【还有一系列重载方法】 此方法返回一个double值的绝对值. static double acos(double a) 此方法返回一个值的反余弦值，返回的角度范围从0.0到pi. static double asin(double a) 此方法返回一个值的反正弦，返回的角度范围在-pi/2到pi/2. static double atan(double a) 此方法返回一个值的反正切值，返回的角度范围在-pi/2到pi/2. static double atan2(double y, double x) 此方法返回角度theta（x，y）从转换的矩形坐标到极坐标（r，θ）. static double cos(double a) 此方法返回一个角的三角余弦. static double sin(double a) 此方法返回一个double值的双曲正弦. static double tan(double a) 此方法返回一个角的三角函数正切值 static double toDegrees(double angrad) 这种方法大致相等的角度，以度为单位的角度转换成弧度测量. static double toRadians(double angdeg) 此方法转换一个角度，以度为单位大致相等的角弧度测量. static double cbrt(double a) 此方法返回一个double值的立方根. static double pow(double a, double b) 此方法返回的第一个参数的值提升到第二个参数的幂 static double exp(double a) 此方法返回欧拉数e的一个double值的次幂. static double expm1(double x) 此方法返回 e^x -1. static double log(double a) 此方法返回一个double值的自然对数（以e为底）. static double log10(double a) 此方法返回一个double值以10为底. static double floor(double a) 此方法返回最大的（最接近正无穷大）double值小于或相等于参数，并相等于一个整数. static double ceil(double a) 此方法返回最小的（最接近负无穷大）double值，大于或等于参数，并等于一个整数. static double rint(double a) 此方法返回的double值，值的参数是最接近的，相等于一个整数. static long round(double a) 此方法返回的参数最接近的long. static int round(float a) 此方法返回的参数最接近的整数. static double max(double a, double b) 【还有一系列重载的方法】 此方法返回两个double值较大的那一个. static double min(double a, double b) 【还有一系列重载的方法】 此方法返回的两个较小的double值. static double random() 该方法返回一个无符号的double值，大于或等于0.0且小于1.0. 这些方法在使用的时候要特别注意返回值大部分情况下都是double。特别是加粗的几个方法，每次都记不清楚。这里另外拎出来讲讲 Math.floor() 的概念，向下取整，返回值是double类型。Math.floor(2.2) = 2.0; Math.floor(-2.2) = -3.0; Math.floor(2.5) = 2.0; Math.floor(-2.5) = -3.0; Math.floor(2.7) = 2.0; Math.floor(-2.7) = -3.0; Math.ceil() >=的概念，向上取整，返回值是double类型。Math.ceil(2.2) = 3.0; Math.ceil(-2.2) = -2.0; Math.ceil(2.5) = 3.0; Math.ceil(-2.5) = -2.0; Math.ceil(2.7) = 3.0; Math.ceil(-2.7) = -2.0; Math.round() 正宗的四舍五入，返回值是int类型。 参数是负数的时候不太好理解，可以利用公式Math.round(x) = Math.floor(x + 0.5)来记忆。Math.round(2.2) = 2； Math.round(-2.2) = -2； Math.round(2.5) = 3； Math.round(-2.5) = -2； Math.round(2.7) = 3； Math.round(-2.7) = -3 Math.rint() 返回最接近该值的那个整数，注意！如果存在两个这样的整数，则返回其中的偶数。 Math.rint(2.2) = 2.0； Math.rint(-2.2) = -2.0； Math.rint(2.7) = 3.0； Math.rint(-2.7) = -3.0； Math.rint(2.5) = 2.0； Math.rint(-2.5) = -2.0； Math.rint(3.5) = 4.0； Math.rint(-3.5) = -4.0； static double random() 返回一个[0.0, 1.0) 之间的double值，注意区间和返回值类型！！！可以利用它来返回一某个区间（左开右闭）的随机浮点数，如果要返回整型，千万别忘记类型转化。 例如，返回[a,b)之间的随机整数， 则int r = (int)(Math.random() * (b - a) + a)。 random方法还可以用来生成字符。例如生成a~z之间的任意字符： (char)('a' + Math.random() * ('z' - 'a' + 1) )；随机生成一个ch1-ch2之间的任意字符：(char)(ch1 + Math.random() * (ch2 - ch1 + 1)); 随机数一般可以使用两种方法来实现：一是使用Math.random()方法，二是使用java.util.Random对象，两者有什么关系？ 我们看下random方法的实现： public static double random() { return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble(); } 追溯nextDouble发现它就是Random类的实例方法nextDouble！ 所以一般情况下，大部分程序员都是用Math.random，比较方便。 有关Random类，请查看相关博客。 参考 java中Math.random()与java.util.random()的区别 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:04:25 "},"源码解读/java.lang/Enum.html":{"url":"源码解读/java.lang/Enum.html","title":"Enum","keywords":"","body":"Enum 这是所有Java语言枚举类型的公共基类。 有关枚举的更多信息，包括由编译器合成的隐式声明方法的描述，可以在Java™语言规范的第8.9节中找到。 请注意，当使用枚举类型作为集合的类型或作为映射中的键的类型时，可以使用专门且高效的java.util.EnumSet集合和java.util.EnumMap映射实现。 结构如下： public abstract class Enum> implements Comparable, Serializable 类声明，注意到这是一个抽象类，实现了Comparable和Serializable接口。枚举类型符合通用模式 Class Enum>，而E表示枚举类型的名称。 protected Enum(String name, int ordinal){...} 这个类的构造函数，指定了name和ordinal，name表示这个类的名称，ordinal表示序数。定义如下： protected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } 然而我们很少直接new一个枚举类的对象，而是经常采取下面这种写法： public enum EnumTest { MON, TUE, WED, THU, FRI, SAT, SUN; } 创建枚举类型要使用enum关键字，隐含了所创建的类型都是java.lang.Enum类的子类（java.lang.Enum 是一个抽象类）。枚举类型的每一个值都将映射到protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 所以上面这段话调用了7次构造函数，等同于 new Enum(\"MON\",0); new Enum(\"TUE\",1); new Enum(\"WED\",2); public final String name(){...} 取得枚举对象的名称，定义如下： public final String name() { return name; } public final int ordinal() {...} 取得枚举对象的序数。 public final int ordinal() { return ordinal; } public String toString(){...} 取得枚举对象的string值，这里返回的是name字段。 public final boolean equals(Object other){...} 判断两个枚举对象是不是相等的。定义如下： public final boolean equals(Object other) { return this==other; } 可以看到，内部直接使用了==来判断，所以枚举型的相等判断，用equals方法和==符号是一样的效果。 public final int hashCode(){...} 重写equals方法一定要重写hashCode方法！实际上并没有做什么改变，返回的父类Object的hashCode方法。定义如下： public final int hashCode() { return super.hashCode(); } protected final Object clone() throws CloneNotSupportedException{...} 继承自父类的克隆方法。Enum不允许克隆。定义如下： protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } 没得商量，直接抛出异常。 public final int compareTo(E o){...} 比较两个枚举对象的值。定义如下： public final int compareTo(E o) { Enum other = (Enum)o; Enum self = this; if (self.getClass() != other.getClass() && // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } 可以看到，在两个枚举对象同类型的情况下，返回两个对象序号的差值（正数/0/负数）。 public final Class getDeclaringClass(){...} 返回与此枚举常量的枚举类型相对应的 Class 对象。\u001f定义如下： @SuppressWarnings(\"unchecked\") public final Class getDeclaringClass() { Class clazz = getClass(); Class zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class)clazz : (Class)zuper; } public static > T valueOf(Class enumType, String name) 返回带指定名称的指定枚举类型的枚举常量。定义如下： public static > T valueOf(Class enumType, String name) { T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(\"Name is null\"); throw new IllegalArgumentException( \"No enum constant \" + enumType.getCanonicalName() + \".\" + name); } 这个方法就常常用到了， 比如我们要得到枚举名称为MON的枚举常量，就可以这么做： EnumTest MON = Enum.valueOf(EnumTest.class, \"MON\")。 下面是一段Enum类中常用方法的实例程序： public class Test { public static void main(String[] args) { EnumTest test = EnumTest.TUE; //compareTo(E o) switch (test.compareTo(EnumTest.MON)) { case -1: System.out.println(\"TUE 在 MON 之前\"); break; case 1: System.out.println(\"TUE 在 MON 之后\"); break; default: System.out.println(\"TUE 与 MON 在同一位置\"); break; } //getDeclaringClass() System.out.println(\"getDeclaringClass(): \" + test.getDeclaringClass().getName()); //name() 和 toString() System.out.println(\"name(): \" + test.name()); System.out.println(\"toString(): \" + test.toString()); //ordinal()， 返回值是从 0 开始 System.out.println(\"ordinal(): \" + test.ordinal()); } } 指定结果是： TUE 在 MON 之后 getDeclaringClass(): com.hmw.test.EnumTest name(): TUE toString(): TUE ordinal(): 1 枚举对象自定义属性和方法 public enum EnumTest { MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6) { @Override public boolean isRest() { return true; } }, SUN(0) { @Override public boolean isRest() { return true; } }; private int value; private EnumTest(int value) { this.value = value; } public int getValue() { return value; } public boolean isRest() { return false; } public static void main(String[] args) { System.out.println(\"EnumTest.FRI 的 value = \" + EnumTest.FRI.getValue()); System.out.println(\"EnumTest.SAT 的isSet方法\" + EnumTest.SAT.isRest()); } } 执行结果是： EnumTest.FRI 的 value = 5 EnumTest.SAT 的isSet方法true 枚举类的原理分析 enum 的语法结构尽管和 class 的语法不一样，但是经过编译器编译之后产生的是一个class文件。该class文件经过反编译可以看到实际上是生成了一个类，该类继承了java.lang.Enum。EnumTest经过反编译(javap com.hmw.test.EnumTest命令)之后得到的内容如下： public class com.hmw.test.EnumTest extends java.lang.Enum{ public static final com.hmw.test.EnumTest MON; public static final com.hmw.test.EnumTest TUE; public static final com.hmw.test.EnumTest WED; public static final com.hmw.test.EnumTest THU; public static final com.hmw.test.EnumTest FRI; public static final com.hmw.test.EnumTest SAT; public static final com.hmw.test.EnumTest SUN; static {}; public int getValue(); public boolean isRest(); public static com.hmw.test.EnumTest[] values(); public static com.hmw.test.EnumTest valueOf(java.lang.String); com.hmw.test.EnumTest(java.lang.String, int, int, com.hmw.test.EnumTest); } 所以，实际上 enum 就是一个 class，只不过 java 编译器帮我们做了语法的解析和编译而已。所以可以把enum看做是一个普通的class，它们都可以定义一些属性和方法，不同的是：enem关键字不能继承其他类，因为enum已经继承了java.lang.Enum（Java是单继承关系）。 EnumSet和EnumMap的用法等待学习java.util包的时候再学习。 参考 java enum(枚举)使用详解 + 总结 Java 枚举(enum) 详解7种常见的用法 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:05:42 "},"源码解读/java.lang/System.html":{"url":"源码解读/java.lang/System.html","title":"System","keywords":"","body":"System java系统类System是一个不可实例化的类，提供了一些系统属性和方法。我们经常用到System.out.println()，那么其中的out是一个内部类么？看了这个类就能得到答案了。类的结构如下： 内容还挺多的，但是我们只用记住几个常用的就可以了。 属性字段 //标准输入流 public final static InputStream in; //标准输出流 public final static PrintStream out; //标准错误流 public final static PrintStream err; 这三个就是我们常用都到的System.in、System.out、System.err，他们都不是内部类，而是字段变量。他们都是IO类，并且已经处于打开状态，等待着接收和输出内容。 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 这是经常被用到数组拷贝方法。数组拷贝有很多种方法，比如String类的getChars(char dst[], int dstBegin)、Arrays类的copyOf(char[] origin, int len)或copyOfRange(char[] origin, int len)，但是实际上三者都是直接调用了System类的arraycopy方法。 遇到过一道题目，问的是数组拷贝方法中哪种方法效率最高。候选的有for循环方法、String的getChars方法，Arrays的copyOf方法和System的arraycopy方法。在大规模复制的情况下，当然是System的arraycopy方法效率最高。为什么？且不说其他两个（除了for循环）是调用的System.arraycopy方法，它本身是一个native方法，是C++实现的，所以这个效率更高。 public static native long currentTimeMillis(); 该方法和Date类中getTime方法完全是一样的，如果只是需要毫秒数，这样的调用也是很方便的。但是需要注意的是currentTimeMillis并不是直接拿到了getTime的结果！currentTimeMillis是一个本地方法，返回的是操作系统的时间，由于有的操作系统时间的最小精确度是10毫秒所以这个方法可能会导致一些偏差。 public static String getProperty(String key){...} 我们通过调用这个方法，在参数中输入键的字符串获取系统的属性。哪些系统属性呢？如下面。 Key Description of Associated Value java.version Java Runtime Environment version java.vendor Java Runtime Environment vendor java.vendor.url Java vendor URL java.home Java installation directory java.vm.specification.version Java Virtual Machine specification version java.vm.specification.vendor Java Virtual Machine specification vendor java.vm.specification.name Java Virtual Machine specification name java.vm.version Java Virtual Machine implementation version java.vm.vendor Java Virtual Machine implementation vendor java.vm.name Java Virtual Machine implementation name java.specification.version Java Runtime Environment specification version java.specification.vendor Java Runtime Environment specification vendor java.specification.name Java Runtime Environment specification name java.class.version Java class format version number java.class.path Java class path java.library.path List of paths to search when loading libraries java.io.tmpdir Default temp file path java.compiler Name of JIT compiler to use java.ext.dirs Path of extension directory or directories Deprecated. This property, and the mechanism which implements it, may be removed in a future release. os.name Operating system name os.arch Operating system architecture os.version Operating system version file.separator File separator (\"/\" on UNIX) path.separator Path separator (\":\" on UNIX) line.separator Line separator (\"\\n\" on UNIX) user.name User's account name user.home User's home directory user.dir User's current working directory 有些情况下会用到。比如我们在操作文件的时候可能需要用到我们的当前工作目录。可以使用这个方法来获取： public static void main(String[] args) { String dirPath = System.getProperty(\"user.dir\"); System.out.println(dirPath); } public static void gc(){...} 调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象或失去了所有引用的对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。定义如下： public static void gc() { Runtime.getRuntime().gc(); } 需要注意的是，实际上我们并不一定需要调用gc()方法，让编译器自己去做就好了。另外需要注意人为调用gc()方法并不会立即触发垃圾回收，什么时候回收还是JVM说了算。 public static void exit(int status){...} 退出虚拟机。定义如下： public static void exit(int status) { Runtime.getRuntime().exit(status); } exit(int)方法终止当前正在运行的 Java 虚拟机，参数解释为状态码。根据惯例，非 0的状态码表示异常终止。0表示正常中止。而且，该方法永远不会正常返回。 这是唯一一个能够退出程序并不执行finally的情况。例如： public static void main(String[] args) { try { System.out.println(\"this is try\"); System.exit(0); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { System.out.println(\"this is finally\"); } } 上面这段程序并不会指定finally中的语句。因为退出虚拟机会直接杀死整个程序，已经不是从代码层面来终止程序了，所以finally不会执行。 参考 java——深度解析System系统类 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:09:26 "},"源码解读/java.lang/Iterable.html":{"url":"源码解读/java.lang/Iterable.html","title":"Iterable","keywords":"","body":"Iterable 这是一个接口（不同于java.util中的Iterator），定义了迭代器所具有的功能。实现此接口允许对象成为“for-each loop”语句的目标。 什么是\"for-each loop\"？官方doc对for each loop专门做了解释： 集合迭代的代码实现往往非常臃肿。考虑下面这个例子，它遍历定时器任务并取消它们： void cancelAll(Collection c) { for (Iterator i = c.iterator(); i.hasNext(); ) i.next().cancel(); } 这个迭代器的使用非常繁琐也容易导致错误。因为迭代器在循环中出现了3次，后面两次都可能出错。而for-each循环解决了这些问题： void cancelAll(Collection c) { for (TimerTask t : c) t.cancel(); } 其中冒号读作“in”。这个循环读作“for each TimerTask t in c.”for-each循环和泛型完美结合，此时我们不需要声明迭代器，因此也不需要为它提供泛型定义（实际上编译器为我们实现了这些）。所以它不但提供了类型安全，也去掉了复杂的语法 。 下面是嵌套循环中容易出现的另一个错误： List suits = ...; List ranks = ...; List sortedDeck = new ArrayList(); // BROKEN - throws NoSuchElementException! for (Iterator i = suits.iterator(); i.hasNext(); ) for (Iterator j = ranks.iterator(); j.hasNext(); ) sortedDeck.add(new Card(i.next(), j.next())); 如果你没有发现这个bug请不要灰心，许多专家级的程序员也会时不时犯这个错误。仔细检查会发现suits的next方法被调用了太多次。要解决这个问题可以采用下列方法： // Fixed, though a bit ugly for (Iterator i = suits.iterator(); i.hasNext(); ) { Suit suit = (Suit) i.next(); for (Iterator j = ranks.iterator(); j.hasNext(); ) sortedDeck.add(new Card(suit, j.next())); } 那这和for-each循环有什么关系呢？实时上它可以完美解决这个问题： for (Suit suit : suits) for (Rank rank : ranks) sortedDeck.add(new Card(suit, rank)); for-each对数组同样有效： // Returns the sum of the elements of a int sum(int[] a) { int result = 0; for (int i : a) result += i; return result; } 那么我们什么时候采用for-each循环呢？实际上我们应该尽可能使用它。它可以让代码更加完美。但是它也有自己的缺点。因为for-each隐藏了迭代器，因此我们无法调用remove方法以删除元素，也无法在循环中替换元素。同时它也不适合并行遍历多个集合。 事实上for-each的设计者们精心考虑过这些问题，目前的for-each设计是一个简洁易用而且足以覆盖大多数情况的解决方案。 Iterable接口结构如下： 其中后两个方法是1.8新加的非抽象方法，目前我们只需要知道第一个抽象方法就行了。 Iterator iterator(); 实现Iterable接口的类需要实现该抽象方法，该方法获取到了在这个对象上的迭代器。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-31 10:33:19 "},"源码解读/java.lang/Runnable.html":{"url":"源码解读/java.lang/Runnable.html","title":"Runnable","keywords":"","body":"Runnable Runnable可以理解为可执行的任务，用这个任务来定义线程，即线程应该完成哪项任务。 只有一个方法，所以这是一个函数式接口。 @FunctionalInterface public interface Runnable { /** * When an object implementing interface Runnable is used * to create a thread, starting the thread causes the object's * run method to be called in that separately executing * thread. * * The general contract of the method run is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 继承该接口的类定义了应该完成的任务，然后用这个任务去实例化线程。这是一个创建新城的方法。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 23:51:36 "},"源码解读/java.lang/Runtime.html":{"url":"源码解读/java.lang/Runtime.html","title":"Runtime","keywords":"","body":"Runtime Runtime类代表着Java程序的运行时环境，每个Java程序都有一个Runtime实例，该类会自动被创建，可以通过Runtime.getRuntime()方法来获取当前程序的Runtime实例。 Runtime是单例模式的应用。 其中一个比较重要的方法是exec，这个方法用来执行外部命令。 比如Linux下调用系统命令 String [] cmd={\"/bin/sh\",\"-c\",\"ln -s exe1 exe2\"}; Process proc =Runtime.getRuntime().exec(cmd); Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 15:56:45 "},"源码解读/java.lang/ThreadLocal.html":{"url":"源码解读/java.lang/ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 这篇文章的解释非常通俗易懂 线程的私家小院儿：ThreadLocal 可以这么想，每一个Thread实例中都保存了一个map，这个map叫做ThreadLocalMap，和我们一般用的HashMap不太一样，但是总之就是一个键值对，我们可以往这个map中加入一点东西，即map.put(k, value)，我们给这个key定义了一个类，叫做ThreadLocal，到这个地步，我们是可以操作的，比如想要从一个线程中取得一个名叫\"context\"的ThreadLocal类型变量对象的值，那我们就可以通过下面的方式取得： Thread thread = Thread.currentThread(); ThreadLocalMap map = thred.getThreadLocalMap(); Object o = map.get(context); //进行类型转换 以上是取值过程，设值过程的前两步也是这样，是不是很繁琐？所以，为了简化取值的步骤，我们将上面的过程打包进了ThreadLocal中，取值和设值过程分别定义为get和set方法。 ThreadLocal类结果如下： ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 构造函数 里面什么都没有。 /** * Creates a thread local variable. * @see #withInitial(java.util.function.Supplier) */ public ThreadLocal() { } get public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } set方法 /** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } remove方法 public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } private void remove(ThreadLocal key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } ThreadLocalMap 这是ThreadLocal的内部类，虽然是map，但是和我们一般用的 ThreadLocalMap不一样。 首先看到它其中的属性： /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 其中有些概念还是非常相似的，比如初始容量是16，然后扩容阈值，元素个数和哈希数组。 这里我们看到数组元素是Entry类型，该类型的定义如下： static class Entry extends WeakReference> { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } 它继承的是WeakReference类，该类定义如下： public class WeakReference extends Reference { /** * Creates a new weak reference that refers to the given object. The new * reference is not registered with any queue. * * @param referent object the new weak reference will refer to */ public WeakReference(T referent) { super(referent); } /** * Creates a new weak reference that refers to the given object and is * registered with the given queue. * * @param referent object the new weak reference will refer to * @param q the queue with which the reference is to be registered, * or null if registration is not required */ public WeakReference(T referent, ReferenceQueue q) { super(referent, q); } } 从名字上看，这是一个“弱引用”，实现自Reference。Java中有四种引用，具体可以参见相关博文。 总之，这是一个map，有点不一样而已。我们暂且不深究弱引用和强引用有什么区别，先来看看这个map的一些操作： 构造方法 //构造函数 ThreadLocalMap(ThreadLocal firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } private ThreadLocalMap(ThreadLocalMap parentMap) { Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j key = (ThreadLocal) e.get(); if (key != null) { Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode & (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; } } } } Set方法 采取线性探测法解决哈希冲突。 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } get方法 private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } //当发生哈希冲突的时候，将采取线性探测法进行查找 private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } 内存泄漏 参考 深入分析 ThreadLocal 内存泄漏问 让我们重新回顾一下ThreadLocal原理 ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。 其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。 但是这些被动的预防措施并不能保证不会内存泄漏： 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏（参考ThreadLocal 内存泄露的实例分析）。 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。 每次使用完ThreadLocal，都调用它的remove()方法，清除数据。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 11:57:13 "},"源码解读/java.lang/java.lang.reflect/java.lang.reflect.html":{"url":"源码解读/java.lang/java.lang.reflect/java.lang.reflect.html","title":"java.lang.reflect","keywords":"","body":"这个子包包含了与反射相关的所有接口和类。 具体如下： 接口： 接口 说明 AnnotatedElement 表示目前正在此 VM 中运行的程序的一个已注释元素。 GenericArrayType GenericArrayType 表示一种数组类型，其组件类型为参数化类型或类型变量。 GenericDeclaration 声明类型变量的所有实体的公共接口。 InvocationHandler InvocationHandler 是代理实例的调用处理程序 实现的接口。 Member 成员是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息。 ParameterizedType ParameterizedType 表示参数化类型，如 Collection。 Type Type 是 Java 编程语言中所有类型的公共高级接口。 TypeVariable TypeVariable 是各种类型变量的公共高级接口。 WildcardType WildcardType 表示一个通配符类型表达式，如 ?、? extends Number 或 ? super Integer。 类： 类 说明 AccessibleObject AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。 Array Array 类提供了动态创建和访问 Java 数组的方法。 Constructor Constructor 提供关于类的单个构造方法的信息以及对它的访问权限。 Field Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。 Method Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。 Modifier Modifier 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。 Proxy Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 ReflectPermission 反射操作的 Permission 类。 参考 菜鸟学Java（十四）——Java反射机制（一） 阅读材料 《Java深度历险》（看看第1、2、5三章） 《 java reflection in action 》（有一定基础再看） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 16:07:59 "},"源码解读/java.lang/java.lang.reflect/Field.html":{"url":"源码解读/java.lang/java.lang.reflect/Field.html","title":"Field","keywords":"","body":"Field 提供有关类或接口的单个域的信息或动态访问权限，这个字段可以是静态域或者实例域。 可以通过类对象中的getFields()、getField(fieldName)、getDeclaredFields()或getDeclaredField(fieldName)来取得域数组或域对象。注意这几种方法的区别。 该类结构如下： public final class Field extends AccessibleObject implements Member 类声明，说明Field类无法被继承。 Field(Class declaringClass, String name, Class type, int modifiers, int slot, String signature,byte[] annotations) 构造方法。包内访问，反正开发人员是不能调用了。 Field(Class declaringClass, String name, Class type, int modifiers, int slot, String signature, byte[] annotations) { this.clazz = declaringClass; this.name = name; this.type = type; this.modifiers = modifiers; this.slot = slot; this.signature = signature; this.annotations = annotations; } private Class clazz; private int slot; // This is guaranteed to be interned by the VM in the 1.4 // reflection implementation private String name; private Class type; private int modifiers; // Generics and annotations support private transient String signature; // generic info repository; lazily initialized private transient FieldRepository genericInfo; private byte[] annotations; 重点是这些参数： clazz：代表这个域所属的类 name：代表这个域的名称 type：这个和clazz有什么区别呢？ modifiers：int类型，表示这个域的修饰符？为什么不是一个数组呢？ slot： int类型，暂时还不知道这是什么意思 signature：方法签名的意思么？ annotations：注解，这个很好理解，一个域可能被很多注解注释，这里是byte类型的数组，为什么是byte类型？ 常用方法 类中的方法很多，我们不需要每个都了解，只要知道一些常用的方法就可以了，毕竟我也不会去写框架什么的。常用方法分为两类吧，一是获取域属性，二是修改属性。 获取属性 获取域的属性，哪些属性？比如属性的名称、修饰符、所属类等等。 方法 说明 Class getDeclaringClass 获取所属类的全称 Class getType() 获取属性声明类型，返回Class对象 Type getGenericType() 获取属性类型，返回的是Type类型 String getName 获取属性声明时的名字 boolean isEnumConstant 判断该属性是否为枚举型 int getModifiers 获取属性对象的修饰符 boolean isSynthetic 判断这个域是否是人工合成的域？？？ 什么是人工合成域 getAnnotations() 获得这个属性上所有的注释 。。。。 以上是一些主要的方法。 注意getType方法和getGenericType方法的区别。首先返回值类型不同，前者返回Class对象，后者返回Type接口。再者，如果一个属性是泛型，那么前者只能得到这个属性的接口类型，而后者还等得到这个属性的泛型类型。 获取属性并修改属性 Field类中有两个特殊的方法 public Object get(Object obj)：用来获取obj这个对象的这个域的值 public void set(Object obj, Object value)：用来修改obj这个对象的域的值。 下面是一个测试代码。 首先定义一个类： public class Person { private int age; public String name; public String sex; //setter and getter public static void main(String[] args) { Person person = new Person(); person.setAge(10); person.setName(\"Alice\"); person.setSex(\"female\"); Class cls = person.getClass(); // Field[] fields = cls.getFields();// 只能取得public的域 Field[] fields = cls.getDeclaredFields(); // 可以取得本类的所有域，不限访问修饰符 for (Field field : fields){ System.out.println(field.getName()); } try { Field field = cls.getField(\"age\");//age是私有域，将抛出异常 System.out.println(field.get(person)); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } try { Field field = cls.getDeclaredField(\"age\");//age是私有域，将抛出异常 field.setAccessible(true);//当获取私有属性值的时候，需要设置Accessible为true System.out.println(field.get(person)); // 10 field.set(person, 20); System.out.println(field.get(person)); // 20 } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 19:34:27 "},"源码解读/java.lang/java.lang.reflect/Method.html":{"url":"源码解读/java.lang/java.lang.reflect/Method.html","title":"Method","keywords":"","body":"Method Method类提供了关于类或接口上单独方法（以及如何访问该方法）的信息。 使用类对象的getMethods()、getMethods(String, Class[])、getDeclaredMethods()和getDeclaredMethod(String, Class[])可以获取Method对象。同样注意有declared和没有declared方法的区别。 public final class Method extends Executable 类声明。不可继承，实现Executable接口。 常用方法 同样有些方法只需要会用就行了，这个方法大都用力获取方法的各类属性，比如返回值类型、参数个数、参数类型等，大致如下： 方法 说明 Class getDeclaringClass() 获取所属类的类对象 String getName() 获取方法名称 TypeVariable[] getTypeParameters() 获取参数列表 Type[] getGenericParameterTypes() 获取参数列表 Class[] getParameterTypes() 获取参数类型 int getParameterCount() 获取参数个数 int getModifiers() 获取修饰符 Class getReturnType() 获取返回值类型 Type getGenericReturnType() 获取返回值类型 Class[] getExceptionTypes() 获取异常类型 Type[] getGenericExceptionTypes() 获取异常类型 。。。 常用的大致是以上这些了。可以发现getXXXType和getGenericXXXTypes这种形式经常成对出现，他们的区别和Field中讲解的一样。 invoke方法 这是最重要的方法，反射取得Method的目的不都是执行么，这个方法就是触发方法执行。定义如下： public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); } } MethodAccessor ma = methodAccessor; // read volatile if (ma == null) { ma = acquireMethodAccessor(); } return ma.invoke(obj, args); } 方法有两个参数，第一个参数指定方法触发的对象，第二个参数是一个变长参数列表，指定了方法的参数。另外需要注意该方法的返回值是Object类型，我们需要将执行结果进行类型转换。 当然，反射中触发方法并不是都调用invoke方法， 可以反射取得一个实例，然后一般的实例方法调用就行。 下面是invoke方法使用的例子: public class MethodTest { public String saySomething(String name, String msg){ String res = \"Hello \" + name + \", \" + msg; return res; } public static void main(String[] args) { //通过反射触发saySomething方法 Class cls = MethodTest.class; //触发方式1： 得到method实例，调用invoke方法 try { Method method = cls.getDeclaredMethod(\"saySomething\", String.class, String.class); System.out.println((String)method.invoke(new MethodTest(), \"baobao\", \"how are you\"));//Hello baobao, how are you } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } //触发方式2：反射得到一个实例，用实例触发 try { MethodTest methodTest = (MethodTest) cls.newInstance(); //注意要进行类型转换 System.out.println(methodTest.saySomething(\"Alice\", \"how are you\"));//Hello Alice, how are you } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } method.invoke方法也是动态代理类中用到的一个基础知识，明白了这个再看InvokationHandler接口实现类的invoke方法会相对容易些。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 11:12:23 "},"源码解读/java.lang/java.lang.reflect/Modifier.html":{"url":"源码解读/java.lang/java.lang.reflect/Modifier.html","title":"Modifier","keywords":"","body":"Modifier 之前在Field和Method中遇到getModifiers类的时候很困惑，为什么这个方法的返回值类型是int，看这个类的实现就知道了。类的结构如下： 这个类将所有的修饰符编号，这个编号就是int型，这也就是为什么getModifiers方法的返回值类型是int。 类中的方法很简单，就是在判断是不是具有某个修饰符，以及类、接口、构造函数、属性、方法各自都具有什么样的修饰符？ 例如一个方法有多个修饰符，那么这个方法调用getModifiers的值是多少，做个试验。 算了不试验了，我要回家了~~~ Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 18:24:32 "},"源码解读/java.lang/java.lang.reflect/Constructor.html":{"url":"源码解读/java.lang/java.lang.reflect/Constructor.html","title":"Constructor","keywords":"","body":"Constructor 构造方法是特殊的方法，所以专门有一个类用来描述构造方法。用类对象的getConstructors()，getConstructor(Class[])， getDeclareConstructors()方法可以取得Constructor对象。 该类的结构如下： 可以看到其中大部分的方法都很眼熟，在Field和Method中看到很多了。 其中有一个方法需要特别注意——newInstance方法，这表示使用这个构造方法来创建类的实例。下面是一个简单的测试例子： public class Person { private int age; public String name; public String sex; public Person() { } public Person(int age, String name, String sex) { this.age = age; this.name = name; this.sex = sex; } public int getAge() { return age; } @Override public String toString() { return \"Person{\" + \"age=\" + age + \", name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + '}'; } public static void main(String[] args) { Class cls = Person.class; Constructor [] cons = cls.getConstructors(); try { Constructor constructor = cls.getConstructor(int.class, String.class, String.class); Person person1 = (Person) constructor.newInstance(10, \"Bob\", \"male\"); System.out.println(person1.toString()); //Person{age=10, name='Bob', sex='male'} } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } System.out.println(cons.length); // 2 } } 讲到这里，我们可以总结下创建一个类的实例的方法了，有以下几种方法： 通过new方法自主创建 获取类的类对象，通过类对象的newInstance方法可以创建实例。 获取类的类对象，获取指定的构造方法Constructor实例，通过这个实例的newInstance方法创建类的实例。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 18:40:24 "},"源码解读/java.lang/java.lang.reflect/Array.html":{"url":"源码解读/java.lang/java.lang.reflect/Array.html","title":"Array","keywords":"","body":"Array Array提供了数组的动态创建和访问Java数组的办法，比较特殊。为什么特殊呢？因为我们平常创建数组都不经过这个类，而是直接创建，比如我们创建一个String类型的数组，通常会这样做： String [] array = new String[10]; 全程都没有没有Array这个类什么事情，但是我们可以通过这个类动态创建数组，什么是动态当然是反射了。先看这个类的结构： 很显然，看到了几个熟悉的方法，比如newInstance、get和set方法，这三个是主要的操纵数组的方法。 我们不需要知道底层如何实现，但是需要记住方法签名。 public static Object newInstance(Class componentType, int length) 第一个参数是数组元素的类对象，第二个元素是长度，所以由这个方法创建的数组是一维数组。需要注意，方法的而返回类型是Object。 public static Object newInstance(Class componentType, int... dimensions) 第一个参数是数组元素的类对象，第二个数组是一个变长参数，指的是各个维度，所以由这个方法创建的数组是一个多维数组。 public static native Object get(Object array, int index) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; 注意到这个一个本地方法，两个参数，第一个是操纵的数组的对象，第二个是位置的索引 public static native void set(Object array, int index, Object value)throws IllegalArgumentException, ArrayIndexOutOfBoundsException; 同样是本地方法，三个参数，第一个是操纵的数组的对象，第二个是位置的索引，第三个是用来替换的对象 Array类有一个特点，那就是所有方法都是静态方法。 ！！！！ 注意,Array类没有public的构造方法，所以根本不能实例化，所以Array array = new Array()这种写法是错误的。 下面是一个利用Array类来创建String类型数组，并向其中添加内容的例子: public class ArrayTest { public static void main(String[] args) { Object array = Array.newInstance(String.class, 10); //创建一个大小为10的String类型的数组，注意返回值是Object //往数组中添加一项内容 Array.set(array, 1, \"Hello\"); Array.set(array, 2, \"baobao\"); Array.set(array, 3, \"how are you\"); //获取数组中的一项 System.out.println(Array.get(array, 3)); // how are you } } 学到这里我们可能会想另外一个和数组有关的类Arrays，这个类也提供了对数组的操作，比如排序啊，查找啊这种，有什么区别。 Array和Arrays的关系就像是Object和Objects、Executor和Executors、Collection和Collections的关系，那就是后者都是一个工具类，前者才是正主！。Array所在包是java.lang.reflect，而Arrays所在包是java.util，前者可以通过反射来创建数组并操作数组，后者只能用来操纵数组。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-28 10:16:23 "},"源码解读/java.lang/java.lang.reflect/Proxy.html":{"url":"源码解读/java.lang/java.lang.reflect/Proxy.html","title":"Proxy","keywords":"","body":"Proxy 代理技术是整个Java中最重要的技术，不弄懂它，看一些框架例如Spring的源代码会有问题的。 动态代理技术，注意不是静态代理，是用来产生一个独对象的代理对象的。有点拗口，也就是说，如果A是B的代理，我们需要通过B来产生A。类比于B是刘德华，那么A就是刘德华的经纪人。 这就奇怪了，为什么不找刘德华而去找刘德华的经纪人，这个当然了，刘德华的腕儿大么，一些事宜都是经纪人说了算法。那为什么不随便指定一个人呢，这不废话么，刘德华就制定了一个经纪人，随便一个人谁也不认啊。我们需要刘德华唱歌跳舞的，那么就要告诉经纪人：我们邀请经纪人来唱歌跳舞，经纪人需要和刘德华一样，同样会唱歌跳舞（虽然这个例子在现实生活中并不现实，因为经纪人并不需要唱歌跳舞的技能，但是在程序设计中，代理对象和被代理的对象需要有相同的方法）。 所以，由以上的例子就可以明确代理对象的两个概念了： 1. 代理对象存在的价值在于拦截对真实业务对象（即被代理的对象，上例中的刘德华）的访问。 2. 代理对象应该具有和真实业务对象相同的方法。（上例中经济人需要和刘德华一样会唱歌跳舞） 怎么生成代理对象呢？Proxy就是提供产生代理对象的方法类。类结构如下： 该类中其他可以不用管，但是newProxyInstance这个方法是最最最重要的方法，一定要知道，这个方法用来创建一个对象的代理类，方法签名如下： public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h){ } 这里有三个参数： ClassLoader loader用来指定用哪个类装载器生成代理对象。一般来说，都使用被代理对象的类装载器。 Class [] interface用来指明生成哪个对象的代理对象。注意，这是通过接口来指定的。 InvocationHandler h 是用来指明产生的这个代理对象要做什么事情。也就是这个代理对象怎么产生目标对象。因此，一个非常重要的步骤就是实现InvocationHandler接口的类。 下面就是使用动态代理模式的例子： 首先定义一个对象的行为接口 package cn.gacl.proxy; 2 3 /** 4 * @ClassName: Person 5 * @Description: 定义对象的行为 6 * @author: 孤傲苍狼 7 * @date: 2014-9-14 下午9:44:22 8 * 9 */ 10 public interface Person { 11 12 /** 13 * @Method: sing 14 * @Description: 唱歌 15 * @Anthor:孤傲苍狼 16 * 17 * @param name 18 * @return 19 */ 20 String sing(String name); 21 /** 22 * @Method: sing 23 * @Description: 跳舞 24 * @Anthor:孤傲苍狼 25 * 26 * @param name 27 * @return 28 */ 29 String dance(String name); 30 } 接着定义这个接口的目标业务对象类： package cn.gacl.proxy; 2 3 /** 4 * @ClassName: LiuDeHua 5 * @Description: 刘德华实现Person接口，那么刘德华会唱歌和跳舞了 6 * @author: 孤傲苍狼 7 * @date: 2014-9-14 下午9:22:24 8 * 9 */ 10 public class LiuDeHua implements Person { 11 12 public String sing(String name){ 13 System.out.println(\"刘德华唱\"+name+\"歌！！\"); 14 return \"歌唱完了，谢谢大家！\"; 15 } 16 17 public String dance(String name){ 18 System.out.println(\"刘德华跳\"+name+\"舞！！\"); 19 return \"舞跳完了，多谢各位观众！\"; 20 } 21 } 下面就是要看如何生成代理对象的代理类： 1 package cn.gacl.proxy; 2 3 import java.lang.reflect.InvocationHandler; 4 import java.lang.reflect.Method; 5 import java.lang.reflect.Proxy; 6 7 /** 8 * @ClassName: LiuDeHuaProxy 9 * @Description: 这个代理类负责生成刘德华的代理人 10 * @author: 孤傲苍狼 11 * @date: 2014-9-14 下午9:50:02 12 * 13 */ 14 public class LiuDeHuaProxy { 15 16 //设计一个类变量记住代理类要代理的目标对象 17 private Person ldh = new LiuDeHua(); 18 19 /** 20 * 设计一个方法生成代理对象 21 * @Method: getProxy 22 * @Description: 这个方法返回刘德华的代理对象：Person person = LiuDeHuaProxy.getProxy();//得到一个代理对象 23 * @Anthor:孤傲苍狼 24 * 25 * @return 某个对象的代理对象 26 */ 27 public Person getProxy() { 28 //使用Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)返回某个对象的代理对象 29 return (Person) Proxy.newProxyInstance(LiuDeHuaProxy.class 30 .getClassLoader(), ldh.getClass().getInterfaces(), 31 new InvocationHandler() { 32 /** 33 * InvocationHandler接口只定义了一个invoke方法，因此对于这样的接口，我们不用单独去定义一个类来实现该接口， 34 * 而是直接使用一个匿名内部类来实现该接口，new InvocationHandler() {}就是针对InvocationHandler接口的匿名实现类 35 */ 36 /** 37 * 在invoke方法编码指定返回的代理对象干的工作 38 * proxy : 把代理对象自己传递进来 39 * method：把代理对象当前调用的方法传递进来 40 * args:把方法参数传递进来 41 * 42 * 当调用代理对象的person.sing(\"冰雨\");或者 person.dance(\"江南style\");方法时， 43 * 实际上执行的都是invoke方法里面的代码， 44 * 因此我们可以在invoke方法中使用method.getName()就可以知道当前调用的是代理对象的哪个方法 45 */ 46 @Override 47 public Object invoke(Object proxy, Method method, 48 Object[] args) throws Throwable { 49 //如果调用的是代理对象的sing方法 50 if (method.getName().equals(\"sing\")) { 51 System.out.println(\"我是他的经纪人，要找他唱歌得先给十万块钱！！\"); 52 //已经给钱了，经纪人自己不会唱歌，就只能找刘德华去唱歌！ 53 return method.invoke(ldh, args); //代理对象调用真实目标对象的sing方法去处理用户请求 54 } 55 //如果调用的是代理对象的dance方法 56 if (method.getName().equals(\"dance\")) { 57 System.out.println(\"我是他的经纪人，要找他跳舞得先给二十万块钱！！\"); 58 //已经给钱了，经纪人自己不会唱歌，就只能找刘德华去跳舞！ 59 return method.invoke(ldh, args);//代理对象调用真实目标对象的dance方法去处理用户请求 60 } 61 62 return null; 63 } 64 }); 65 } 66 } 在动态代理技术中，由于不管用户调用了代理对象的什么方法，都是调用开发人员编写的处理器的invoke方法，相当于invoke方法拦截到了代理对象的方法调用。，并且，开发人员能通过invoke方法的参数，还可以在拦截的同事，知道用户调用了什么方法，因此利用这两个属性，就可以实现一些特殊需求，比如：拦截用户的访问请求，查看权限，动态添加额外功能。 参考 java中Proxy(代理与动态代理) Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 00:46:19 "},"源码解读/java.lang/java.lang.annotation/java.lang.annotaion.html":{"url":"源码解读/java.lang/java.lang.annotation/java.lang.annotaion.html","title":"java.lang.annotaion","keywords":"","body":"java.lang.annotaion 类/接口/注解/枚举 类型 作用 Annotation 接口 所有注释类实现的接口 AnnotationFormatError 枚举类 AnnotationTypeMismatchException 枚举类 ElementType 枚举类 注解作用范围分类 RetentionPolicy 枚举类 注解保留策略 IncompleteAnnotationException 类 Documented 注解 指示具有该类型的注释默认由javadoc和类似工具来记录 Inherited 注解 Native 注解 Repeatable 注解 Retention 注解 限定注解保留策略 Target 注解 限定注解能修饰的范围 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:44:14 "},"源码解读/java.lang/java.lang.annotation/Annotaion.html":{"url":"源码解读/java.lang/java.lang.annotation/Annotaion.html","title":"Annotaion","keywords":"","body":"Annotaion Annotation是一个接口，定义如下： Annotation是所有注解类型扩展的通用接口。 请注意，手动扩展此接口的接口不会定义注释类型。 还要注意，这个接口本身并没有定义一个注释类型。 这里面需要注意的是annotationType方法，它将返回此注释的注释类型。定义如下： Class annotationType(); Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:09:19 "},"源码解读/java.lang/java.lang.annotation/Documented.html":{"url":"源码解读/java.lang/java.lang.annotation/Documented.html","title":"Documented","keywords":"","body":"Documented 指示具有类型的注释默认由javadoc和类似工具来记录。 这种类型应该用于注释注释影响客户使用注释元素的类型的声明。 如果一个类型声明使用Documented进行注释，则其注释将成为注释元素的公共API的一部分。 该类型定义如下： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Documented { } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:12:46 "},"源码解读/java.lang/java.lang.annotation/ElementType.html":{"url":"源码解读/java.lang/java.lang.annotation/ElementType.html","title":"ElementType","keywords":"","body":"ElementType 这个枚举类型的常量提供了Java程序中注解可能出现的句法位置的简单分类。这些常量用在java.lang.annotation.Target元注释中以指定写入给定类型的注释的合法位置。 注释可能出现的语法位置被分解成声明上下文，注释应用于声明，类型上下文，注释应用于声明和表达式中使用的类型。 常量ANNOTATION_TYPE，CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE和TYPE_PARAMETER对应于JLS 9.6.4.1中的声明上下文。 有以下常量： 常量 含义 TYPE 类、接口（包括注释类型）或枚举声明 FIELD 字段声明（包括枚举常量） METHOD 方法声明 PARAMETER 常规参数声明 CONSTRUCTOR 构造方法声明 LOCAL_VARIABLE 局部变量声明 ANNOTATION_TYPE 注释类型声明 PACKAGE 包声明 TYPE_PARAMETER Type parameter declaration（since 1.8） TYPE_USE 类型声明（包括注释类型声明）和参数类型声明 例如，类型被@Target（ElementType.TYPE_USE）元注释的注释可以被写在字段的类型上（或者在字段的类型内，如果它是嵌套的，参数化的或数组类型的），并且也可以作为类声明的修饰符出现。 TYPE_USE常量包括类型声明和类型参数声明，以方便设计者为赋予注释类型语义的类型检查器。例如，如果注释类型NonNull使用@Target（ElementType.TYPE_USE）进行元注释，则类型检查器可以将@NonNull类C {...}处理为指示类C的所有变量都为非null ，同时仍然允许其他类的变量是否为非null或非非null，这取决于@NonNull是否出现在变量的声明中。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:24:10 "},"源码解读/java.lang/java.lang.annotation/Target.html":{"url":"源码解读/java.lang/java.lang.annotation/Target.html","title":"Target","keywords":"","body":"Target 指示注释类型适用的上下文。 注释类型可能适用的声明上下文和类型上下文在JLS 9.6.4.1中指定，并且在源代码中用java.lang.annotation.ElementType的枚举常量表示。 如果注解类型T中不存在@Target元注释，则类型T的注释可以被写为除了TYPE_ELEMENT声明之外的任何声明的修饰符。 该注释定义如下： @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value(); } 例如，如果一个注释的@Target限定该注释可以修饰的类型是ElementType.ANNOTATION_TYPE，那么该注释就是”元注释”能够修饰其他注释。 如果注释需要注释多种类型，可以用下面这种写法。 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD}) public @interface Bogus { ... } 该注解类有一个方法，value方法用来返回给注解能修饰的类型数组。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:33:18 "},"源码解读/java.lang/java.lang.annotation/RetentionPolicy.html":{"url":"源码解读/java.lang/java.lang.annotation/RetentionPolicy.html","title":"RetentionPolicy","keywords":"","body":"RetentionPolicy 注释保留策略。 这个枚举类型的常量描述了保留注释的各种策略。 它们与保留元注释类型一起使用来指定保留注释的时间。 有以下注释保留策略： 枚举值 含义 SOURCE 在源文件中有效（即源文件保留） CLASS 在字节码文件中有效（即class保留） RUNTIME 在运行时有效（即运行时保留） 实现的原理是反射 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:41:23 "},"源码解读/java.lang/java.lang.annotation/Retention.html":{"url":"源码解读/java.lang/java.lang.annotation/Retention.html","title":"Retention","keywords":"","body":"Retention 指示具有注释类型的注释要保留多长时间，允许的值是RetentionPolicy的枚举值，即取值只能是RetentionPolicy.SOURCE、RetentionPolicy.CLASS、RetentionPolicy.RUNTIME中的一种。 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Retention { /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value(); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-07 23:42:55 "},"源码解读/java.util/java-util.html":{"url":"源码解读/java.util/java-util.html","title":"java.util","keywords":"","body":"java.util Java工具包(java.util)是非常非常重要的包，它提供了一些使用的数据结构，包含集合框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组、日期Date类、堆栈Stack类、向量Vector类等）。 主要包含的接口如下： 接口 功能 Collection 集合体系中的根接口 Set 不能包含重复元素的集合 List 有序集合，也叫序列 Map 键值对 Queue 队列接口，设计用于在处理之前保留元素的集合。 Deque 支持两端元素插入和移除的线性集合。 Comparator 比较接口，对一些对象的集合施加了一个整体的排序。 Iterator 一个集合的迭代器 ListIterator 用于列表的迭代器，允许程序员沿任一方向遍历列表，在迭代期间修改列表，并获取列表中迭代器的当前位置。 SortedSet 进一步提供基于元素的排序的set SortedMap 进一步提供key的排序的map 常用的重要的类如下： 类名 功能 AbstractCollection 该类提供了Collection接口的骨架实现，以最大限度地减少实现此接口所需的工作量。 AbstractSet 该类提供了Set接口的骨架实现，以最大限度地减少实现此接口所需的工作量。 HashSet 此类实现了Set接口，由哈希表（实际上是HashMap实例）支持。 LinkedHashSet 哈希表和链接列表实现的Set接口，具有可预测的迭代顺序。 TreeSet AbstractList 该类提供了List接口的骨架实现，以最大限度地减少实现此接口所需的工作量。 ArrayList List接口的可调整大小的数组实现 LinkedList List和Deque接口的双向链表实现。 AbstractMap 该类提供了Map接口的骨架实现，以最大限度地减少实现此接口所需的工作量。 HashMap 基于哈希表的Map接口实现。 LinkedHashMap 哈希表和链接列表实现的Map接口，具有可预测的迭代顺序。 Hashtable 哈希表类，该类实现了一个哈希表，它将键映射到值。 WeakHashMap 基于哈希表的实现Map接口，具有弱键。 AbstractQueue 该类提供了Queue接口的骨架实现 PriorityQueue 具有优先级的队列 Collections 这个类完全由静态方法组成或返回集合。 Stack 栈类，Stack类代表一个最先进先出（LIFO）堆栈的对象。 Vector 向量类，Vector类实现可扩展的对象数组。 Formatter printf样式格式字符串的解释器。 Random 随机数生成器 StringTokenizer 字符串tokenizer类允许应用程序将字符串拆分成令牌。 Calendar 日历类 Date 日期类，Date代表一个特定的时间，以毫秒的精度。 Timer 线程调度任务以供将来在后台线程中执行的功能。 UUID 一个代表不可变的通用唯一标识符（UUID）的类。 Scanner 一个简单的文本扫描器，可以使用正则表达式解析原始类型和字符串。 BitSet 位集合类，封装了一组二进制数据的操作 参考 Java 8 API java util包概述 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-31 11:32:49 "},"源码解读/java.util/Random.html":{"url":"源码解读/java.util/Random.html","title":"Random","keywords":"","body":"Random 学到Math的random方法时候，想起来Random也可以实现随机数。但是Random类中实现的随机算法是伪随机，也就是有规则的随机。在进行随机时，随机算法的起源数字称为种子数(seed)，在种子数的基础上进行一定的变换，从而产生需要的随机数字。 相同种子数的Random对象，相同次数生成的随机数字是完全相同的。也就是说，两个种子数相同的Random对象，第一次生成的随机数字完全相同，第二次生成的随机数字也完全相同。这点在生成多个随机数字时需要特别注意。 以上是Random类的结构，方法很多，但是一样是个工具类，了解常用的方法就行。 构造方法 重载了2个构造方法。 public Random(){...} 无参数构造方法，使用一个和当前系统时间对应的相对时间有关的数字作为种子数，然后使用这个种子数构造Random对象。 public Random() { this(seedUniquifier() ^ System.nanoTime()); } public Random(long seed){...} 通过制定一个种子数进行创建。具体的实现细节不重要省略不讲。使用示例： Random r1 = new Random(10); 再次强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。 常用方法 Random作为工具类，只需要知道一些常用的方法就行。总结如下： 方法 含义 public boolean nextBoolean() 生成一个随机的boolean值，生成true和false的值几率相等，也就是都是50%的几率。 public double nextDouble() 生成一个随机的double值，数值介于[0,1.0)之间。与Math.random()方法实现效果一样 public int nextInt() 生成一个随机的int值，该值介于int的区间，也就是-2^31到2^31-1之间。如果需要制定区间，需要做数学变换 public int nextInt(int n) 生成一个随机的int值，该值介于[0,n)的区间。如果需要制定区间，需要做数学变换 public void setSeed(long seed) 重新设置Random对象中的种子数。设置完种子数以后的Random对象和相同种子数使用new关键字创建出的Random对象相同。【所以程序里无论要生成多少个随机数，使用同一个Random对象即可】 以下是Random类的一些使用示例： Random r = new Random(); 生成[0,1.0)区间的小数double d = r.nextDouble(); 生成[0,5.0)区间的小数double d = r.nextDouble() * 5; 生成[1,2.5)区间的小数double d = r.nextDouble() * 1.5 + 1; 生成任意整数int i = r.nextInt(); 生成[0,10)区间的整数int i1 = r.nextInt(10); //或者 int i2 = Math.abs(r.nextInt() % 10); 生成[0,10]区间的整数int i1 = r.nextInt(11); //或者 int i2 = Math.abs(r.nextInt() % 11); 生成[-3,15)区间的整数int i1 = r.nextInt(18) - 3; //或者 int i2 = Math.abs(r.nextInt() % 18) - 3; 几率实现问题 nextInt(int n)方法中生成的数字是均匀的，也就是说该区间内部的每个数字生成的几率是相同的。那么如果生成一个[0,100)区间的随机整数，则每个数字生成的几率应该是相同的，而且由于该区间中总计有100个整数，所以每个数字的几率都是1%。按照这个理论，可以实现程序中的几率问题。 例如：代码实现”随机生成一个整数，该整数以55%的几率生成1，以40%的几率生成2，以5%的几率生成3。\" 代码实现为： int n5 = r.nextInt(100); int m; //结果数字 if(n5 因为每个数字的机率都是1%，则任意55个数字的区间的几率就是55%，为了代码方便书写，这里使用[0,55)区间的所有整数，后续的原理一样。 当然，这里的代码可以简化，因为几率都是5%的倍数，所以只要以5%为基础来控制机率即可，下面是简化的代码实现： int n6 = r.nextInt(20); int m1; if(n6 真是机智，打开新思路！ 参考: Random类 (java.util) Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:22:35 "},"源码解读/java.util/EnumSet.html":{"url":"源码解读/java.util/EnumSet.html","title":"EnumSet","keywords":"","body":"EnumSet Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 13:29:01 "},"源码解读/java.util/EnumMap.html":{"url":"源码解读/java.util/EnumMap.html","title":"EmumMap","keywords":"","body":"EmumMap Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 13:29:01 "},"源码解读/java.util/Arrays.html":{"url":"源码解读/java.util/Arrays.html","title":"Arrays","keywords":"","body":"Arrays Arrays类是Java集合框架的一部分，提供了对数组的处理方法。注意，Arrays是java.util中的一个工具类，在java.lang.reflect中，有一个Array类，这两种的关系，与Objects和Object、Collections和Collection非常类似。Arrays是一个工具类，提供了对数组的操作，比如排序、查找、与线性表的转化，而Array则定义和操作数组，可以用Array.newInstance来创建数组（虽然我们平常不使用这种方法来创建数组），操作数组当然是通过get和set方法。 Arrays 无公共的构造方法，私有构造方法的方法体为空。 Arrays中提供了众多的数组操作方法，大部分是已经类型的重载，太多了所以就不截图了，主要提供了一下类别的方法： 查找方法 排序方法 填充方法 拷贝方法 哈希方法 判别相等方法 打印方法 转化为线性表 Arrays中重载主要是针对数据类型（eg. int[], double[], float[], long[]，对象数组）和操作范围（left, right）。 查找方法 Arrays中采取的是二分法查找，二分法有一个前提是必须有序，算法的时间复杂度是O(logn)。 下面是一个int类型数数组的二分查找算法： public static int binarySearch(int[] a, int fromIndex, int toIndex, int key) { rangeCheck(a.length, fromIndex, toIndex); return binarySearch0(a, fromIndex, toIndex, key); } private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) { if (fromIndex > toIndex) { throw new IllegalArgumentException( \"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\"); } if (fromIndex arrayLength) { throw new ArrayIndexOutOfBoundsException(toIndex); } } private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; int high = toIndex - 1; while (low >> 1; int midVal = a[mid]; if (midVal key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found. } 如果找到则返回元素下标，如果没有找到则返回元素应该插入的位置下标。注意到该方法在取mid位置的时候并可能会存在整数溢出问题！而Collections中的binarySearch则考虑到这个问题，所以更好的取mid的方法是： int mid = left + (right - left) >>> 1 ; 排序方法 Arrays定义了两类排序的方法：sort和parallelSort方法。 sort方法 sort方法可以用来对基本类型或对象数组进行排序，可自定义排序方位，但是不能自定义比较器（默认是升序）。下面是对int数组的排序： public static void sort(int[] a, int fromIndex, int toIndex) { rangeCheck(a.length, fromIndex, toIndex); DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0); } 同样首先进行范围检查，然后进行真正的排序。 在1.7之前，Arrays.sort使用的是我们普通的快速排序方法，即单轴快速排序。但是在1.7之后使用的是DualPivotQuicksort中的sort方法。该类名翻译过来就是“双轴快速排序”，顾名思义即基于两个轴来进行比较，而普通的快排是选择一个点来作为轴点。该方法的具体实现比较复杂，请参考DualPivotQuicksort类的说明。 sort方法同样可以作用域对象数组，这个可以定下面是对对象数组的排序操作： public static void sort(T[] a, int fromIndex, int toIndex, Comparator c) { if (c == null) { sort(a, fromIndex, toIndex); } else { rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); } } static final class LegacyMergeSort { private static final boolean userRequested = java.security.AccessController.doPrivileged( new sun.security.action.GetBooleanAction( \"java.util.Arrays.useLegacyMergeSort\")).booleanValue(); } 可以看到，对于对象数组，我们可以自定义比较器，当比较器赋值为null的时候，采用自然排序。如果定义了比较器，那么需要对LegacyMergeSort.userRequested进行判断，这个的意思大概就是“用户请求传统归并排序”，我们可以通过以下设置将这个变量设置为true： System.setProperty(\"java.util.Arrays.useLegacyMergeSort\", \"true\"); 当这个值为true的时候，采用的是传统的归并排序，legacyMergeSort的定义如下： private static void legacyMergeSort(T[] a, int fromIndex, int toIndex, Comparator c) { T[] aux = copyOfRange(a, fromIndex, toIndex); if (c==null) mergeSort(aux, a, fromIndex, toIndex, -fromIndex); else mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c); } private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off) { int length = high - low; // 小数组（小于7）采取插入排序 if (length low && ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--) swap(dest, j, j-1); return; } // Recursively sort halves of dest into src int destLow = low; int destHigh = high; low += off; high += off; int mid = (low + high) >>> 1; mergeSort(dest, src, low, mid, -off); mergeSort(dest, src, mid, high, -off); // If list is already sorted, just copy from src to dest. This is an // optimization that results in faster sorts for nearly ordered lists. //如果序列已经有序，那么直接将src拷贝到desc中，这个方法对于原本就接近有序的数组十分有效 if (((Comparable)src[mid-1]).compareTo(src[mid]) = high || p 然而事实上，这里实际上并不是严格意义上的”归并排序”，当待排序的对象数组很小（长度小于7）的时候要进行插入排序。其他情况采取归并排序，并且这个过程也做了优化。我们知道归并排序是将先细分再合并，当原数组拆分为两个数组，并各自进行排序，然后将两个有序数组进行合并。这里做出的优化是，先看下这个数组是不是已经有序了，依据是左边最大值和右边最小值是否有序，即src[mid-1]小于src[mid]，如果是的话，我们就可以直接将src复制拷贝到desc中，这里用的是System.arraycopy方法，而不用在进行遍历赋值。这种情况对轻微乱序的数组比较高效。如果没有有序，那就合并，合并的原理也很简单，就是将两个数组的依次比较，然后按照大小依次赋值到desc数组中。 sort方法可以总结如下： parallelSort 意思是“并行排序”，暂时不知道有何用，先不看了。 填充方法 填充就是将数组全部赋值为一个值。这个算法很简单，就是循环遍历然后赋值。这里需要注意一下对于对象数组的填充： public static void fill(Object[] a, int fromIndex, int toIndex, Object val) { rangeCheck(a.length, fromIndex, toIndex); for (int i = fromIndex; i 可以看到，数组的所有元素都赋值为同一个元素，下面是一个测试程序： private static class Person{ private String name; private short age; public Person(String name, short age) { this.name = name; this.age = age; } // omit setter and getter @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } public static void main(String[] args) { Person person = new Person(\"baobao\", (short) 18); Person[] people = new Person[3]; Arrays.fill(people, person); System.out.println(Arrays.toString(people)); //[Person{name='baobao', age=18}, Person{name='baobao', age=18}, Person{name='baobao', age=18}] people[0].setAge((short) 17); System.out.println(Arrays.toString(people)); //[Person{name='baobao', age=17}, Person{name='baobao', age=17}, Person{name='baobao', age=17}] String str = \"aaa\"; String[] strArr = new String[3]; Arrays.fill(strArr, str); System.out.println(Arrays.toString(strArr)); //[aaa, aaa, aaa] strArr[0] = \"bbb\"; System.out.println(Arrays.toString(strArr)); //[bbb, aaa, aaa] } Person对象数组果然跟我们想的一样，指向的是同一个对象，所以改变这个对象，所有的元素都受到影响。但是String数组为什么没有这种结果？因为String是不可变类，同理对于基本类型包装类的缓存区间也有这种效果。 拷贝方法 Arrays提供了copyOf和copyOfRange方法，或者定义了拷贝的范围，比前者多了一个范围检查。对于copyOf方法，同样可分为对基本数据类型数组的处理和对对象数据类型的处理： //处理基本数据类型数组 public static int[] copyOf(int[] original, int newLength) { int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } //对于对象数组 public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 两个方法的根源都是调用了System的数组拷贝方法arraycopy，但是对于对象数组，可以指定拷贝类型，这里用到了Array创建数组的方法。那么有一个疑问，System.arraycopy对于对象数组到底是浅拷贝还是深拷贝呢？做一个实验： public static void main(String[] args) { String[] origin = new String[]{\"a\", \"b\", \"c\"}; display(origin); //[a, b, c] String[] copy = Arrays.copyOf(origin, origin.length, String[].class); display(copy);//[a, b, c] System.out.print(origin[0] == copy[0]); //true } public static void display(String[] arr){ System.out.println(Arrays.toString(arr)); } 证明这是浅拷贝。 哈希方法 哈希方式将提供整个数组的哈希方法。对于数组A，设其中元素A[i]的哈希值为hash(A[i])，那么Arrays提供的哈希函数定义为 int hashValue = ∑ hash(A[i]) * 31 ^(n-i)。 是不是有点眼熟，其实这就是String求哈希的方法。hash(A[i])实际上解决的是数组元素自己求哈希的方法。 Arrays提供了两种求数组哈希值的方法：hashValue和deepHashCode。这两个的差别在于后者常用来处理多维数组。 hashCode 下面是对于long类型数组的哈希方法： public static int hashCode(long a[]) { if (a == null) return 0; int result = 1; for (long element : a) { int elementHash = (int)(element ^ (element >>> 32)); result = 31 * result + elementHash; } return result; } 其中elementHash就是单个元素的哈希值。 对于对象数组，哈希函数的定义如下： public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; } 同样很好理解。 deepHashCode deepHashCode可以用来处理多维数组，其定义如下： public static int deepHashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) { int elementHash = 0; if (element instanceof Object[]) elementHash = deepHashCode((Object[]) element); else if (element instanceof byte[]) elementHash = hashCode((byte[]) element); else if (element instanceof short[]) elementHash = hashCode((short[]) element); else if (element instanceof int[]) elementHash = hashCode((int[]) element); else if (element instanceof long[]) elementHash = hashCode((long[]) element); else if (element instanceof char[]) elementHash = hashCode((char[]) element); else if (element instanceof float[]) elementHash = hashCode((float[]) element); else if (element instanceof double[]) elementHash = hashCode((double[]) element); else if (element instanceof boolean[]) elementHash = hashCode((boolean[]) element); else if (element != null) elementHash = element.hashCode(); result = 31 * result + elementHash; } return result; } 可以看到，对于普通的对象数组和基本类型数组，这个方法和hashCode无差别，但是对于多维数组而言，其elementHash是递归的。 判别相等方法 提供了equals方法和deepEquals方法。 equals 这个算法实现很简单，就是依次比较对数组元素是否相等，对于基本数据类型，这里的“相等”用的是“=”号，对于对象，这里的“相等”用的是equals： public static boolean equals(Object[] a, Object[] a2) { if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; for (int i=0; i 可以注意到，当数组是多维数组的时候，该比较方法不太好。所以才有了deepEquals方法。 deepEquals 和deepHashCode方法一样，这个方法的设计专门服务于多维数组： public static boolean deepEquals(Object[] a1, Object[] a2) { if (a1 == a2) return true; if (a1 == null || a2==null) return false; int length = a1.length; if (a2.length != length) return false; for (int i = 0; i 可以看到，对于多维数组，它的deepEquals比较是递归的。 下面是一个测试程序。 public static void main(String[] args) { int[][] arr1 = new int[][]{ {1,1,1}, {2,3,2}, }; int[][] arr2 = new int[][]{ {1,1,1}, {2,3,2}, }; System.out.println(Arrays.equals(arr1, arr2)); //false System.out.println(Arrays.deepEquals(arr1, arr2)); //true } 打印方法 提供了toString和deepToString两个方法，同样后者专门服务与多维数组 public static String toString(long[] a) { if (a == null) return \"null\"; int iMax = a.length - 1; if (iMax == -1) return \"[]\"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) { b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(\", \"); } } public static String deepToString(Object[] a) { if (a == null) return \"null\"; int bufLen = 20 * a.length; //有长度限制 if (a.length != 0 && bufLen ()); return buf.toString(); } 下面是一个测试程序 public static void main(String[] args) { int[][] arr1 = new int[][]{ {1,1,1}, {2,3,2}, }; System.out.println(arr1.toString());//[[I@2503dbd3 System.out.println(Arrays.toString(arr1)); //[[I@4b67cf4d, [I@7ea987ac] System.out.println(Arrays.deepToString(arr1)); //[[1, 1, 1], [2, 3, 2]] } 可见数组本身的toString只能打印出该对象的十六进制的地址，而Arrays.toString能打印出一维数组的准确元素值，对于多维数组，只能用Arrays.deepToString方法打印全部值。 这个方法要眼熟啊，以前经常自己写for循环，太傻了这有现成的。 转为线性表 asList，将数组转为线性表，准确来说是ArrayList，是加上就是调用了ArrayList的构造方法。 @SafeVarargs @SuppressWarnings(\"varargs\") public static List asList(T... a) { return new ArrayList<>(a); } 需要注意的是，这个方法接受的不是一个数组，而是一个操作表，所以写法如下： List list1 = Arrays.asList(new int[]{1,2,3}); //错误 List list2 = Arrays.asList(1, 2, 3); //正确 BUT! ArrayList.asList()返回的结果并不是java.util.ArrayList的实例，而是java.util.Arrays.ArrayList的实例，这个内部类的定义如下： private static class ArrayList extends AbstractList implements RandomAccess, java.io.Serializable { private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) { a = Objects.requireNonNull(array); } @Override public int size() { return a.length; } @Override public Object[] toArray() { return a.clone(); } @Override @SuppressWarnings(\"unchecked\") public T[] toArray(T[] a) { int size = size(); if (a.length ) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length > size) a[size] = null; return a; } @Override public E get(int index) { return a[index]; } @Override public E set(int index, E element) { E oldValue = a[index]; a[index] = element; return oldValue; } @Override public int indexOf(Object o) { E[] a = this.a; if (o == null) { for (int i = 0; i spliterator() { return Spliterators.spliterator(a, Spliterator.ORDERED); } @Override public void forEach(Consumer action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } @Override public void replaceAll(UnaryOperator operator) { Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i c) { Arrays.sort(a, c); } } 可以看到，这个类的实例只有一些面向位置和判断的操作，但是没有add、remove等修改线性表的方法，所以，我们用上面的方法得到的实际上并不是我们想要的。那么如何取得java.util.ArrayList的实例呢。首先想到的方法就是用Arrays.asList的结果作为ArrayList的构造参数，如下： ArrayList list = new ArrayList(Arrays.asList(\"a\", \"b\", \"c\")); 实际上一个更加高效的代码是： String[] array = new String[]{\"a\", \"b\", \"c\"}; ArrayList list = new ArrayList(array.length); Collections.addAll(list, Arrays.asList(array)); 以上是数组转化为线性表的方法，那么如何逆操作呢？即将线性表转为数组？调用线性表的toArray方法！ Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 15:33:10 "},"源码解读/java.util/DualPivotQuicksort.html":{"url":"源码解读/java.util/DualPivotQuicksort.html","title":"DualPivotQuicksort","keywords":"","body":"DualPivotQuicksort 类名翻译过来就是“双轴快速排序”，应用于Arrays.sort的系列方法中。类结构如下： 算法是由Vladimir Yaroslavskiy在2009年研究出来的，并在2011年发布在了Java1.7。所有对外提供的都是package-private即protected，包内访问，由Arrays.sort方法调用。 该类只提供Sort，重载了不同的方法用来解决数据类型的问题。例如下面这个方法被Arrays.sort方法调用： /** * 给指定数组的指定范围排序 * @param a 指定的数组 * @param left 指定范围的第一个元素(包括) * @param right 指定范围的最后一个元素(不包括) */ static void sort(int[] a, int left, int right, int[] work, int workBase, int workLen) { // Use Quicksort on small arrays //当数组大小小于286的时候，直接使用快排 if (right - left a[k + 1]) { // descending while (++k = a[k]); //如果是降序的，找出k之后，把数列倒置 for (int lo = run[count] - 1, hi = k; ++lo work.length) { work = new int[blen]; workBase = 0; } if (odd == 0) { System.arraycopy(a, left, work, workBase, blen); b = a; bo = 0; a = work; ao = workBase - left; } else { b = work; ao = 0; bo = workBase - left; } // 合并 // 最外层循环，直到count为1，也就是栈中待合并的序列只有一个的时候，标志合并成功 // a 做原始数组，b 做目标数组 for (int last; count > 1; count = last) { // 遍历数组，合并相邻的两个升序序列 for (int k = (last = 0) + 2; k = hi || p = lo; b[i + bo] = a[i + ao] ); run[++last] = right; } //临时数组，与原始数组对调，保持a做原始数组，b 做目标数组 int[] t = a; a = b; b = t; int o = ao; ao = bo; bo = o; } } 首先，当数组长度小于QUICKSORT_THRESHOLD，调用的是另一个对于int类型数组的排序方法，在这个方法里，优先使用的是快速排序而不是归并排序，具体的可以参照下面方法的具体介绍，这里先略过。 private static void sort(int[] a, int left, int right, boolean leftmost){...} 参数leftmost表示指定的范围是否在数组的最左边。该方法的排序策略如下： 对于很小的数组（长度小于27），会使用插入排序。 选择两个点P1, P2作为轴心，比如我们可以使用第一个元素和最后一个元素。 P1必须比P2要小，否则将这两个元素交换，现在将整个数组分为四部分： 第一部分：比P1小的元素。 第二部分：比P1大但是比P2小的元素。 第三部分：比P2大的元素。 第四部分：尚未比较的部分。 在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素。 从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个。 移动L，K，G指向。 重复 4 5 步，直到第四部分没有元素。 将P1与第一部分的最后一个元素交换。将P2与第三部分的第一个元素交换。 递归的将第一二三部分排序。 图示： 算法实现如下： /** * 使用双轴快速排序给指定数组的指定范围排序 * @param a 参与排序的数组 * @param left 范围内最左边的元素的位置(包括该元素) * @param right 范围内最右边的元素的位置(包括该元素) * @param leftmost 指定的范围是否在数组的最左边 */ private static void sort(int[] a, int left, int right, boolean leftmost) { int length = right - left + 1; // 小数组使用插入排序 if (length = right) { return; } } while (a[++left] >= a[left - 1]); /** * 这里用到了成对插入排序方法，它比简单的插入排序算法效率要高一些 * 因为这个分支执行的条件是左边是有元素的 * 所以可以直接从left开始往前查找。 */ for (int k = left; ++left =a2 if (a1 > 3) + (length >> 6) + 1; // 对5段靠近中间位置的数列排序，这些元素最终会被用来做轴(下面会讲) // 他们的选定是根据大量数据积累经验确定的 int e3 = (left + right) >>> 1; // 中间值 int e2 = e3 - seventh; int e1 = e2 - seventh; int e4 = e3 + seventh; int e5 = e4 + seventh; //这里是手写的冒泡排序，没有for循环 if (a[e2] pivot2); /* * Partitioning: * * left part center part right part * +--------------------------------------------------------------+ * | pivot2 | * +--------------------------------------------------------------+ * ^ ^ ^ * | | | * less k great * * Invariants: * * all in (left, less) pivot2 * * Pointer k is the first index of ?-part. */ outer: for (int k = less - 1; ++k pivot2) { // k遇到great本次分割 while (a[great] > pivot2) { if (great-- == k) { break outer; } } if (a[great] 4/7 of the array), * swap internal pivot values to ends. * 如果中心区域太大，超过数组长度的 4/7。就先进行预处理，再参与递归排序。 * 预处理的方法是把等于pivot1的元素统一放到左边，等于pivot2的元素统一 * 放到右边,最终产生一个不包含pivot1和pivot2的数列，再拿去参与快排中的递归。 */ if (less pivot | * +-------------------------------------------------+ * ^ ^ ^ * | | | * less k great * * Invariants: * * all in (left, less) pivot * * Pointer k is the first index of ?-part. */ for (int k = less; k pivot - 把a[k]移动到右边 while (a[great] > pivot) {// 先找到右边最后一个比pivot小的值 --great; } if (a[great] 参考 DualPivotQuickSort 双轴快速排序 源码 笔记 JDK源码解析(1)——数据数组排序：Arrays.sort() Java源码解析-DualPivotQuicksort 快速排序算法原理及实现（单轴快速排序、三向切分快速排序、双轴快速排序） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-22 16:33:53 "},"源码解读/java.util/Collection.html":{"url":"源码解读/java.util/Collection.html","title":"Collection","keywords":"","body":"Collection Collection接口是Java框架系统中的根接口。“集合”表示一组对象，这些对象被称为“元素”。一些集合允许有重复元素，一些集合不允许有重复元素。一些集合是有序的，一些集合是无序的。JDK不提供任何这种接口的直接实现：它提供了更多的特定子接口的实现，如Set和List。这种接口用于传递集合，并在需要最大的通用性的情况下对它们进行操作。 包或多重复集（可能包含重复元素的无序集合）应直接实现此接口。 所有通用的Collection实现类（通常通过其子接口间接实现Collection）应该提供两个“标准”构造函数：一个void(无参数)构造函数，它创建一个空集合，以及一个具有单个参数类型的构造函数，它创建一个与其参数相同的元素的新集合。实际上，后一个构造函数允许用户复制任何集合，从而生成所需实现类型的等价集合。没有办法强制执行此约定（因为接口不能包含构造函数），而Java平台库中的所有通用Collection实现都符合要求。 对于某个集合，如果此集合不支持该操作，则此接口中包含“破坏性”方法（即修改其操作的集合的方法）将被指定为抛出UnsupportedOperationException异常。如果是这种情况，但不是必需的。例如，如果要添加的集合为空，则在不可修改的集合上调用addAll(Collection)方法可能抛出异常（也可能不抛出异常）。 某些集合实现对它们可能包含的元素有限制。例如，一些实现禁止有空元素，一些实现方式对元素的类型有限制。尝试添加不合格的元素引发免检异常，通常为NullPointerException或ClassCastException。尝试查询不合格元素的存在可能会引发异常，或者可能只是返回false；一些实现将表现出前者的行为，一些实现将展示后者。更一般地说，尝试对不符合条件的元素进行操作时，其完成不会导致将不合格元素插入到集合中没可能会导致异常，或者可能会成功执行该选项。此异常在此接口的规范中标记为“可选”。 每个集合决定自己的同步策略。在没有执行的更强保证的情况下，未定义的行为可能是由于另一个线程被入编的集合上的任何方法的额调用而导致的；这包括直接调用，将集合传递给可能执行调用的方法，并使用现有的迭代器来检查集合。 集合框架的接口中许多方法都是用equals方法来定义的。例如：contains(Object o)方法的规范说：“当且仅当此集合至少包含一个元素e才能返回true”，以便(o == null ? e == null : o.equals(e))。该规范不应该被解释为暗示使用非空参数调用Collection.contains(o)将冬至为任何元素e调用o.equals(e)。实现可以自由地实现优化，从而避免等待调用。例如，首先比较两个元素的哈希值（Object.hashCode（）规范保证具有不等的哈希码的两个对象不能相等）。更一般地，各种集合框架接口的实现可以随礼使用底层Object方法的执行行为，只要执行者认为合适。 执行递归遍历集合的一些集合操作可能会失败，并且对于自引用实例的异常，其中集合直接或间接包含自身。 这包括clone（），equals（），hashCode（）和toString（）方法。 实现可以可选地处理自参考场景，然而大多数当前实现不这样做。 上面这些是官方注解，给出了整个框架体系的概览。下面就从这个根接口开始学习集合框架。Collection接口的结构如下： public interface Collection extends Iterable 类声明，可以继承了Iterable接口，说明子类必须实现Iterable中的抽象方法，即每个实现Collection的子类都应该实现一个方法来返回这个集合上的迭代器。 int size(); 返回集合元素的个数。如果数据大于 Integer.MAX_VALUE，就只能返回Integer.MAX_VALUE。 boolean isEmpty(); 是否是空集合。是的话就返回true。 boolean contains(Object o); 集合是否包含某个特定的元素，包含的话返回true。一般的，当且仅当集合中至少包含一个元素o才会返回true。 Iterator iterator(); 实现Iterable接口，返回此集合中元素的迭代器，这个迭代器不能保障元素返回顺序，除非这个集合是提供保证的某各类的实例。 什么是迭代器。 Object[] toArray(); 返回一个包含此集合中所有元素的数组。如果此集合对其迭代返回的元素的顺序做出了某个保证，则此方法必须以相同的顺序返回元素。 返回的数据将是“安全”的，因为该集合不会保留对它的引用。（换句话说，这个方法必须分配一个新数组，即使这个数组是由数组支持的）。因此，调用者可以自由地修改返回的数组。此方法将位于数组和集合的API之间的桥梁。 T[] toArray(T[] a); 返回一个包含此集合中所有元素的数组。返回的数组的运行时类型是指定数组的运行时类型。如果集合适合指定的数组，则返回其中。否则将指定数组的运行时类型和此集合的大小分配一个新数组。 如果这个集合是适合指定的集合，有空余的空间（即该数组具有比此集合更多的元素空间，紧跟在集合结束后的数组中的元素将设置为null。（仅当调用者知道此集合不好喊任何控制元素时，此方法此有助于确定此集合的长度。） 如果此集合对齐迭代器返回的元素的顺序做出任何保证，则此方法必须以相同的顺序返回元素。和上一个toArray方法一样，此方法充当了数组和集合API之间的桥梁。此外，该方法允许精确地控制输出数组运行时类型，并且在某些情况下可以用于节省分配成本。 假设x是一个已知的只包含字符串的集合，以下代码可以用于将集合转储到新分配的String数组中： String [] y = x.toArray(new String[0]); 请注意， toArray(new Object[0]) 和toArray()相同。 boolean add(E e); 向集合中添加元素，这是一个可选操作（为什么可选？在这篇博文最初已经解释了，因为可能是破坏性方法）。如果添加成功了，则返回true，否则返回false。（比如有些集合不允许包含重复元素，则返回false）。 支持此操作的集合可能会限制这个被添加的元素e。特别的，一些集合将拒绝添加null元素，而其他集合将对可能添加的元素的类型施加限制。集合类应该在文档中明确规定可能天机哪些元素的限制。 如果集合拒绝添加特定元素，除了它已经包含该元素之外，它必须抛出一个异常（而不是返回false）。这保留了在该调用返回后，集合始终包含指定元素的不变量。 boolean remove(Object o); 从该集合中删除指定元素的单个实例（如果存在），这同样是一个可选操作。如果这个集合包含一个或多个此类元素则删除元素e，使得(o == null ? e == null : o.equals(e))。如果此集合包含指定的元素，也就是调用这个方法后集合改变了，那么该方法将返回true。 boolean containsAll(Collection c); 测试该集合是不是包含指定集合中的所有元素，是的话将返回true。 boolean addAll(Collection c); 将指定集合中的所有元素添加到此集合（可选操作）。 如果指定的集合在操作进行中被修改，则此操作的行为是未定义的。 （这意味着如果指定的集合是此集合，则此调用的行为是未定义的，并且此集合是非空的。） boolean removeAll(Collection c); 删除指定集合中包含的所有此集合的元素（可选操作）。 此调用返回后，此集合将不包含与指定集合相同的元素。 default boolean removeIf(Predicate filter){...} 这是在接口中声明了一个非抽象方法，用default关键词修饰，是JDK1.8中的新特性。定义如下： default boolean removeIf(Predicate filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator each = iterator(); while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; } 其中的Predicate也是1.8的新特性。总之，该方法删除满足给定谓词的此集合的所有元素。 在迭代或谓词中抛出的错误或运行时异常被转发给调用者。要对接口的实现着有以下要求：默认实现使用iterator（）遍历集合的所有元素。 使用Iterator.remove（）删除每个匹配元素。 如果集合的迭代器不支持删除，则会在第一个匹配元素上抛出UnsupportedOperationException异常。 boolean retainAll(Collection c); 仅保留此集合中包含在指定集合中的元素（可选操作）。 换句话说，从该集合中删除所有不包含在指定集合中的元素。 void clear(); 清空集合。该方法调用完成后，这个集合将是空集合。 boolean equals(Object o); 使用此集合来指定对象的等同性。 尽管Collection界面没有为Object.equals的一般合同添加任何规定，但是直接“实现Collection”接口的程序员（换句话说，创建一个Collection，而不是Set或List）必须保护如果他们选择覆盖Object.equals。没有必要这样做，最简单的行动是依靠Object的实现，但是实现者可能希望实现“值比较”来代替默认的“参考比较”。 （列表和集合接口要求这样的价值比较。） Object.equals方法的一般合同规定，等于必须是对称的（换句话说，a.equals（b）当且仅当b.equals（a））。 List.equals和Set.equals的合同规定列表仅等于其他列表，并设置为其他集合。因此，当将集合与任何列表或集合进行比较时，不会同时实现List或Set接口的集合类的自定义equals方法必须返回false。 （通过相同的逻辑，不可能编写正确实现Set和List接口的类。） int hashCode(); 返回此集合的哈希码值。 虽然Collection接口对Object.hashCode方法的通用合同没有添加任何规定，但程序员应该注意，覆盖Object.equals方法的任何类也必须覆盖Object.hashCode方法，以满足Object的一般约定。 特别地，c1.equals（c2）意味着c1.hashCode（）== c2.hashCode（）。 default Spliterator spliterator(){...} 非抽象方法。定义如下： default Spliterator spliterator() { return Spliterators.spliterator(this, 0); } 在此集合中的元素上创建一个Spliterator。 实施应该记录分配器报告的特征值。 如果拼接器报告Spliterator.SIZED并且此集合不包含元素，则不需要报告此类特征值。 应该通过可以返回更高效的拼接器的子类覆盖默认实现。 为了保留stream（）和parallelStream（））方法的预期懒惰行为，分配器应该具有IMMUTABLE或CONCURRENT的特征，或者具有后期绑定。 如果这些都不实用，那么重写类应该描述绑定器的绑定和结构干扰策略，并且应该使用stream（）和parallelStream（）方法来创建流，使用Spliterator的供应商，如： Stream s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) 这些要求确保由stream（）和parallelStream（）方法生成的流将在终端流操作启动时反映集合的内容。 default Stream stream(){...} default Stream stream() { return StreamSupport.stream(spliterator(), false); } 返回一个以此集合为源的顺序流。当spliterator（）方法无法返回IMMUTABLE，CONCURRENT或后期绑定的拼接器时，应该覆盖此方法。 （有关详细信息，请参阅spliterator（）） default Stream parallelStream(){...} default Stream parallelStream() { return StreamSupport.stream(spliterator(), true); } 返回一个可能并行的Stream，该集合作为其源。 该方法允许返回顺序流。当spliterator（）方法无法返回IMMUTABLE，CONCURRENT或后期绑定的拼接器时，应该覆盖此方法。 （有关详细信息，请参阅spliterator（）） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 00:27:55 "},"源码解读/java.util/Collections.html":{"url":"源码解读/java.util/Collections.html","title":"Collections","keywords":"","body":"Collections Collections是一个包装类，里面封装了很多集合框架的操作，注意这个类不能实例化，因为没有公开的构造方法，该类服务于Java的Collection框架。 Java中有很多对类与相对应的服务类，例如Collection和Collections，Array和Arrays，Object和Objects、Executor和Executors。 该类的结构如下： 总的来说，Collections为Collection框架提供了两类方法： 提供对集合进行包装的静态方法，比如把指定的集合包装成线程安全的集合、包装成不可修改的集合、包装成类型安全的集合等。 提供了若干简单而又有用的算法，比如二分查找、求最大值或最小值。 下面就这两类方法做源码解读： 集合包装方法 在Collections类结构中，我们可以看到非常多的内部类，他们的名字具有有这样的特点：分别前缀(Unmodified-、Synchronized-、Checked-、Empty-、Singleton-)和后缀（Collection框架中的接口或类），分别对应了不可变集合、线程安全集合、类型安全集合、空集合类、单元素集合类、。 不可变集合 首先是不可变集合，名字统一为UnmodifiedXXX，顾名思义，当集合被包装成不可变集合的时候，如果对集合进行操作，将抛出UnsupportedOperationException。例如下面这个例子： public static void main(String[] args) { List list = new ArrayList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); List unmodifiableList = Collections.unmodifiableList(list); System.out.print(list); //[a, b, c] try { unmodifiableList.add(\"d\");//此处将抛出异常 }catch (Exception e){ System.out.println(e.getMessage()); } list.add(\"d\"); System.out.println(list); //[a, b, c, d, d] } 上面这个测试程序中，当我们使用Collections.unmodifiableList对list进行包装后，取得该方法的返回值。当我们尝试就该不可变集合进行操作时候，会抛出异常，这一点是符合我们预期的。然而奇怪的是，我们仍旧可以对原集合进行操作，这就说明Collections类提供的对集合的不可变包装实际上是一个假的包装。为什么会这样？我们从源码就可以看出： static class UnmodifiableList extends UnmodifiableCollection implements List { private static final long serialVersionUID = -283967356065247728L; final List list; UnmodifiableList(List list) { super(list); this.list = list; } public boolean equals(Object o) {return o == this || list.equals(o);} public int hashCode() {return list.hashCode();} public E get(int index) {return list.get(index);} public E set(int index, E element) { throw new UnsupportedOperationException(); } public void add(int index, E element) { throw new UnsupportedOperationException(); } public E remove(int index) { throw new UnsupportedOperationException(); } public int indexOf(Object o) {return list.indexOf(o);} public int lastIndexOf(Object o) {return list.lastIndexOf(o);} public boolean addAll(int index, Collection c) { throw new UnsupportedOperationException(); } @Override public void replaceAll(UnaryOperator operator) { throw new UnsupportedOperationException(); } @Override public void sort(Comparator c) { throw new UnsupportedOperationException(); } public ListIterator listIterator() {return listIterator(0);} public ListIterator listIterator(final int index) { return new ListIterator() { private final ListIterator i = list.listIterator(index); public boolean hasNext() {return i.hasNext();} public E next() {return i.next();} public boolean hasPrevious() {return i.hasPrevious();} public E previous() {return i.previous();} public int nextIndex() {return i.nextIndex();} public int previousIndex() {return i.previousIndex();} public void remove() { throw new UnsupportedOperationException(); } public void set(E e) { throw new UnsupportedOperationException(); } public void add(E e) { throw new UnsupportedOperationException(); } @Override public void forEachRemaining(Consumer action) { i.forEachRemaining(action); } }; } public List subList(int fromIndex, int toIndex) { return new UnmodifiableList<>(list.subList(fromIndex, toIndex)); } /** * UnmodifiableRandomAccessList instances are serialized as * UnmodifiableList instances to allow them to be deserialized * in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). * This method inverts the transformation. As a beneficial * side-effect, it also grafts the RandomAccess marker onto * UnmodifiableList instances that were serialized in pre-1.4 JREs. * * Note: Unfortunately, UnmodifiableRandomAccessList instances * serialized in 1.4.1 and deserialized in 1.4 will become * UnmodifiableList instances, as this method was missing in 1.4. */ private Object readResolve() { return (list instanceof RandomAccess ? new UnmodifiableRandomAccessList<>(list) : this); } } 以上是UnmodifiableList内部类的源码实现，可见该类实例的add方法内直接抛出了异常，由此实现“不可变”，但是原来的list并收到任何影响，可以这么想，内存中有一片区域保存了一个集合，有list和unmodifiedList两个指针指向这个地方，其中unmodifiedList指针的add方法被禁止，但是list指针仍旧可用，所以仍能操作这片内存。 另外需要注意的点，当使用ArrayList的实例和LinkedList的实例调用Collections.unmodifiedList创建得到的不可变集合是不一样的，该方法源码如下： public static List unmodifiableList(List list) { return (list instanceof RandomAccess ? new UnmodifiableRandomAccessList<>(list) : new UnmodifiableList<>(list)); } 因为ArrayList实现了RandomAccess接口，所以返回的是UnmodifiableRandomAccessList实例，而后者返回的是UnmodifiableList实例。 在Collections中，可以通过以下方法得到相应的不可变集合类实例： unmodifiableCollection unmodifiableList unmodifiableMap unmodifiableSet unmodifiableSortedMap unmodifiableSortedSet 线程安全集合 阅读源码我们可以知道，Collections中我们常用的一些容器类是非线程安全的，有些线程安全类比如HashTable我们又不常用，所以Collections就将非线程安全的容器类包装成线程安全类。他们的命名是\"SynchronizedXXX\"。以SynchronizedList内部类为例，源码如下： static class SynchronizedList extends SynchronizedCollection implements List { private static final long serialVersionUID = -7754090372962971524L; final List list; SynchronizedList(List list) { super(list); this.list = list; } SynchronizedList(List list, Object mutex) { super(list, mutex); this.list = list; } public boolean equals(Object o) { if (this == o) return true; synchronized (mutex) {return list.equals(o);} } public int hashCode() { synchronized (mutex) {return list.hashCode();} } public E get(int index) { synchronized (mutex) {return list.get(index);} } public E set(int index, E element) { synchronized (mutex) {return list.set(index, element);} } public void add(int index, E element) { synchronized (mutex) {list.add(index, element);} } public E remove(int index) { synchronized (mutex) {return list.remove(index);} } public int indexOf(Object o) { synchronized (mutex) {return list.indexOf(o);} } public int lastIndexOf(Object o) { synchronized (mutex) {return list.lastIndexOf(o);} } public boolean addAll(int index, Collection c) { synchronized (mutex) {return list.addAll(index, c);} } public ListIterator listIterator() { return list.listIterator(); // Must be manually synched by user } public ListIterator listIterator(int index) { return list.listIterator(index); // Must be manually synched by user } public List subList(int fromIndex, int toIndex) { synchronized (mutex) { return new SynchronizedList<>(list.subList(fromIndex, toIndex), mutex); } } @Override public void replaceAll(UnaryOperator operator) { synchronized (mutex) {list.replaceAll(operator);} } @Override public void sort(Comparator c) { synchronized (mutex) {list.sort(c);} } /** * SynchronizedRandomAccessList instances are serialized as * SynchronizedList instances to allow them to be deserialized * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). * This method inverts the transformation. As a beneficial * side-effect, it also grafts the RandomAccess marker onto * SynchronizedList instances that were serialized in pre-1.4 JREs. * * Note: Unfortunately, SynchronizedRandomAccessList instances * serialized in 1.4.1 and deserialized in 1.4 will become * SynchronizedList instances, as this method was missing in 1.4. */ private Object readResolve() { return (list instanceof RandomAccess ? new SynchronizedRandomAccessList<>(list) : this); } } 很容易明白该类是如何实现线程安全的，就是将每个方法体都包含进同步块中，这样就实现了同步。 与不可变集合一样，线程安全集合同样存在“假安全”的问题。另外，对于SynchronizedList实例的创建同样考虑了RandomAccess接口。 在Collections中，可以通过以下方法得到相应的线程安全实例： synchronizedCollection synchronizedSet synchronizedSortedSet synchronizedNavigableSet synchronizedList synchronizedMap synchronizedSortedMap synchronizedNavigableMap 类型安全集合 什么叫做类型安全？就是在插入元素的时候会检查元素类型？比如元素被定义为String类型，当插入的元素是其他类型的时候就会抛出ClassCastExceptions异常。 难道泛型的使用没有解决这个问题么？ 在Collections中，可以通过以下方法得到相应的类型安全集合实例： checkedCollection checkedList checkedMap checkedSet checkedSortedMap checkedSortedSet 空集合 空集合是没有元素在这些集合中，特别需要主要的是返回的集合都是只读的。只要更改值就会抛出UnsupportedOperationException异常。 集合为空且只读？那要它何用？ Collections中定义了三个静态常量： public static final List EMPTY_LIST = new EmptyList<>(); public static final Map EMPTY_MAP = new EmptyMap<>(); public static final Set EMPTY_SET = new EmptySet<>(); 我们可以使用以下方法将其返回： Collections.emptyList()—返回只读的空LIST 集合 Collections.emptyMap()——返回只读的空MAP集合 Collections.emptySet()——返回只读的空SET集合 单元素集合 Collections中的单元素集合指的是集合只有一个元素而且集合只读。内部类命名是SingletonXXX。内部类和对应的创建方法如下： 内部类名称 获取方法 SingletonSet singleton() singletonIterator Iterator() SingletonList singletonList() SingletonMap singletonMap() 这个有什么用呢? 简单算法 Collections类在开头定义了这样几个常量： private static final int BINARYSEARCH_THRESHOLD = 5000; private static final int REVERSE_THRESHOLD = 18; private static final int SHUFFLE_THRESHOLD = 5; private static final int FILL_THRESHOLD = 25; private static final int ROTATE_THRESHOLD = 100; private static final int COPY_THRESHOLD = 10; private static final int REPLACEALL_THRESHOLD = 11; private static final int INDEXOFSUBLIST_THRESHOLD = 35; 虽然暂时不懂这些数字有什么用（名字听起来好像是算法的阈值），但是至少这些命名告诉我们Collections工具类提供了哪些算法。下面我们就看看这些算法的实现。 二分查找(binarySearch) 这是查找算法的最简单有效的算法，二分查找必须要求list是有序的，在无需的集合中进行二分查找没有任何意义。如果list中有多个key，不能保证哪个key被找到。 在Collections中重载了两个binarySearch方法： /** * * 使用二分查找在指定List中查找指定元素key。 List中的元素必须是有序的。如果List中有多个key，不能确保哪个key值被找到。 * 如果List不是有序的，返回的值没有任何意义 * * 对于随机访问列表来说，时间复杂度为O(log(n)),比如1024个数只需要查找log2(1024)=10次， * log2(n)是最坏的情况，即最坏的情况下都只需要找10次 * 对于链表来说，查找中间元素的时间复杂度为O(n),元素比较的时间复杂度为O(log(n)) * * @return 查找元素的索引。如果返回的是负数表明找不到此元素，但可以用返回值计算 * 应该将key插入到集合什么位置，任然能使集合有序(如果需要插入key值的话)。 公式：point = -i - 1 */ public static int binarySearch(List> list, T key) { if (list instanceof RandomAccess || list.size() int binarySearch(List list, T key, Comparator c) { if (c==null) return binarySearch((List>) list, key); if (list instanceof RandomAccess || list.size() 第一个binarySearch可以接受元素类型为Comparable实例的list集合，而具体的实现方法是类似。我们可以看到，当list是RandomAccess实例的时候，比如list的类型为Arraylist，或者集合元素小于阈值，即5000的时候，将采用indexedBinarySearch方法，否则采用iteratorBinarySearch方法。这两个方法有什么不同呢？为什么要区别对待。 //indexedBinarySearch采取索引化二分查找 private static int indexedBinarySearch(List> list, T key) { int low = 0; // 元素所在范围的下界 int high = list.size() - 1; // 上界 while (low >> 1; // 指定元素与中间值比较 Comparable midVal = list.get(mid); int cmp = midVal.compareTo(key); // 重新设置上界和下界 if (cmp 0) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found } //iteratorBinarySearch采取迭代式二分查找。 private static int iteratorBinarySearch(List> list, T key) { int low = 0; int high = list.size() - 1; ListIterator> i = list.listIterator(); while (low >> 1; Comparable midVal = get(i, mid); int cmp = midVal.compareTo(key); if (cmp 0) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found } private static T get(ListIterator i, int index) { T obj = null; int pos = i.nextIndex(); if (pos index); } return obj; } 可以看到两个方法的之处在于如何取得位于mid位置的元素，数组本身就是一个索引，所以使用下标访问实现随机存取。而对于链表来说，如果从链表头开始遍历，那么会非常耗时，所以借助迭代器进行遍历。这里的迭代器是双向迭代器，能很快找到对应位置上的元素。 反转(reverse) 反转即将集合的顺序逆置。 public static void reverse(List list) { int size = list.size(); // 如果是size小于18的链表或是基于随机访问的列表 if (size > 1, j = size - 1; i > 1; i list, int i, int j) { // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method final List l = list; l.set(i, l.set(j, l.get(i))); } 可见，反转的思想是交换。对于随机访问列表比较好理解，对于链表而言，我们以迭代器的来实现交换。注意的是迭代器在取得值的同时，会修改图标，所以我们不用认为控制，但是需要控制停下来的时候，以免走过头。 混排（shuffle） 混排的意思就是随意排列，如果随机源是公平的，那么随便哪种顺序都是有可能的。这种算法在碰运气或洗牌的程序中比较有用。Collections定义了两个重载的shuffle，区别在于是否任务定义随机源： /** * * 对指定列表中的元素进行混排 */ public static void shuffle(List list) { Random rnd = r; if (rnd == null) r = rnd = new Random(); // harmless race. shuffle(list, rnd); } private static Random r; /** * * 提供一个随机数生成器对指定List进行混排， 时间复杂度O(n) * * 基本算法思想为： 逆向遍历list，从最后一个元素到第二个元素，然后重复交换当前位置 与随机产生的位置的元素值。 * * 如果list不是基于随机访问并且其size>5,会先把List中的复制到数组中， 然后对数组进行混排，再把数组中的元素重新填入List中。 * 这样做为了避免迭代器大跨度查找元素影响效率 */ public static void shuffle(List list, Random rnd) { int size = list.size(); if (size 1; i--) // 从i-1个位置开始与随机位置元素交换值 swap(list, i - 1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // 先转化为数组 // 对数组进行混排 for (int i = size; i > 1; i--) swap(arr, i - 1, rnd.nextInt(i)); // 然后把数组中的元素重新填入List ListIterator it = list.listIterator(); for (int i = 0; i 注释已经写的很明白了，它的原理同样是交换。 填充(fill) 使用指定元素替换指定列表中的所有元素，注意是所有元素。定义如下： /** * * 用obj替换List中的所有元素 依次遍历赋值即可 */ public static void fill(List list, T obj) { int size = list.size(); if (size itr = list.listIterator(); for (int i=0; i 思想就是遍历赋值。 轮换（rotate） 轮换的意思是根据指定的距离轮转指定列表中的元素。比如类似于[t, a, n, k, s , w]指定长度为2或者-4的轮换之后，将变成[s, w, t, a, n , k]。这个算法经常被考到。 /** * * 旋转移位List中的元素通过指定的distance。每个元素移动后的位置为： (i + * distance)%list.size.此方法不会改变列表的长度 * distance表示移动的位置，可以这么理解：正数表示向后移，负数表示向前移，0表示不移动 * */ public static void rotate(List list, int distance) { if (list instanceof RandomAccess || list.size() void rotate1(List list, int distance) { int size = list.size(); if (size == 0) return; distance = distance % size; // distance始终处于0到size(不包括)之间 if (distance = size) i -= size; // 超出size就减去size displaced = list.set(i, displaced); // 为新位置赋原来的值 nMoved++; // 如果等于size证明全部替换完毕 } while (i != cycleStart); // 依次类推，求新位置的新位置！ } } private static void rotate2(List list, int distance) { int size = list.size(); if (size == 0) return; int mid = -distance % size; if (mid 这两个方法都非常有启发性。 对于小线性表或者可随机访问到的线性表，使用的是轮换的方法，首先当前下标i设置为0，然后寻找这个下标应该移动到的数组数组中的位置，将该值设置到这个位置，取得这个位置原来的值displace和这个位置的索引i，循环上面步骤，如果发现这个循环已经到了头，即i=cycleStart，那么让cycleStart前进一步，继续下一个循环，这里需要记录下修改的次数，当修改的次数为线性表的长度的时候，表示全部轮换完成。比如对于数组[1,2,3,4,5,6]，首先将index=0的元素1交换到下标为4（因为 0 + 4 = 4 6， 则8 - 6 = 2），然后将index= 2上的元素3交换到位置（2 + 4 = 6， 所以6 - 6 =0），此时发现i=cycleStart，所以内层循环结束，让cycleStart增加1，即此时从index= 2，同样进行上述步骤。 对于链表及大数组现象表来说，实现的方法非常巧妙，使用了三次的倒置操作！对于[1,2,3,4,5,6]来说，当distance为2时候，-2%6的结果是-2，最后取得mid=4，两次reverse过后变成[4,3,2,1,6,5]，最后一次reverse之后变成[5,6,1,2,3,4]，非常神奇！ 拷贝方法（copy） 这个没什么好解释的，就是遍历赋值。同样对随机存取的数组和链表做了不同的处理。定义如下： /** * * 复制源列表的所有元素到目标列表， 如果src.size > dest.size 将抛出一个异常 如果src.size void copy(List dest, List src) { int srcSize = src.size(); if (srcSize > dest.size()) throw new IndexOutOfBoundsException(\"Source does not fit in dest\"); if (srcSize di = dest.listIterator(); ListIterator si = src.listIterator(); for (int i = 0; i 替代方法（replaceAll） 把指定集合中所有与oladVal相等的元素替换成newVal 只要list发生了改变就返回true。定义如下： public static boolean replaceAll(List list, T oldVal, T newVal) { boolean result = false; int size = list.size(); if (size itr = list.listIterator(); if (oldVal == null) { for (int i = 0; i 遍历比较，匹配则赋值。非常好理解。 子串匹配（indexOfSubList和lastIndexOfSubList） indexOfSubList用来返回指定源列表中第一次出现指定目标列表的起始位置，如果没有出现这样的列表，则返回-1；lastIndexOfSubList用来返回指定源列表中最后一次出现指定目标列表的起始位置，如果没有出现这样的列表，则返回-1。 /** * * target是否是source的子集，如果是返回target第一个元素的索引， 否则返回-1。 * 其实这里和串的模式匹配差不多。这里使用的是基本的回溯法。 * */ public static int indexOfSubList(List source, List target) { int sourceSize = source.size(); int targetSize = target.size(); int maxCandidate = sourceSize - targetSize; if (sourceSize si = source.listIterator(); nextCand: for (int candidate = 0; candidate ti = target.listIterator(); for (int i = 0; i source, List target) { int sourceSize = source.size(); int targetSize = target.size(); int maxCandidate = sourceSize - targetSize; if (sourceSize = 0; candidate--) { for (int i = 0, j = candidate; i si = source.listIterator(maxCandidate); nextCand: for (int candidate = maxCandidate; candidate >= 0; candidate--) { ListIterator ti = target.listIterator(); for (int i = 0; i 排序（Sort） sort方法实现对集合的排序。定义如下 public static > void sort(List list) { list.sort(null); } 在JDK1.8中，List接口通过default关键字实现了sort方法： @SuppressWarnings({\"unchecked\", \"rawtypes\"}) default void sort(Comparator c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } 可见，底层实现的时候是调用的Arrays的Sort方法，然后在将排好序的数组重新赋值。 最大(max)和最小(min) 求出集合中的最大元素和最小元素，方法很简单，就是用一个变量保存当前最小或最大值，然后遍历集合，更新该值，最后返回这个值即可。定义如下： /** * * 返回集合中的最小元素。前提是其中的元素都是可比的，即实现了Comparable接口 找出一个通用的算法其实不容易，尽管它的思想不难。 * 反正要依次遍历完所有元素，所以直接用了迭代器 */ public static > T min(Collection coll) { Iterator i = coll.iterator(); T candidate = i.next(); while (i.hasNext()) { T next = i.next(); if (next.compareTo(candidate) T min(Collection coll, Comparator comp) { if (comp == null) // 返回默认比较器，其实默认比较器什么也不做，只是看集合元素是否实现了Comparable接口， // 否则抛出ClassCastException return (T) min((Collection) (Collection) coll); Iterator i = coll.iterator(); T candidate = i.next(); // 假设第一个元素为最小元素 while (i.hasNext()) { T next = i.next(); if (comp.compare(next, candidate) > T max(Collection coll) { Iterator i = coll.iterator(); T candidate = i.next(); while (i.hasNext()) { T next = i.next(); if (next.compareTo(candidate) > 0) candidate = next; } return candidate; } /** * 根据指定比较器求集合中最大元素 */ public static T max(Collection coll, Comparator comp) { if (comp == null) return (T) max((Collection) (Collection) coll); Iterator i = coll.iterator(); T candidate = i.next(); while (i.hasNext()) { T next = i.next(); if (comp.compare(next, candidate) > 0) candidate = next; } return candidate; } 阅读源码可以知道，Collections实现了一些简单有用的算法，其中对随机访问的列表和链表分别做了特殊处理，前者采用索引式存取，后者采取迭代器，提高了效率。同时其中一些算法的思路值得好好咀嚼，比如对于链表的rotate的处理，非常巧妙！ 参考 Java Collections和Arrays工具类剖析 理解不可变集合 | Guava Immutable与JDK unmodifiableList Collections源码 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 13:06:42 "},"源码解读/java.util/Set.html":{"url":"源码解读/java.util/Set.html","title":"Set","keywords":"","body":"Set Set也是一个接口，直接继承Collection接口，不过它对元素做了一些限制。什么限制？不包含重复元素。更正式地说，Set不包含一对元素e1和e2，使得e1.equals(e2)和最多一个null元素。正如它的名字Set所暗示的那样，这个接口模拟了\"数学集合\"的抽象。Set的接口结构如下： 可以看到这些抽象方法继承自其父类Collection。我们需要到具体的实现类才能具体的实现。Set接口有三个常用的实现类：HashSet、LinkedHashSet和TreeSet。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 17:55:40 "},"源码解读/java.util/HashSet.html":{"url":"源码解读/java.util/HashSet.html","title":"HashSet","keywords":"","body":"HashSet HashSet是常用的Set接口的实现。此类实现了Set接口，由哈希表（实际上是HashMap实例）支持。 对集合的迭代次序不作任何保证; 特别是不能保证次序在一段时间内保持不变。 此类允许null元素。以下是该类的结构： public class HashSet extends AbstractSet implements Set, Cloneable, java.io.Serializable 类声明，可以看到该类继承了AbstractSet，实现了Set、Cloneable和Serializable接口。 构造函数 重载了5个构造函数。 public HashSet(){...} 无参构造函数。定义如下： public HashSet() { map = new HashMap<>(); } 其中的map是该类的私有成员变量，声明如下： private transient HashMap map; 注意到这是一个HashMap的实例，用关键词transient修饰，表明不是持久化。HashSet中的元素都是作为map中的key存放的。也可见，其实HashSet内部是由HashMap的实例来实现的。在这个无参构造函数中，未指定初始化大小和装载因子，根据HashMap的知识可知，初始化大小为16，装载因子是0.75。 public HashSet(Collection c){...} 创建一个包含指定集合中的元素的HashSet实例。定义如下： public HashSet(Collection c) { map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } 可以注意到的是初始化HashMap实例的时候，指定的装载因子是0.75，而初始化大小是指定的集合的4/3倍和16中的最大值。之后用addAll方法将集合中的元素加入到集合中。 public HashSet(int initialCapacity, float loadFactor){...} 直接指定了HashMap的初始化大小和装载因子的大小。定义略。 public HashSet(int initialCapacity){...} 只指定了初始化大小，装载因子默认为0.75。 HashSet(int initialCapacity, float loadFactor, boolean dummy){...} 注意该构造函数可访问修饰符是default，即包内访问，定义如下： HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap<>(initialCapacity, loadFactor); } 注意到这个方法的第三个参数并没有什么用，只是为了能够重载一个构造函数（重载要保证方法名相同，参数表不同）而已。特别要注意的是，这个方法里的map的实现是LinkedHashMap。同样可以指定初始化大小和装载因子。 public Iterator iterator(){...} 返回迭代器，不保证顺序。 public Iterator iterator() { return map.keySet().iterator(); } public int size(){...} 用来获取集合中包含的元素的个数。 public int size() { return map.size(); } public boolean isEmpty(){...} 检测集合是否为空。 public boolean isEmpty() { return map.isEmpty(); } public boolean contains(Object o){...} 检测集合是否含有某个元素，当且仅当至少存在一个元素e，使得(o==null&&e==null&&o.equals(e))时返回true。 public boolean add(E e) 添加一个元素e。 public boolean add(E e) { return map.put(e, PRESENT)==null; } 其中PRESENT是该类定义的一个静态常量，声明如下： private static final Object PRESENT = new Object(); 文档中对这个量的解释是：与支持map中的对象相关联的虚拟值。 暂时不懂是什么意思，等学习了HashMap之后再回过头来看。 前面说到Set不允许重复元素，所以当指定的对象已经在集合中存在，则不做任何改变返回false；如果原本不存在该对象，则添加元素并返回true。 public boolean remove(Object o) {...} 从集合中移除某个元素。如果该集合中确实包含该元素则移除元素并返回true；如果不包含，则返回false。该方法被调用后，集合中不再含有该元素。定义如下： public boolean remove(Object o) { return map.remove(o)==PRESENT; } public void clear(){...} 清空所有元素，指定该方法后，集合将不再含有元素。定义如下： public void clear() { map.clear(); } public Object clone() {...} 复制得到一个新的HashSet实例，该方法是浅拷贝！什么是“浅拷贝”？什么是“深拷贝”？ 浅拷贝是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝。 深拷贝是指在拷贝对象时，同时会对引用指向的对象进行拷贝。 区别就在于是否对 对象中的引用变量所指向的对象进行拷贝。 参考谈Java中的深拷贝和浅拷贝（转载），“浅拷贝”和“深拷贝”的区别会在《集合框架》专题中具体讲到。 没有对引用指向的对象进行拷贝。 @SuppressWarnings(\"unchecked\") public Object clone() { try { HashSet newSet = (HashSet) super.clone(); newSet.map = (HashMap) map.clone(); return newSet; } catch (CloneNotSupportedException e) { throw new InternalError(e); } } public Spliterator spliterator(){...} 这是JDK1.8新方法。Spliterator是一个并行迭代器。定义如下： public Spliterator spliterator() { return new HashMap.KeySpliterator(map, 0, -1, 0, 0); } 由于还没有学到Spliterator，所以这个方法的讲解先放一下。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-14 20:11:55 "},"源码解读/java.util/LinkedHashSet.html":{"url":"源码解读/java.util/LinkedHashSet.html","title":"LinkedHashSet","keywords":"","body":"LinkedHashSet 在学习HashSet的时候，遇到一个三个参数的构造方法，该方法中，用来存储元素的hashMap被定义为LinkedHashMap的实例，所以创建出来的HashSet就是LinkedHashSet。 该类的结构如下： 可以看到，结构非常简单，只是定义了几个构造方法。 public class LinkedHashSet extends HashSet implements Set, Cloneable, java.io.Serializable 类声明。可以看该类继承了HashSet接口。 构造方法 重载了5个构造方法。调用的都是HashSet中三个参数的构造方法。默认初始化容量为16，装载因子为0.75。 public LinkedHashSet() { super(16, .75f, true); } 需要注意的是以集合为参数的构造方法： public LinkedHashSet(Collection c) { super(Math.max(2*c.size(), 11), .75f, true); addAll(c); } 初始化大小在2倍的集合容量与11中选择较大者。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-14 20:37:13 "},"源码解读/java.util/TreeSet.html":{"url":"源码解读/java.util/TreeSet.html","title":"TreeSet","keywords":"","body":"TreeSet Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-14 20:43:55 "},"源码解读/java.util/List.html":{"url":"源码解读/java.util/List.html","title":"List","keywords":"","body":"List 有序集合（也称为序列）。 该接口的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。与集合不同的是，序列可以允许重复元素，通常也允许多个空元素。 List接口结构如下： public interface List extends Collection 接口声明，该接口继承了Collection接口。所以大部分的抽象方法是直接继承了Collection接口的方法。这里不再赘述，只列出其本身新声明的方法。 E get(int index); 用来返回特定位置的元素。可能会出现越界异常。 E set(int index, E element); 将指定位置上的元素变更为指定的元素。 void add(int index, E element); 添加一个元素到指定位置。 E remove(int index); 删除指定位置上的元素。 int indexOf(Object o); 返回元素第一次出现的位置（下标最小），如果不存在该元素就返回-1。 int lastIndexOf(Object o); 返回元素最后一次出现的位置（下标最大），如果不存在该元素就返回-1。 ListIterator listIterator(); 返回序列迭代器。 ListIterator listIterator(int index); 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 指定的索引表示初次调用next返回的第一个元素。 对previous的初始调用将返回具有指定索引的元素减1。 List subList(int fromIndex, int toIndex); 返回此列表中指定的fromIndex（包括）和toIndex之间的独占视图。 （如果fromIndex和toIndex相等，返回的列表为空。）返回的列表由此列表支持，因此返回列表中的非结构性更改将反映在此列表中，反之亦然。 返回的列表支持此列表支持的所有可选列表操作。 这种方法消除了对显式范围操作（通常针对数组存在的排序）的需要。 任何期望列表的操作都可以通过传递一个子列表视图而不是整个列表来用作范围操作。 例如，以下语句从列表中删除了一系列元素： list.subList(from, to).clear(); 可以为indexOf和lastIndexOf构造类似的成语，并且Collections类中的所有算法都可以应用于子列表。 如果支持列表（即，此列表）以除了通过返回的列表之外的任何方式进行结构修改，则此方法返回的列表的语义将变得未定义。 （结构修改是那些改变此列表的大小，或以其他方式扰乱它，使得正在进行的迭代可能产生不正确的结果）。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-31 23:10:22 "},"源码解读/java.util/Iterator.html":{"url":"源码解读/java.util/Iterator.html","title":"Iterator","keywords":"","body":"Iterator 迭代器。注意这是一个接口而不是一个类。作为一种设计模式，迭代器可以用于遍历一个对象，对于这个对象的底层结构开发人员不必去了解。java中的Iterator一般称为“轻量级”对象，创建它的代价是比较小的。 Iterator是一个集合的迭代器。 迭代器代替Java集合框架中的Enumeration。 以下两点是Iterator不同于Enumeration的地方： 迭代器允许调用者在迭代期间从底层集合中删除元素，并具有明确定义的语义。 方法名称得到改进。 boolean hasNext(); 如果迭代器有更多的元素，则返回true。 E next(); 用来返回迭代中的下一个元素，迭代出的元素是集合中元素的拷贝。特别需要注意的是，在返回下一个元素的时候，同时，迭代游标cursor后移。 所以看下面这段代码： List suits = ...; List ranks = ...; List sortedDeck = new ArrayList(); // BROKEN - throws NoSuchElementException! for (Iterator i = suits.iterator(); i.hasNext(); ) for (Iterator j = ranks.iterator(); j.hasNext(); ) sortedDeck.add(new Card(i.next(), j.next())); 这是一个常常会犯错的错误，执行后将会抛出NoSuchElementException异常，原因在于在内层循环中suits的next方法执行了太多次，而这个方法每执行一次都会将迭代游标后移，所以最后会过早将元素读完，抛出异常。正确的写法如下： for (Iterator i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator j = ranks.iterator(); j.hasNext() ; ) { sortedDeck.add(new Card(suit, j.next())); } } 上面这种写法是对的，但是代码很臃肿，更优雅的方式是使用for-each loop: for (Suit suit : suits ) { for (Rank rank : ranks) { sortedDeck.add(new Card(suit, rank)); } } default void remove(){...} 用来删除最近一次已经迭代出去的那个元素。定义如下： default void remove() { throw new UnsupportedOperationException(\"remove\"); } 这个方法使用是有限制的，否则会抛出UnsupportedOperationException异常。什么限制呢？ 只有当next执行完之后，才能调用remove函数。 比如要删除第一个元素，不能直接调用remove方法，而是要先next一下。 上面三个方法一般配合使用（尤其是hasNext和next方法，而remove方法一般很少使用，以至于Eclipse自动补齐时常把它忽略），一个例子如下： public static void main(String[] args) { List list = new ArrayList<>(); list.add(1); list.add(2); list.add(3); //不适用for-each循环而手动迭代 Iterator iter = list.iterator(); // 获取ArrayList的迭代器 while (iter.hasNext()){ //探测是否能够继续探测 System.out.println(iter.next());//可以继续探测的时，取出本次迭代的元素 iter.remove(); } for (Integer i : list){ System.out.println(i); } } 最后一个foreach循环认仍能够打印出list中的内容，这说明了，迭代器中的内容是集合内容的拷贝。注意，是内容的拷贝。那么对迭代器的修改会影响原来的集合的内容么？ 有可能会！如果集合内容是基本类型，那么拷贝就是复制一份值。如果集合保存的是对象，其实质是保存的一份对象的引用，那么迭代器拷贝的也是一份引用。这个时候也要分为两种情况，如果对象是可变内容，此时通过迭代器的操作会影响集合的内容。如果对象是不可变的，如String，基本数据包装类型Integer等，那对迭代器的操作是不会反映到原集合的。下面是一个验证程序： public class IteratorTest { public static void main(String[] args) { List list = new ArrayList<>(); list.add(new Person(\"Tom\")); for (Person pr : list){ pr.setName(\"Jerry\"); } System.out.println(list.get(0).getName()); //Jerry } } class Person { private String name; public Person(String name) { this.name = (name == null? \"\" : name); } public String getName() { return name; } public void setName(String name) { if (name == null){ name = \"\"; } this.name = name; } } 程序最后输出是\"Jerry\"而不是\"Tom\"，可见当集合内容为可变对象的时候，对迭代器的修改确实可以改变集合原内容。 实现自己的迭代器类 public interface IteratorTest { public static void main(String[] args) { MyString s = new MyString(\"1234567\"); for (char c : s){ System.out.print(c + \" \"); } } } class MyString implements Iterable{ private int length = 0; private String inners = null; public MyString(String str) { this.inners = str; this.length = str.length(); } @Override public Iterator iterator() { class iter implements Iterator { private int cur = 0; @Override public boolean hasNext() { return cur != length; } @Override public Character next() { Character ch = inners.charAt(cur); cur ++; return ch; } } return new iter(); } } 程序输出： 1 2 3 4 5 6 7 参考： Java迭代 : Iterator和Iterable接口 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 20:53:18 "},"源码解读/java.util/ListIterator.html":{"url":"源码解读/java.util/ListIterator.html","title":"ListIterator","keywords":"","body":"ListIterator ListIterator是用于列表的迭代器，允许程序员沿任一方法遍历列表，在迭代期间修改列表，并获取列表中迭代器的当前位置。ListIterator没有当前元素，它的光标位置总是位于通过对previous（）的调用返回的元素和由next（）调用返回的元素之间。 长度为n的列表的迭代器具有n + 1个可能的光标位置，如下图所示（^）所示： Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^ 需要注意的是：remove（）和set（Object）方法未按照光标位置进行定义; 它们被定义为对调用next（）或previous（）返回的最后一个元素进行操作。 该接口的结构如下： boolean hasNext(); 判断列表迭代器是否有下一个元素。 E next(); 获取下一个元素并将光标向后移动一个。 boolean hasPrevious(); 判断是否有前一个元素。 E previous(); 获取前一个元素并将光标向前移动一个。 int nextIndex(); 返回使用next方法将得到的元素的下标，如果迭代器已经在序列的末尾，则返回序列的长度。 int previousIndex(); 返回使用previous方法将得到的元素的下标。如果迭代器已经在序列的开头，则返回-1。 void remove(); 从列表中删除next（）或previous（）返回的最后一个元素（可选操作）。 这个调用只能在每次调用next或previous进行一次。 只有在最后一次调用next或previous之后没有调用add（E）时才可以进行此操作。 void set(E e); 用指定的元素（可选操作）替换next（）或previous（）返回的最后一个元素。 只有在最后一次调用next或previous之后既不调用remove（）也不add（E），则可以进行此调用。 void add(E e); 将指定的元素插入列表（可选操作）。 元素将插入到将由next（）返回的元素之前，如果有的话，并且在由previous（）返回的元素之后）。（如果列表不包含任何元素，则新元素将成为列表中的唯一元素。）新元素插入到隐式游标之前：对next的后续调用将不受影响，并且对previous的后续调用将返回新元素。 （此调用将增加一个调用nextIndex或previousIndex所返回的值。） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 21:05:11 "},"源码解读/java.util/ArrayList.html":{"url":"源码解读/java.util/ArrayList.html","title":"ArrayList","keywords":"","body":"ArrayList 经过前面众多的铺垫，终于到了一个真正的实现类。ArrayList被经常用到，了解真正的底层实现才能真正了解集合框架。该类的结构图如下： ArrayList是List接口的可调整大小的实现。可以存储所有的值，包括null。这个类大致等于Vector，除了它是不同步的。 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 类声明。直接继承AbstractList抽象类，实现List接口、RandomAccess接口、Cloneable接口、Serializable接口。 其中RandomAccess接口中没有任何方法，即这是一个标记接口。用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在其应用到随机或连续访问列表时提供更好的性能。 JDK中推荐的是对List集合尽量要实现RandomAccess接口。如果集合类是RandomAccess的实现，则尽量用for(int i = 0; i 来代替Iterator迭代器来遍历，后者的效果差一点，反过来，如果List是Sequence List，则最好用迭代器来进行迭代。 JDK中说的很清楚，在对List特别是Huge size的List的遍历算法中，要尽量来判断是属于RandomAccess(如ArrayList)还是Sequence List (如LinkedList），因为适合RandomAccess List的遍历算法，用在Sequence List上就差别很大，常用的作法就是： 要作一个判断： if (list instance of RandomAccess) { for(int m = 0; m 这一点我们在遇到遍历时候再进行学习。 另外注意到，ArrayList使用了泛型。 构造方法 ArrayList重载了3个构造方法。 public ArrayList(int initialCapacity){...} 指定缓存区初始大小。 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 其中elementData是ArrayList中真正用来存储数据的对象数组。定义如下： transient Object[] elementData 前面说到ArrayList使用了泛型，所以这里元素的缓存就使用了顶级父类Object来声明，那么为什么不使用泛型数组E[] 来声明呢？因为实际上并不存在泛型数组这个东西，而且这里使用泛型将会在后面引起很多的麻烦。具体可以参考“泛型”的讲解内容。 该缓存数组用transient修饰。 在这个构造方法中可以看到，如果指定的参数合法那么初始的缓存区大小就可被指定，否则就被赋值未EMPTY_ELEMENTDATA，其定义如下： private static final Object[] EMPTY_ELEMENTDATA = {}; 注意到，这是一个静态常量空数组，用于空实例的共享空数组。即数组缓存被初始化为空数组。 public ArrayList() {} 无参构造方法。定义如下： public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 无指定的情况下，对象数组elementData被赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这个变量定义如下： private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 诶，这个DEFAULTCAPACITY_EMPTY_ELEMENTDATA空对象数组和之前提到的EMPTY_ELEMENTDATA定义完全一样，用法看起来似乎差不多，有什么用处呢？根据指示，大概意思是构造一个空的对象数组，用来与EMPTY_ELEMENTDATA这个数组进行对比，来确定当第一次向ArrayList中添加数据时，应该如何进行扩容。暂时不太好理解，往后看遇到了再说。 另外这个方法的注释说“默认构造了一个容量为10的缓存区”，怎么会是10呢，明明DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空数组。往后看就知道了。 public ArrayList(Collection c){...} 指定一个集合，构造一个包含集合中元素的ArrayList实例。定义如下： public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 这里首先用到了Collection.toArray()方法进行数组转换，将自己的缓存指向了这个转化得到数组。这里有一个确认对象类型的检验，如果集合中的对象不是Object类型，利用Arrays.copyOf方法进行数组的拷贝。这里有一个问题，为什么“集合中的数组不是Object类型”？注释给出的解释是:c.toArray方法有可能导致的问题，这个bugID是6260652。当转化得到的数组为空时，ArrayList并没有使用这个数组，而是仍然能使用自己构造的空数组。 public int size(){...} 用来获取ArrayList中真正元素的个数。定义如下： public int size() { return size; } size就是一个私有变量，默认为0，之后往里添加元素的时候就增加，删除元素的时候就减小。注意和缓存空间大小的区别！！！ public boolean isEmpty(){...} 查看是否存在元素。怎么判断，很简单，还是看size的大小，为0就是无元素，否则就是有元素。定义略。 add方法 往ArrayList中添加元素，这是最常使用的方法。重载了两种add方法。 public boolean add(E e){...} 只指定了元素，那么就是追加元素。定义如下： public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 首先需要保证能够添加得进去，什么意思？就是保证容量足够，有位置添加。ensureCapacityInternal的定义如下： private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } 这个方法的参数是最低需要保证的容量，在这个add方法中，最低容量就是在当前size基础上加1。从上面的方法可以看到，首先将缓冲区和DEFAULTCAPACITY_EMPTY_ELEMENTDATA进行比较，如果相等说明什么？说明这个实例创建的时候是用默认构造方法创建的而且还没有添加过元素。这不行啊，我得有空间才行，行，那我创建一个，多大空间合适啊？这里取常量DEFAULT_CAPACITY和指定参数minCapacity的较大者，其中常量DEFAULT_CAPACITY等于10。这里较大者一定是10(因为if判断成立的时候，说明原来是空数组，size等于0，那么指定的minCapacity是1，10和1比较当然取10，这也就是为什么前面说到，默认构造方法相当于创建了一个初始容量为10的数组缓存区)。之后调用的ensureExplicitCapacity，定义如下： private void ensureExplicitCapacity(int minCapacity){ modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } modCount是该类的一个保护变量，定义如下： protected transient int modCount = 0; 我们暂且先不管它的具体含义。看后面的代码，很简单，判断容量和现在的容量相比那么大，如果现在不够大，那就增加容量。grow方法定义如下： private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 这段代码进行了扩容，新容量和旧容量的关系是新容量= 1.5旧容量。但是这并不是最终的容量，需要检验。有两种可能： 得到的容量比需要的容量要少，为什么会这样？溢出了！ 得到的容量超过了规定的最大容量，进入hugeCapacity中，如果需求的容量小于0，则抛出内存溢出异常，如如果需要的容量比规定的最大容量大，那么最大容量只能是Integer.MAX_VALUE了。 最后elementData通过Arrays的赋值拷贝方法进行扩容。 扩容后再回到add方法中，将size位置赋值为指定值，size增加1，返回true。【注意这个方法永远都返回true，所以我们不能通过返回值来判断是否添加成功】。 从ArrayList的扩容过程可以看出，ArrayList并不是无限大的，它指定了一个最大容量是Integer.MAX_VALUE - 8，而实际的最大只能是Integer.MAX_VALUE这个值了。 public void add(int index, E element){...} 指定位置和指定元素。定义如下： public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } private void rangeCheckForAdd(int index) { if (index > size || index 首先检查了位置参数index是否合法。接着同样进行是否扩容的判断。接着用调用System.arraycopy方法将index上及之后的元素后移移位，这是一个本地方法，看不到源码。最后给index上的元素赋值，size增加1。注意这个方法的返回类型是void而不是boolean。 remove方法 从线性表中删除元素。重载了两个方法。 public E remove(int index) {...} 指定元素删除的位置，返回的是被删除的元素。定义如下： public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } @SuppressWarnings(\"unchecked\") E elementData(int index) { return (E) elementData[index]; } 首先检查参数index是否越界，这类的越界检查和add方法中的越界检查不一样，rangeCheck没有对index 的情况作出处理。所以如果参数是-1，那么在elementData方法中会抛出ArrayIndexOutOfBoundsException异常，注意到这个方法上确实用@SuppressWarnings注解做了标记，可能会抛出免检异常。诶，既然做了越界检查，为什么不索性连负数的越界一起检测了？？？不太懂这里的设计思路。 之后numMoved记录的是需要移动元素的位数，如果等于0，说明要删除的的是最后一位，就没有必要进行移动了。最后将移动后的数组末尾赋值为null。注释里说这是释放内存，但是我们不能依赖这种方法，因为我们永远你不知道GC如何回收它们。 读到这里，我有一个启发，就是数组的移动操作可以用System.arraycopy()方法代替我们自己写的遍历赋值的移动方法，虽然前者的底层实现原理就是遍历赋值，但是由于前者是native方法，效率更高。这点在String类的设计中可以看到实际的应用。 public boolean remove(Object o){...} 移除ArrayList中第一个指定的对象o。如果删除成功就返回true，否则返回false。定义如下： public boolean remove(Object o) { if (o == null) { for (int index = 0; index 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 这里可以看到，首先要判断指定的对象是不是null，为什么要区别？因为o.equals(elementData[index]可能会引起空指针异常。除此之外操作过程都相同，主要调用的是fastRemove方法，这个方法实际上就是remove(int index)的后半段代码，那句很奇怪了，为什么remove(int index)不直接调用这个方法呢？ public void clear() {...} 清除元素。该方法被调用后，ArrayList缓冲区中不再有元素，定义如下： public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i 将所有元素都置为null，再将size置为0。 addAll方法 add方法是向线性表中添加单个元素，而addAll方法是想向线性表添加一个集合中的所有元素，同样重载了两个方法。 public boolean addAll(Collection c){...} 向线性表追加元素。 public boolean addAll(Collection c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } 追加的很简单，将集合转为数组、扩容、移动赋值、更新size，最后返回是否添加成功的boolean变量，实际上一系列过程都是正确执行的，所以该方法是不是返回true取决于指定的这个集合是不是空集合，是空集合的话那还添加个啥，返回false，否则返回true(因为这种情况一定添加成功)。 public boolean addAll(int index, Collection c){...} 指定元素集合和添加的位置。定义如下： public boolean addAll(int index, Collection c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } 套路可以延续add(int index, E o)的过程：越界检查、集合转为数组、扩容、移动赋值，更新size，不同的地方在于，这里需要两次数组的移动赋值：一次是将原缓冲区中index后的元素都往后移动numNew个位置，一次是将新元素添加进缓冲区。 另外还需要注意的是，这个方法返回的类型是boolean，而添加单个元素add(int index, E o)方法的返回值是void。 public boolean removeAll(Collection c) {...} 这是JDK1.7的新方法。removeAll就没有重载方法了，就一个移除指定集合中的所有元素。定义如下： public boolean removeAll(Collection c) { Objects.requireNonNull(c); return batchRemove(c, false); } public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } private boolean batchRemove(Collection c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try { for (; r 首先调用的是工具类Objects【注意不是Object】的静态方法requireNonNull，检验c非空。如果为空则抛出空指针异常。接下来就是batchRemove方法，这个方法指定的第二个参数是false。意思就是留下与c中不一样元素，这样就达到了删除c中所有元素的目的。 在batchRemove方法中，首先对数组进行了一次赋值，然后将数组中的元素一次与collection中的元素进行比较。try块的结果是一个数组，数组前w位元素或与colletcion相同（当complement = true的时）或不同（complement = false）。 在finally中，第二个if代码块的作用是将数组中w之后的元素全部变成null，让gc回收。而第一个if块中，看条件r != size似乎永远不会满足，因为try块中r一直递增，什么时候会出现r != size呢？当c.contains(elementData[r])抛出异常的时候，一旦类型不匹配（之前我们说过，toArray可能会导致类型不一致），就会抛出异常。这种情况下，就把剩下没有比较的原数组部分，即位置r之后的部分复制都w位置之后。再回到第二个if块，进行到这一步，可以明确，原缓冲区一定是remove了一些元素了，所以将布尔变量modified置为true，表示修改成功。 这个的方法很巧妙，要眼熟它。 public boolean retainAll(Collection c){...} retain的意思是“保留”，所以retainAll方法用于从列表中移除未包含在collection中的所有元素。如果list集合对象由于调用该方法而发生改变，则返回true。 原来我很纳闷，“只保留集合中的所有元素”，那最后不就是得到一个与collection相同的集合呢，为什么不知道让elementData = c，转念一想，太傻了我，根本不能赋值啊，首先父类不能赋值给子类，再者就算是转化为list类型，顺序也不一致了，所以这个想法太蠢了。 方法定义如下： public boolean retainAll(Collection c) { Objects.requireNonNull(c); return batchRemove(c, true); } 仍旧调用的batchRemove方法，但是第二个参数是true，表示留下的而是存在集合c中的那些元素。 public void sort(Comparator c){...} 使用规则c对线性表进行排序，调用的是Arrays.sort方法。定义如下： @Override @SuppressWarnings(\"unchecked\") public void sort(Comparator c) { final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } public int indexOf(Object o){...} 从头开始，查找指定元素的第一个索引，如果没有该元素就返回-1。 public int indexOf(Object o) { if (o == null) { for (int i = 0; i public int lastIndexOf(Object o){...} 从尾开始，查找指定元素的第一个索引，如果没有该元素就返回-1。 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i >= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } public Object clone(){...} 重写了Object类的拷贝方法，注意ArrayList的拷贝方法是浅拷贝。 public Object clone() { try { ArrayList v = (ArrayList) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } } 浅拷贝是说对于对象的拷贝，实际上只拷贝了对象的地址，源对象和经过拷贝得到的对象指向的是同一个对象。而深拷贝是指经过new 对象得到的拷贝结果。 参考 http://www.jb51.net/article/48201.htm public Object[] toArray(){...} 得到对象数组。注意可不能直接返回ArrayList中的缓存，得返回其副本。 public Object[] toArray() { return Arrays.copyOf(elementData, size); } 注意该方法的返回值是 Object类型的数组，我们无法用强制类型转化的方法得到想要的对象数组。比如某个list存储String类型，使用语句(String[]) list.toArray()会报错，该语句不正确，正确的写法是list.toArray(new String[list.size()])。 public E get(int index){...} 取得某个位置上的元素值。 public E get(int index) { rangeCheck(index); return elementData(index); } public E set(int index, E element){...} 更改某个位置上的元素的值。 public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } ArrayList中还有一些其他方法，大部分是一些1.8的新特性，不是很常用的，这里先暂时不做学习。 总结 ArrayList是最基础也是最常用的Java集合框架类，通过读源码加深了对之前只能从书本上获取到的信息，比如何如初始化，如何扩容，这些都能从源码中找到最清晰原始的答案。另外还有一些编程方法指值得学习，比如成块的数组元素的移动可以借助System.arraycopy方法，在删除多个元素的时候，使用赋值的方法可以在O(n)的时内完成。这些问题的解决办法都值得学习。另外注意到ArrayList是线程不安全的，它的操作中没有使用同步方法，而Vector类是线程安全的，实际上，两者的区别只在于线程安全性上，除此之外，ArrayList完全可以替代Vector。另外，Collections.synchronizedList可以用来创建线程安全的list。 迭代器 ArrayList通过内部类Itr实现了 Iterator接口，注意其类本身没有实现Iterator接口。 这个内部类的定义如下： private class Itr implements Iterator { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } @SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i >= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) { throw new ConcurrentModificationException(); } while (i != size && modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 首先这类有三个重要的属性： cursor： 游标，迭代器始终是往前走的，cursor使用是++。 lastRet：末尾标识，标识了最后一个返回的元素的索引位置。-1表示这个元素不存在。 int expectedModCount = modCount;：操作数标识。用来校验在使用iteration期间，是否存在非iteration的操作对ArrayList进行了修改。modCount这个变量在之前add、addAll、remove、removeAll、retainAll的操作中指定++操作。 接着这个类有三个重要的方法： checkForComodification：在这个内部类中，几乎所有的都在调用它，目的在于用来校验在使用iteration期间，是否存在非iteration的操作对ArrayList进行了修改。Iterator的游标特性决定了它对ArrayList中元素在这一时刻的位置很敏感，如果当前游标在index位置，而有其他操作在index-1的位置上插入了一个元素，那么调用iterator的next()方法，返回的还是当前这个元素，这样就乱了。为了避免这个情况发生，需要在这个期间把ArrayList“锁住“。它并没有实现真正的锁，所以采用了这个校验的方式。 next：返回游标位置的元素。注意这里面第一个if，游标移动到一个不存在数据的地方会抛出异常，而并不是返回null，这就是我们为什么在使用iterator的时候，不用用(null == iterator.next())来判断的原因，正确的做法是在每次循环开始的时候判断iterator.hasNext()。 remove：删除lastRet所标识位置的元素。可以理解为删除当前元素。在try之前有一个校验，保证元素没有被改动过。在try块中，首先删除了lastRet标识的元素，然后让游标指向了这个位置。我们知道删除了元素之后，这个位置有了新元素。这样再次调动next()的时候就不会出现空指针异常，更不会跳过一个元素。最后expectedModCount = modCount，这句话相当于释放了锁。 对于 ArrayList，它还定义了一种内部迭代器ListItr，这是一个功能更强大的迭代器，该内部类的定义如下： private class ListItr extends Itr implements ListIterator { ListItr(int index) { super(); cursor = index; } public boolean hasPrevious() { return cursor != 0; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } @SuppressWarnings(\"unchecked\") public E previous() { checkForComodification(); int i = cursor - 1; if (i = elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; } public void set(E e) { if (lastRet 可以看到，这个迭代器继承自Itr，可以双向迭代，还能进行add和set操作【实际上其本质还是调用的外部类ArrayList的add和set方法】。 ArrayList类提供了对迭代器的获取，一共有三个方法： public Iterator iterator(){...} 获取一个基本的Itr类型的迭代器。定义如下： public Iterator iterator() { return new Itr(); } public ListIterator listIterator(){...} 获取一个ListItr类型的迭代器，默认游标的位置是0。定义如下： public ListIterator listIterator() { return new ListItr(0); } public ListIterator listIterator(int index){...} 获取一个ListItr类型的迭代器，指定游标的初始位置。 public ListIterator listIterator(int index) { if (index size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); } public List subList(int fromIndex, int toIndex){...} 获取子集合。定义如下： public List subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } 首先进行了越界检查： static void subListRangeCheck(int fromIndex, int toIndex, int size) { if (fromIndex size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex > toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\"); } 接着返回一个SubList的实例。这又是一个内部类，类定义如下： private class SubList extends AbstractList implements RandomAccess { private final AbstractList parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList parent, int offset, int fromIndex, int toIndex) { this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; } public E set(int index, E e) { rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; } public E get(int index) { rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); } public int size() { checkForComodification(); return this.size; } public void add(int index, E e) { rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; } public E remove(int index) { rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; } protected void removeRange(int fromIndex, int toIndex) { checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; } public boolean addAll(Collection c) { return addAll(this.size, c); } public boolean addAll(int index, Collection c) { rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; } public Iterator iterator() { return listIterator(); } public ListIterator listIterator(final int index) { checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator() { int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() { return cursor != SubList.this.size; } @SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); int i = cursor; if (i >= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; } public boolean hasPrevious() { return cursor != 0; } @SuppressWarnings(\"unchecked\") public E previous() { checkForComodification(); int i = cursor - 1; if (i = elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; } @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer consumer) { Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i >= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (offset + i >= elementData.length) { throw new ConcurrentModificationException(); } while (i != size && modCount == expectedModCount) { consumer.accept((E) elementData[offset + (i++)]); } // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); } public int nextIndex() { return cursor; } public int previousIndex() { return cursor - 1; } public void remove() { if (lastRet 注意到，这个内部类和ArrayList本身通过parent属性相关联。而这个内部类本身也有着ArrayList的一系列操作。具体的这个内部类能做什么，目前还没有应用到。 参考 RandomAccess接口的使用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 21:07:23 "},"源码解读/java.util/LinkedList.html":{"url":"源码解读/java.util/LinkedList.html","title":"LinkedList","keywords":"","body":"LinkedList LinkedList是Java中线性表的链表实现。类结构如下： public class LinkedList extends AbstractSequentialList implements List, Deque, Cloneable, java.io.Serializable 类声明，LinkedList继承自抽象父类AbstractSequentialList，实现List、Deque、Cloneable和Serializable接口。其中Deque是双向队列，所以可以在这个类中看到该类对双向队列的实现。 另外一点需要说明的是，LinkedList没有继承RandomAccess，虽然LinkedList也通过内置迭代器类实现了迭代器，但是最好不要用迭代器遍历。 构造函数 重载了两个构造函数。 public LinkedList(){...} 默认的公共构造函数，方法体为空。 public LinkedList(Collection c) {...} 以集合c为参数，构造一个包含集合c内元素的链表。 public LinkedList(Collection c) { this(); addAll(c); } 其中调用的addAll方法定义如下: public boolean addAll(Collection c) { return addAll(size, c); } addAll(size, c)方法将会把集合c中的元素追加到链表中，其中变量size表示的是当前链表中的元素个数，定义为transient int size = 0;，该方法的定义为： public boolean addAll(int index, Collection c) { checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node pred, succ; if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node newNode = new Node<>(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } private static class Node { E item; Node next; Node prev; Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } } Node node(int index) { // assert isElementIndex(index); if (index > 1)) { Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } transient Node first; transient Node last; 注意到链表节点Node的数据结构中有前驱节点指针和后继节点指针，所以LinkedList是实际上是一个双向链表。在addAll方法中，首先将集合c转化为数组，之后的插入过程就是遍历数组，一个个创建节点建立链接的过程。其中定义的pred和succ节点指示当前应该插入的节点的前驱节点和后继节点。node是查找第index位置上的元素的方法，在该方法中，根据index和二分之一size的大小关系，决定搜索策略，如果要查找的节点在链表的前半部分，那就从头开始用next指针域遍历查找，否则从last开始用prev指针域遍历查找。其中first是链表的第一个节点，last是链表的最后一个节点。 在插入节点的时候对空链表（prev是否为null）做单独处理。 addAll方法调用成功后会返回布尔量表示操作是否成功。 public E getFirst(){...} 和 public E getLast() {...} 获取链表的首个节点的数据和取得链表的最后一个数据节点。定义如下： public E getFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return f.item; } public E getLast() { final Node l = last; if (l == null) throw new NoSuchElementException(); return l.item; } 很好理解，不用多解释。 public E removeFirst() {...}和public E removeLast(){...} 移除首个节点和移除最后一个节点。定义如下： public E removeFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } private E unlinkFirst(Node f) { // assert f == first && f != null; final E element = f.item; final Node next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } public E removeLast() { final Node l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } private E unlinkLast(Node l) { // assert l == last && l != null; final E element = l.item; final Node prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; } 注意到删除元素的时候，不仅要将被删除的元素置为null，还要更新后继/前驱节点的相应指针，注意对首尾节点的处理。方法最后返回的是被删除的节点的值。 public void addFirst(E e){...}和public void addLast(E e) {...} 向链表头添加元素和向链表为添加元素。 public void addFirst(E e) { linkFirst(e); } private void linkFirst(E e) { final Node f = first; final Node newNode = new Node<>(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; } public void addLast(E e) { linkLast(e); } void linkLast(E e) { final Node l = last; final Node newNode = new Node<>(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } public int size(){...} 取得链表的长度，直接返回成员变量size即可。 public boolean contains(Object o){...} 查看链表是否包含某一个指定的元素，借助的是indexOf方法，该方法如果未查找到元素，则返回-1.否则返回该元素所在的位置索引。 public boolean contains(Object o) { return indexOf(o) != -1; } public int indexOf(Object o){...} 从前往后，查看指定元素在链表中的位置，如果链表中无该元素，则返回-1，注意到参数类型是Object，而不是泛型。定义如下： public int indexOf(Object o) { int index = 0; if (o == null) { for (Node x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 注意到对指定的元素为null时的特殊处理。这点在ArrayList的学习中出现过，这样处理的目的是为了防止出现空指针异常。 public int lastIndexOf(Object o){...} 从后往前，查看指定元素在链表中的位置，如果无该元素，则返回-1，同样元素类型是Object而不是泛型。定义如下： public int lastIndexOf(Object o) { int index = size; if (o == null) { for (Node x = last; x != null; x = x.prev) { index--; if (x.item == null) return index; } } else { for (Node x = last; x != null; x = x.prev) { index--; if (o.equals(x.item)) return index; } } return -1; } 由于LinkedList是双向链表的实现，所以从后往前查找十分方便，使用prev指针遍历就行。 public boolean add(E e){...} 向链表中追加一个元素，相当于addLast(e)，永远返回true。定义如下： public boolean add(E e) { linkLast(e); return true; } public boolean remove(Object o){...} 移除第一个指定的元素o，注意参数类型是Object而不是泛型。定义如下： public boolean remove(Object o) { if (o == null) { for (Node x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } public void clear(){...} 将链表中的所有元素移除，注意不单单是让fist = last = null，这么简单，需要释放每一个节点中的数据域和指针域。最后长度置为0.定义如下： public void clear() { // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node x = first; x != null; ) { Node next = x.next; x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; modCount++; } get和set方法 get方法用来取得第index索引位置的节点数据，set方法用来设置第index索引位置的节点数据。 public E get(int index) { checkElementIndex(index); return node(index).item; } public E set(int index, E element) { checkElementIndex(index); Node x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 需要注意的是set方法有返回值，返回的是替换之前的元素的数据值。 public void add(int index, E element){...} 在index位置上添加一个元素节点。 public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } 可以看到这里为了效率对index做了判断，如果要插入到最后一个节点之后，直接调用的是linkLast方法来追加节点。否则是将元素节点添加到原来index节点之前，调用的linkBefore方法定义如下： void linkBefore(E e, Node succ) { // assert succ != null; final Node pred = succ.prev; final Node newNode = new Node<>(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } public E remove(int index){...} 移除指定位置上的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } 单向队列（Queue） Java中LinkedList实现了单向队列的功能，单向队列规定队首只能出队，队尾只能入队。下面这些方法就是针对队列设计的功能。 public E peek(){...} 和 public E element(){...} 两个方法都是获取到队首的元素，但是不出队。两者有细微的差别：peek方法在遇到空链表的时候会返回null，而element方法在遇到空链表的时候会抛出异常。 public E peek() { final Node f = first; return (f == null) ? null : f.item; } public E element() { return getFirst(); } public E getFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return f.item; } public E poll(){...} 和 public E remove(){...} 真正的出队操作。两者的差别在于前者在遇到空链表的时候返回null，后者抛出异常。 public E poll() { final Node f = first; return (f == null) ? null : unlinkFirst(f); } public E remove() { return removeFirst(); } public E removeFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } public boolean offer(E e){...} 入队操作。即追加元素到链表末尾。定义如下： public boolean offer(E e) { return add(e); } 双向队列（Deque） LinkedList同样实现了双向队列。即队首和队尾都可以实现出队和入队。 public boolean offerFirst(E e) 队首入队。 public boolean offerFirst(E e) { addFirst(e); return true; } public boolean offerLast(E e){...} 队尾入队。 public boolean offerLast(E e) { addLast(e); return true; } public E peekFirst() {...} 获取队首元素，但是不出队。 public E peekFirst() { final Node f = first; return (f == null) ? null : f.item; } public E peekLast() {...} 获取队尾元素，但是不出队。 public E peekLast() { final Node l = last; return (l == null) ? null : l.item; } public E pollFirst() {...} 队首元素出队。 public E pollFirst() { final Node f = first; return (f == null) ? null : unlinkFirst(f); } public E pollLast() {...} 队尾元素出队。 public E pollLast() { final Node l = last; return (l == null) ? null : unlinkLast(l); } 栈 LinkedList同样实现了栈的操作，主要是出栈pop操作和入栈push操作。 public void push(E e) {...} 入栈操作。 public void push(E e) { addFirst(e); } public E pop(){...} 出栈操作。 public E pop() { return removeFirst(); } public Object clone(){...} 浅复制方法。 public Object clone() { LinkedList clone = superClone(); // Put clone into \"virgin\" state clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // Initialize clone with our elements for (Node x = first; x != null; x = x.next) clone.add(x.item); return clone; } @SuppressWarnings(\"unchecked\") private LinkedList superClone() { try { return (LinkedList) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e); } } public Object[] toArray(){...} 将链表转化称为数组。很简单，就是构造一个size长度的对象数组，遍历赋值即可。 public Object[] toArray() { Object[] result = new Object[size]; int i = 0; for (Node x = first; x != null; x = x.next) result[i++] = x.item; return result; } 总结 LinkedList是Java中线性表的链表存储方式的实现。同时该类实现了单项队列、双向队列和栈的功能。同时该类是非线程安全的。如果程序对线程安全性有要求。可以使用Collections.synchronizedList()来创建线程安全的线性表。 另外对于LinkedList的遍历，有以下几种方法： 通过迭代器遍历。即通过Iterator去遍历for (Iterator itr = list.iterator(); itr.hasNext();){ System.out.println(itr.next()); } 通过随机访问遍历(不可取，太慢了)int size = list.size(); for (int i=0; i 通过for-each循环for (Integer integ:list) ; 通过pollFirst()来遍历LinkedListwhile(list.pollFirst() != null) ; 通过pollLast()来遍历LinkedListwhile(list.pollLast() != null) ; 通过removeFirst()来遍历LinkedListtry { while(list.removeFirst() != null) ; } catch (NoSuchElementException e) { } 通过removeLast()来遍历LinkedListtry { while(list.removeLast() != null) ; } catch (NoSuchElementException e) { } 以上这些方法的测试时间是： iteratorLinkedListThruIterator：8 ms iteratorLinkedListThruForeach：3724 ms iteratorThroughFor2：5 ms iteratorThroughPollFirst：8 ms iteratorThroughPollLast：6 ms iteratorThroughRemoveFirst：2 ms iteratorThroughRemoveLast：2 ms 由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种遍历方式。无论如何，千万不要通过随机访问去遍历LinkedList！ 参考 Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-09 21:24:49 "},"源码解读/java.util/Vector.html":{"url":"源码解读/java.util/Vector.html","title":"Vector","keywords":"","body":"Vector Vector是一个历史遗留类，现在一般不怎么用。其结构如下： 由于现在一般都不怎么使用了，所以源码解读在此略过。可以这么理解， Vector是线程安全的ArrayList，但是在设计上没有LinkedList细腻。所以我们一般都不再使用Vector，如果要实现线程安全的ArrayList，可以借助于collections.synchronizedList方法来创建线程安全的ArrayList。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-31 14:31:25 "},"源码解读/java.util/Stack.html":{"url":"源码解读/java.util/Stack.html","title":"Stack","keywords":"","body":"Stack Stack直接继承自Vector，同样是历史产物，现在一般都不怎么用了。 现在实现栈的操作一般基于LinkedList对栈的实现，所以该类一般都不怎么使用。在此也先不做学习。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-31 14:36:28 "},"源码解读/java.util/Map.html":{"url":"源码解读/java.util/Map.html","title":"Map","keywords":"","body":"Map 该类提供了key到value的映射。不能包含重复的key，每一个key只能被映射到一个value值。该类代替了Dictionary，这是一个抽象类而非接口。 Map包含了3种视图：一个key的集合（通过keySet()方法），一个value的集合（通过value()方法）和一个key-value（通过entrySet()方法）的映射关系。Map的顺序是指用迭代器遍历的时候返回元素的顺序。许多Map接口的实现类，比如TreeMap类，定义了特殊的顺序，而有一些实现类，比如HashMap，就没有对顺序做特殊约定。 在用可变对象作为键值的时候要特别小心。 Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. 所有通用的map的实现类一般都提供两种构造：一个无参构造方法来创建一个空映射集合；一个带有Map类型的单个参数的构造函数，该构造函数创建一个具有与其参数相同的键值映射的新映射。而实际上，后者的构造函数允许用户复制任何map，产生所需的等价map。没有办法强制执行这个建议（因为接口不能包含构造函数），但是JDK中的所有通用map的实现都符合。 很多map的实现类对它们可能包含的key和value都做了限制，比如，一些map的实现类禁止null作为key或者value的值；一些map实现类对key与value的类型有限制，尝试插入不合格的key或value将引发免检异常，通常为NullPointerExeption和ClassCastException，尝试查询不合格的key或value可能会引发异常，也可能会返回false。 注意，集合框架上的许多方法都是定义在equals方法的基础上的。 Map接口结构如下： int size(); 返回键值对的个数，如果个数超过Integer.MAX_VALUE，就只会返回Integer.MAX_VALUE。 boolean isEmpty(); 查看键值对是否为空。 boolean containsKey(Object key); 当且仅当存在一个k使得(key==null ? k==null : key.equals(k))时候返回true。需要注意的是，这种k最多只有一个，因为map不允许存在重复的key。 boolean containsValue(Object value); 当且仅当存在v使得(value==null ? v==null : value.equals(v))时候返回true。需要注意的是，这种v值可能有好几个。 V get(Object key); 取得key对应的值，当map中含有一对键值k-v使得(key==null ? k==null : key.equals(k))}，此时返回v，否则返回null。（如果map允许null值，那么另外返回null这种设计是没有必要的）。 V put(K key, V value); 往map中存放入一对键值。如果map中已经包含key作为键的键值对，那么将会覆盖，则会建增。 V remove(Object key); 删除map中键值为key的键值对，如果存在该键值对，则删除并返回被删除的value值，如果不存在就返回null。 void putAll(Map m); 将另一个map中的集合都拷贝到当前map中，其效果相当于遍历一个map，对每个map元素都调用put方法。 void clear(); 移除map中的所有元素。 Set keySet(); 返回此映射中包含的key的Set视图。对map的任何修改都会反映到该集合中，反之亦然。如果在对集合进行迭代的过程中修改了映射（除了通过迭代器自己的删除操作），迭代的结果是未定义的。该Set集合支持元素删除，通过Iterator.remove，Set.remove、Set.removeAll、Set.retainAll和Set.clear操作从映射中删除相应的映射，它不支持add和addAll操作。 Collection values(); 返回此映射中包含的value的集合视图。同样，对map的任何修改都会反映到该集合中，反之亦然。 Set> entrySet(); 返回此映射中包含的映射关系。对map的任何修改都会反映到该集合中，反之亦然。。注意到，其中Set的元素类型是Map.Entry类型，这是Map定义的一个内部接口，指的是一个映射关系。定义如下： interface Entry { //返回此映射关系对应的key值 K getKey(); //返回此映射关系对应的value值 V getValue(); //给此映射对应的value值重新复制 V setValue(V value); //判断相等，当且仅当参数也为映射，且key与value完全相等 boolean equals(Object o); //返回此映射关系的hashCode int hashCode(); //还有1.8中加入的几个比较方法 public static , V> Comparator> comparingByKey() { return (Comparator> & Serializable) (c1, c2) -> c1.getKey().compareTo(c2.getKey()); } public static > Comparator> comparingByValue() { return (Comparator> & Serializable) (c1, c2) -> c1.getValue().compareTo(c2.getValue()); } public static Comparator> comparingByKey(Comparator cmp) { Objects.requireNonNull(cmp); return (Comparator> & Serializable) (c1, c2) -> cmp.compare(c1.getKey(), c2.getKey()); } public static Comparator> comparingByValue(Comparator cmp) { Objects.requireNonNull(cmp); return (Comparator> & Serializable) (c1, c2) -> cmp.compare(c1.getValue(), c2.getValue()); } } boolean equals(Object o); 整个映射集合的 equals方法，当且仅当两者完全相同时才返回true。 int hashCode(); 返回映射集合的哈希值，整个哈希值是entrySet哈希值的总和。 default V getOrDefault(Object key, V defaultValue){...} 1.8新方法。当map中包含key的键值对的时候返回其value值，如果不包含，那么返回自定义的默认的defaultValue值。定义如下： default V getOrDefault(Object key, V defaultValue) { V v; return (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue; } 后面还有几个JDK1.8新加入的方法，不常用在此不做讲解。 继承Map接口的类或者接口有：HashMap、TreeMap、HashTable、SortedMap。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-18 22:45:46 "},"源码解读/java.util/HashMap.html":{"url":"源码解读/java.util/HashMap.html","title":"HashMap","keywords":"","body":"HashMap HashMap是基于哈希表（Hash Table）的Map接口的实现，它和HashTable的区别在于两点： HashMap是非线程安全的，而HashTable线程安全的。 HashMap允许以null值作为key和value值，而HashTable是不允许的。 除此之外，HashMap近似等于HashTable。 另外，HashMap不保证顺序并且不保证在使用的过程中顺序恒定。 HashMap能够提供线性时间的存取操作！！！当然前提是散列函数在桶之间正确分散元素。对集合视图的迭代需要的时间与HashMap实例的\"容量\"（桶的数量）加上其大小（键值映射的数量）成正比，因此，如果迭代性能很重要，就不要将初始容量设置地太高（或者负载因子太小）。 HashMap的性能受到两个参数的影响：初始化容量和负载因子。容量就是哈希表的桶的数量，初始容量就是哈希表创建的时的容量。负载因子是散列表在其容量增加之前允许得到度量。当哈希表中条目数量超过了负载因子和当前容量的乘积时，散列表将被重新映射（也就是说内部的数据结构将被重建），重建之后散列表的数量大约是存储桶数量的2倍。 一般来说，这个负载因子取值为0.75，这个数提供了时间和空间成本之间的良好折衷。如果过大，可以减少空间开销但是会增加查找成本，反映在大部分的HashMap类的操作中，包括get和put操作。在设置初始容量的时候，应该考虑映射中条目数量及其负载因子，以尽量减少重新操作的次数。如果初始容量大于最大入口数量除以负载因子，则不会发生重新刷新的操作。 HashMap是非线程安全的。 如果多个线程同时访问哈希映射，并且至少一个线程在结构上做了修改，则必须进行外部同步。这种同步通常是通过封装映射的某个对象完成的，如果不存在这样的对象，就应该使用Collections.synchronizedMap方法“映射”该映射，这最好在创建的时候完成，以防止意外的不同步访问地图，写法如下： Map map = Collections.synchronizedMap(new HashMap(...)) HashMap类的结构如下： public class HashMap extends AbstractMap implements Map, Cloneable, Serializable 类声明，HashMap继承AbstractMap，实现Map接口、Cloneable接口和Serializable接口。 源码对该类的实现有这样的说明： 通常情况下，HashMap作为哈希表的容器，但是当容器变的很大的时候，它将被转化为TreeNodes的容器，类似于java.util.TreeMap中。大多数的方法都使用正常的容器，但是会适时转发给TreeNodes方法（只需要通过检查一个节点的实例） 构造方法 重载了四种构造方法。 public HashMap(int initialCapacity, float loadFactor) {...} 指定哈希表初始容量和装载因子。 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor >> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 首先对传入的参数范围作了检查，loadFactor是常量，一旦赋值就不能改变。而变量threshold是下一次扩容的临界值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） ，调用的tableSizeFor方法写的很奇怪，找到下一个最小的比参数大的2的高次幂。具体的可以参考https://zhidao.baidu.com/question/291266003.html。 这里保证了该值是一个2的倍数，比如你设置的是5，而实际上空间大小为8。 n |= n >>>4 就等于 n = n | n >>> 4，>>>是无符号右移，右移几位就是将从左到右的第几位置为1。所以对于65(1000000)，来说，经过上面的处理，最后变成1111111，然后加上1之后，就变成了2的倍数。 public HashMap(int initialCapacity) {...} 指定初始化容量。 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } static final float DEFAULT_LOAD_FACTOR = 0.75f; 默认的负载因子为0.75。 public HashMap() {...} 无参构造方法，默认初始化大小为16，初始化负载因子为0.75。 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 从方法本身看不出来初始化容量是16，看到下面的putVal就可以看到了。 public HashMap(Map m){...} 用指定的映射来构造新的映射。默认负载大小为0.75。 public HashMap(Map m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } final void putMapEntries(Map m, boolean evict) { int s = m.size(); if (s > 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft threshold) threshold = tableSizeFor(t); } else if (s > threshold) resize(); for (Map.Entry e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } static final int MAXIMUM_CAPACITY = 1 [] table; static class Node implements Map.Entry { final int hash; final K key; V value; Node next; //对下一个节点的引用（看到链表的内容，结合定义的Entry数组，哈希表的链地址法!!!实现） Node(int hash, K key, V value, Node next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry e = (Map.Entry)o; if (Objects.equals(key, e.getKey()) && Objects.equals(value, e.getValue())) return true; } return false; } } public static boolean equals(Object a, Object b) { return (a == b) || (a != null && a.equals(b)); } public static int hashCode(Object o) { return o != null ? o.hashCode() : 0; } putMapEntries方法用来装填映射关系，该方法被构造函数和Map.putAll()方法调用，第二个参数就是用来区分的，被构造函数调用的时候为false，被putAll方法调用时参数为true。方法首先检查旧映射的长度，存在映射（长度大于0）的时候初始化table变量，这是一个Node数组，这此时真正用来存储映射关系的数据结构。Node继承了Map.Entry，数据域中有Node类型变量next，实际上，它构成了一个链表。从这可以看出，HashMap是基于哈希桶数组 + 链表实现存储的，实际上，这是JDK1.7之前的是实现方式，1.8之后，以哈希桶数组 + 链表/红黑树的方式实现的。现在在这里还看不到红黑树的影子，往下分析就知道了。 注意到Node数据结构中，hash和key域是常量，一旦被赋值就不能改变。还需要注意到hashCode和equals方法的写法，其中hashCode方法返回的是key和value的本身哈希值的异或结果。而equals方法的参数Object类型，先用==符号比较两者是不是指向同一个地址，然后进行类型检查，必须得让key和value都相等才行。这里面用到了Objects辅助类的相关方法。 JDK1.6没有用到Objects类，而是单纯的代码赋值 重新回到putMapEntries方法，当table == null的时候，表示HashMap实例并未分配真正的存储空间，所以接下来要做的事情就是分配存储空间了。这个过程实际上是权衡各种因素之后给threshold赋值，当旧映射容量大于threshold时，进行扩容，resize方法定义如下： final Node[] resize() { Node[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) newThr = oldThr 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap [] newTab = (Node[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode)e).split(this, newTab, j, oldCap); else { // preserve order Node loHead = null, loTail = null; Node hiHead = null, hiTail = null; Node next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 1 当threshold为0的时候，就用DEFAULT_INITIAL_CAPACITY作为容量大小，该值为16（这也就是上文所说在未指定容量大小的时候默认容量为16的原因）。而threshold赋值为DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR，否则容量扩大为原来的2倍。 扩容完成后就要将旧映射中的内容赋值到自己的table中，调用的是putVal方法，定义如下： final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; //判断table是否为空 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;//创建一个新的table数组，用resize确定大小，并且获取该数组的长度 //根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { //如果对应的节点存在 Node e; K k; //判断table[i]的首个元素是否和key一样，如果相同直接覆盖value if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; //判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对 else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); // 该链为链表，就用链地址法 else { //遍历table[i]，判断链表长度是否大于TREEIFY_THRESHOLD(默认值为8)，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //树转型 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 写入覆盖 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } Node newNode(int hash, K key, V value, Node next) { return new Node<>(hash, key, value, next); } //！！Java 8 HashMap的分离链表。 在没有降低哈希冲突的度的情况下，使用红黑书代替链表。 /* 使用链表还是树，与一个哈希桶中的元素数目有关。下面两个参数中展示了Java 8的HashMap在使用树和使用链表之间切换的阈值。当冲突的元素数增加到8时，链表变为树；当减少至6时，树切换为链表。中间有2个缓冲值的原因是避免频繁的切换浪费计算机资源。 */ static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; 这是一个非常非常重要的方法，有四个参数： hash：这里是指key的哈希值，实现调用了hash()方法，定义如下：static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 可以看到key求取hash值的方法：当key为null的时候为0，否则等于该值的哈希值和其除以2^{16}的商的异或。所以，HashMap只可以存储一个key为null的键值对。但是可以存储多个value为null的键值对 key：即键的值 value：键值对中的“值” onlyIfAbsent： 如果为true，就不改变已经存在的值 evict：前一个值的大小，如果无前一个值，就为null。 方法的实现过程比较复杂，关键的注释已经在源码中标出。这里有一个关键的地方需要特别注意。 首先是key=null的值一定在table[0]的位置，为什么呢？因为根据hash方法的实现，null的返回值是0，所以在进行第二个if语句判断的时候，i = (n - 1) & hash定位到索引为0，所以key=null的值一定被放置在了table[0]。 再者，根据哈希值找到了table[i]，需要判断该位置是红黑树还是链表。如果是红黑树，调用putTreeVal方法插入节点。否则就是链表，那么就用链地址法解决问题。在解决的过程中，如果发现冲突的数量大于约定的允许的冲突最大值（默认为8），就将链表转为红黑树，然后执行插入节点的操作，否则就按照链表的插入操作进行。注意如果已经存在key，参数onlyIfAbsent决定了是否要覆盖旧的value值。 红黑树的实现很重要，我们另外起一章来讲解。 最后size增加1（当然，如果本来就存在key值，size是不会变化的），这里的size是实际存储的映射关系真实个数，和“容量”是不同的概念。此时要判断是否需要进行扩容操作。 另外，源码中afterNodeAccess和afterNodeInsertion是两个回调方法，方法体都为空。 public V get(Object key){...} 取得指定key的value值。定义如下： public V get(Object key) { Node e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node getNode(int hash, Object key) { Node[] tab; Node first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 方法将返回key值对应的value值，如果不存在则返回null。getNode方法每次都是检查first节点，否则的话，检查剩余的节点，需要考虑剩下的节点是红黑树节点还是链表。 public V put(K key, V value) {...} 添加一组映射关系。定义如下： public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 调用的是putVal方法，上文已经讲解过。 public boolean containsKey(Object key) {...} 判断是否存在key为某个值的映射关系。定义如下： public boolean containsKey(Object key) { return getNode(hash(key), key) != null; } 调用getNode方法，该方法没有找到该节点的时候将返回null。 public void putAll(Map m) {...} 将旧映射中的映射添加到新映射中，同理还是调用了putMapEntries方法，与HashMap调用时不一样的地方在于，这里第二个参数为true。 public void putAll(Map m) { putMapEntries(m, true); } public V remove(Object key){...} 移除指定key的映射关系，如果移除成功就返回被移除的映射，否则返回null。 public V remove(Object key) { Node e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node[] tab; Node p; int n, index; if ((tab = table) != null && (n = tab.length) > 0 && (p = tab[index = (n - 1) & hash]) != null) { Node node = null, e; K k; V v; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode)p).getTreeNode(hash, key); else { do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null && (!matchValue || (v = node.value) == value || (value != null && value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } removeNode和putVal是刚好相反的操作，过程差不多。需要注意的是removeNode方法有一个matchValue的布尔型参数，这个参数的意义在于考虑在匹配的时候是否考虑匹配参数中的value值，为什么有这种设计呢？因为后面还有一个remove方法，该方法指定了特定的key和value，同样调用removeNode方法，这时候，我们就需要匹配value值了。而对于只有一个参数的remove方法，为了能复用removeNode方法，参数value是指定为null的，这时候我们就不用匹配这个value值。 public boolean remove(Object key, Object value){...} 与上一个remove不同的是，这个remove方法删除的是一个指定的映射。定义如下： public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } 实际上，对于存在于map中的一条映射key-value，调用remove(key)和remove(key, value)的效果是一样的，因为key和key-value都是唯一的，不会重复，所以当存在这种映射的时候，两个方法找到的节点是同一个，所以执行结果是一样的。 public void clear() {...} 清空映射。定义如下： public void clear() { Node[] tab; modCount++; if ((tab = table) != null && size > 0) { size = 0; for (int i = 0; i 可以是将多有的哈希桶置为null。那么丢掉的链表/红黑树节点怎么办呢？不是应该一个个释放掉以帮助gc么？？？ public boolean containsValue(Object value) {...} 如果映射关系中存在一个或多个value等于指定值的映射，就返回true。 public boolean containsValue(Object value) { Node[] tab; V v; if ((tab = table) != null && size > 0) { for (int i = 0; i e = tab[i]; e != null; e = e.next) { if ((v = e.value) == value || (value != null && value.equals(v))) return true; } } } return false; } 可以看到这里实际上用到的是for双重循环，外层遍历了哈希桶数组，内容遍历了链表。这里有一个问题，为什么此时部分为链表或红黑树的情况？？？ public Set keySet(){...} 将返回该映射的所有key值集合。注意的是，如果对该key值做修改，这种修改将会反映到map中，反之亦然。为什么呢？因为它实现的本质是迭代器(Iterator)！！！定义如下： public Set keySet() { Set ks = keySet; if (ks == null) { ks = new KeySet(); keySet = ks; } return ks; } transient Set keySet; 从上面方法中可以看出，该方法实际上是返回了实例变量keySet，这个实例在该方法在第一次被调用的时候被赋值为一个KeySet类的实例，而KeySet类的定义如下： final class KeySet extends AbstractSet { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator iterator() { return new KeyIterator(); } public final boolean contains(Object o) { return containsKey(o); } public final boolean remove(Object key) { return removeNode(hash(key), key, null, false, true) != null; } public final Spliterator spliterator() { return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer action) { Node[] tab; if (action == null) throw new NullPointerException(); if (size > 0 && (tab = table) != null) { int mc = modCount; for (int i = 0; i e = tab[i]; e != null; e = e.next) action.accept(e.key); } if (modCount != mc) throw new ConcurrentModificationException(); } } } final class KeyIterator extends HashIterator implements Iterator { public final K next() { return nextNode().key; } } 这个类只有默认的无参的构造方法，KeySet的继承关系是：KeySet-AbstractSet-AbstractCollection-Object，但是检查了一圈，发现无参构造方法都是空的，然而debug跟踪发现，在new KeySet()方法之后keySet确实有值了，到底是什么时候取得这个值的呢？我觉的很奇怪？？？ 但是可以确定的是，keySet的获取是依靠迭代器实现的，所以对keySet的修改类似于对迭代器的操作，返回的是一个值的拷贝值。但是如果这个值是一个引用，那么对这个“拷贝值”的修改将会影响原映射。 这个方法还有一个疑问：该方法只在keySet为null的时候进行new，如果我进行下面这种实验： public static void main(String[] args) { Map map = new HashMap<>(); map.put(\"test1\", \"test1\"); map.put(\"test2\", \"test2\"); map.put(\"test3\", \"test3\"); Set keys = map.keySet(); for (String key : keys){ System.out.print(key + \" \"); } map.put(\"test4\", \"test4\"); keys = map.keySet(); //第二次取得keySet for (String key : keys){ //这里到底能不能输出test4呢？ System.out.print(key + \" \"); } } 那么我第二次取得keySet的时候，是否可以取出\"test4\"呢？经过实验是可以的，在进行Set ks = keySet;这一步骤时，就可以观察到此时keyset包含了该值，但是我记得在之前putVal的时候，并没有对keyset有过什么处理，那么keySet到底是什么时候产生变化的呢？？？ public Collection values() {...} 该方法返回映射关系中值的集合。定义如下： public Collection values() { Collection vs = values; if (vs == null) { vs = new Values(); values = vs; } return vs; } transient Collection values; final class Values extends AbstractCollection { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator iterator() { return new ValueIterator(); } public final boolean contains(Object o) { return containsValue(o); } public final Spliterator spliterator() { return new ValueSpliterator<>(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer action) { Node[] tab; if (action == null) throw new NullPointerException(); if (size > 0 && (tab = table) != null) { int mc = modCount; for (int i = 0; i e = tab[i]; e != null; e = e.next) action.accept(e.value); } if (modCount != mc) throw new ConcurrentModificationException(); } } } 和keyset一样，values的修改同样基于迭代器的实现，所以对values的修改会反映到map中。 public Set> entrySet() {...} 这个方法将会返回映射中的所有映射关系，定义如下： public Set> entrySet() { Set> es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; } transient Set> entrySet; final class EntrySet extends AbstractSet> { public final int size() { return size; } public final void clear() { HashMap.this.clear(); } public final Iterator> iterator() { return new EntryIterator(); } public final boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry) o; Object key = e.getKey(); Node candidate = getNode(hash(key), key); return candidate != null && candidate.equals(e); } public final boolean remove(Object o) { if (o instanceof Map.Entry) { Map.Entry e = (Map.Entry) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; } return false; } public final Spliterator> spliterator() { return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0); } public final void forEach(Consumer> action) { Node[] tab; if (action == null) throw new NullPointerException(); if (size > 0 && (tab = table) != null) { int mc = modCount; for (int i = 0; i e = tab[i]; e != null; e = e.next) action.accept(e); } if (modCount != mc) throw new ConcurrentModificationException(); } } } 同样基于迭代器的实现，对其操作的影响将反映到原映射中。entrySet常常用来遍历映射，比keySet和values更具有好的性能，当然这也得看具体的场合。 注意到，keySet和entrySet都是Set，因为key和key-value都是彼此唯一的，而values是Collection类型，因为允许存在重复元素。 一般来说，对map的遍历借助于keySet、values或者entrySet。前两者只能得到key或value，最后一个能得到两者，所以使用地更加普遍一些。下面是一个测试程序： public static void main(String[] args) { Map map = new HashMap<>(); map.put(\"test1\", \"test1\"); map.put(\"test2\", \"test2\"); map.put(\"test3\", \"test3\"); map.put(\"test\", \"test1\"); Collection values = map.values(); for (String value : values){ System.out.print(value + \" \"); //test2 test3 test1 test1 } Set keys = map.keySet(); for (String key : keys){ System.out.print(key + \" \"); //test2 test3 test test1 } Set> entries = map.entrySet(); for (Map.Entry entry : entries){ System.out.print(entry.getKey() + \" - \" + entry.getValue() + \" \");//test2 - test2 test3 - test3 test - test1 test1 - test1 } } 可以看到这三种遍历方式的特点，以及注意到HashMap不能保证元素的顺序的特点。 public V getOrDefault(Object key, V defaultValue){...} 这个方法与get方法不同的地方在于：如果找不到指定key对应的value值，就返回参数指定的默认value。实现和get方法几乎一样，就是将null换成defaultValue而已。 @Override public V getOrDefault(Object key, V defaultValue) { Node e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; } public V putIfAbsent(K key, V value) {...} 从名字就可以看出来，进行非覆盖型的put，还记得我们之前putVal有一个参数用来控制覆盖还是非覆盖么？之前的put和HashMap(Map)调用putVal的时候，该参数一直是false，而该方法的参数使用true即可。 另外还有一些方法，比如size、isEmpty、forEach等方法，有的太简单，有的不常用这里就先学习了， ConcurrentHashMap是另一种AbstractMap的实现，它过滤掉了key和value等于null的情况（抛出异常），这个Hashtable有点像。 参考 笔记001--Hashtable/HashMap与key/value为null的关系 深入Java基础（四）--哈希表（1）HashMap应用及源码详解 java1.8 HahMap的改进 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 14:56:29 "},"源码解读/java.util/LinkedHashMap.html":{"url":"源码解读/java.util/LinkedHashMap.html","title":"LinkedHashMap","keywords":"","body":"LinkedHashMap 学习HashMap源码可以知道，HashMap的存储顺序和遍历顺序没有必然的联系。如果我们需要保证存储顺序和遍历顺序的统一，则需要使用LinkedHashMap这个类。 public class LinkedHashMap extends HashMap implements Map 类声明，继承自HashMap。 HashMap的数据结构为： 数组 + 单向链表 + 红黑树 LinkedHashMap的数据结构为: 数组 + 单向链表 + 红黑树 + 双向链表 构造方法 重载了5种构造方法。所有方法的第一步都是使用super来初始化容量和装载因子。第二部分是给accessOrder赋值。这是一个boolean量，其作用是定义LinkedHashMap的顺序： true : 基于访问的顺序，即遍历的时候按照LUR的顺序 false : 基于插入的顺序，即遍历的时候按照FIFO的顺序 这是什么意思呢？下面是一个测试程序： public class LinkedHashMapTest { public static void main(String[] args) { Map map = new LinkedHashMap(16, 0.75f, true); map.put(1, 'a'); map.put(2, 'b'); map.put(3, 'b'); display(map);//map初始化之后，不管accessOrder的值是false还是true，这里都将按照初始化的顺序进行打印 //此处对map进行了访问 map.get(1); map.get(2); display(map);//由于初始化map的时，accessOrder设置成true，即基于访问顺序，所以此处将按照312的顺序打印 } public static void display(Map map){ Iterator> iterator = map.entrySet().iterator(); while (iterator.hasNext()){ Map.Entry entry = iterator.next(); System.out.println(entry.getKey() + \" : \" + entry.getValue()); } } } 从上例可以看出，当accessOrder设置为true的顺序时，LinkedList将基于访问的顺序，什么意思呢？就是使用LUR(最近最少被使用的调度算法)，将最近被访问的元素加到了最后。 从LinkedHashMap的构造方法中并不能看出它是如何维护元素的顺序的。实际上，LinkedHashMap仍旧采用HashMap来操作数据结构，另外使用了LinkedList来维护插入元素的先后顺序。下面就比较一下HashMap与LinkedHashMap中元素节点的数据结构的不同： //HashMap static class Node implements Map.Entry { final int hash; final K key; V value; Node next; } // LinkedHashMap static class Entry extends HashMap.Node { Entry before, after; Entry(int hash, K key, V value, Node next) { super(hash, key, value, next); } } //双向链表的头结点 transient LinkedHashMap.Entry head; //双向链表的尾节点 transient LinkedHashMap.Entry tail; 在HashMap中，内部类Node作为了节点的数据结构，其中具有属性hash、key、value和next，HashMap整体采取了哈希桶+单向链表的数据结构来存储互数据。而LinkedHashMap中，内部类Entry作为了节点的数据结构，它继承自HashMap的内部类Node，比它多了一两个属性before和after，所以LinkedHashMap是利用双向列表来维护元素的访问顺序的。看到这里可能有疑问呢，next和after不是一个意思么？不是的！！！千万要记住，next用来维护HashMap上指定table上的连接的Entry的顺序，而before和after是用来维护Entry的插入顺序的。 在LinkedHashMap的构造方法中，并未看到对于双向链表的创建和使用。这些操作发生在添加元素的时候。当添加元素的时候，将会调用继承自HashMap的putVal方法，这个方法中将判断是否已经存在该节点，当不存在的情况下，根据当前是Node类型还是TreeNode类型来new一个新的节点，即调用newNode或newTreeNode方法。在LinkedHashMap中这两个方法被重写： Node newNode(int hash, K key, V value, Node e) { LinkedHashMap.Entry p = new LinkedHashMap.Entry(hash, key, value, e); linkNodeLast(p); return p; } TreeNode newTreeNode(int hash, K key, V value, Node next) { TreeNode p = new TreeNode(hash, key, value, next); linkNodeLast(p); return p; } private void linkNodeLast(LinkedHashMap.Entry p) { LinkedHashMap.Entry last = tail; tail = p; if (last == null) head = p; else { p.before = last; last.after = p; } } 可以看到，newNode中除了创建一个Node的实例外，还将这个节点链接到双向列表的最后。newTreeNode中，TreeNode是LinkedHashMap.Entry的子类，所以可以将其链接到双向链表的最后。 所以这样一来，LinkedHashMap的结构大致是这样： HashMap中不存在before和after域，所以遍历的时候只是按照哈希桶和链表进行访问，并不能保证按照元素的插入顺序进行访问。而LinkedHashMap维护了一个双向链表，这个链表的顺序就是访问访问顺序，所以能够按照插入顺序进行访问。 在对元素进行插入和删除的时候，除了对哈希桶和链表本身做增加和删除的操作，还需要修改双向链表，而这个操作在afterNodeInsertion和afterNodeRemoval中进行。这两个方法在HashMap中定义，但是方法体为空，在LinkedHashMap中重写了这两个方法。 void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry first; if (evict && (first = head) != null && removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } void afterNodeRemoval(Node e) { // unlink LinkedHashMap.Entry p = (LinkedHashMap.Entry)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; } 之前我们说到，在创建LinkedHashMap的时候，可以定义accessOrder为true，这样可以基于访问顺序进行访问，即最近被访问的元素总会被至于双向链表的最后。这种实现在方法afterNodeAccess中体现，同样，该方法定义在HashMap中，方法体为空，在LinkedHashMap被重写： void afterNodeAccess(Node e) { // move node to last LinkedHashMap.Entry last; if (accessOrder && (last = tail) != e) { LinkedHashMap.Entry p = (LinkedHashMap.Entry)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } 它实际上就是修改了中双向链表中最后被访问的元素节点的两个指针，使得该节点处于双向链表的最后。而这个方法在任何元素访问的方法（比如get，replace等）中被调用。 LinkedHashMap 的内容还需要细纠！ 参考 初识LinkedHashMap 【集合框架】JDK1.8源码分析之LinkedHashMap（二） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 10:53:30 "},"源码解读/java.util/SortedMap.html":{"url":"源码解读/java.util/SortedMap.html","title":"SortedMap","keywords":"","body":"SortedMap SortedMap是一个接口，表明map中的映射关系将按照key的自然顺序或指定顺序进行排序，这种排序表现在以迭代器遍历容器的时候。要求，放入容器内的映射关系中的key必须实现Comparable接口或者被指定的比较器接受。接口定义如下： 注意到其中comparator方法，它用来返回使用的比较器。 实现这个接口的类很多，典型的有NavigableMap，而TreeMap通过这NavigableMap这个接口实现了映射关系的比较。而TreeMap的实现是通过红黑树。红黑树是有特殊性质的平衡二叉排序树。这里排序的“序”就是我们所说的比较器。 我们一般采用TreeSet来实现映射关系的排序，比如： public static void main(String[] args) { HashMap map=new HashMap(); map.put(\"a\", \"abc\"); map.put(\"b\",\"de\"); map.put(\"c\", \"kg\"); for (Map.Entry entry: map.entrySet()) { System.out.println(\"排序之前:\"+entry.getKey()+\" 值\"+entry.getValue()); } System.out.println(\"======================================================\"); SortedMap sort=new TreeMap(map); Set> entry1=sort.entrySet(); Iterator> it=entry1.iterator(); while(it.hasNext()) { Map.Entry entry=it.next(); System.out.println(\"排序之后:\"+entry.getKey()+\" 值\"+entry.getValue()); } } 需要说明，HashMap比SortedMap快，所以当不需要排序的时候，用HashMap，而如果需要排序的时，也先用HashMap存储映射关系，然后用HashMap的对象来创建SortedMap接口对象。就像上面的例子一样。 SortedMap在实际的应用中有广泛的应用，一个典型的例子就是生成微信签名，其api原文是： 设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。 这里我们就可以用SortedMap来存储映射关系，然后拼接成字符串就行。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-20 16:25:28 "},"源码解读/java.util/TreeMap.html":{"url":"源码解读/java.util/TreeMap.html","title":"TreeMap","keywords":"","body":"TreeMap 红黑树的实现。真正变态级的数据结构，更多红黑树的概念和操作参考数据结构相关博文。 该类的结构如下： public class TreeMap extends AbstractMap implements NavigableMap, Cloneable, java.io.Serializable 类声明，继承自AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。 映射关系Entry TreeMap继承了抽象了AbstractMap，重写了映射关系的数据结构，定义如下： static final class Entry implements Map.Entry { K key; V value; Entry left; Entry right; Entry parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * {@code null} child links, and BLACK color. */ Entry(K key, V value, Entry parent) { this.key = key; this.value = value; this.parent = parent; } /** * Returns the key. * * @return the key */ public K getKey() { return key; } /** * Returns the value associated with the key. * * @return the value associated with the key */ public V getValue() { return value; } /** * Replaces the value currently associated with the key with the given * value. * * @return the value associated with the key before this method was * called */ public V setValue(V value) { V oldValue = this.value; this.value = value; return oldValue; } public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return valEquals(key,e.getKey()) && valEquals(value,e.getValue()); } public int hashCode() { int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; } public String toString() { return key + \"=\" + value; } } 每个树的节点都是一个映射关系，即Entry的实例，其中包含属性key(键) 、value(值)、left(左孩子)、right(右孩子)、parent(父节点)和颜色（默认为黑色），注意BLACK和RED都是布尔型的变量，分别对应true和false。而对于一棵树来说，只需要保存根节点即可。所以TreeMap中保存了根节点： private transient Entry root; 构造方法 定义了四种构造方法。 public TreeMap() { comparator = null; } public TreeMap(Comparator comparator) { this.comparator = comparator; } public TreeMap(Map m) { comparator = null; putAll(m); } public TreeMap(SortedMap m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } } 可以看出，TreeMap的构造中最重要的是对comparator的赋值，该变量定义如下： private final Comparator comparator; 可以看到，这是一个比较器，我们可以认为指定比较器，或者为null的时候表明是自然排序，所以TreeMap是一个可以自定义排序键值对容器。 可以根据一个SortedMap来创建红黑树。 红黑树的核心在于节点插入和删除操作，分别对应TreeMap的put和delete方法。下面就着重将这两个方法的实现。 public V put(K key, V value) 这个方法用来插入一个节点到红黑树中，如果红黑树中已经包含该key节点，则将原value值将被覆盖。 在看这个方法之前，先复习一下红黑树的插入算法。 红黑树的插入算法分为以下步骤： 定位：红黑树首先是一棵BST树，所以按照BST的插入规则定位到应该插入的位置。 着色：将新节点着色为红色。 如果该节点是根节点，则置为黑色，插入算法结束。 如果该节点的父节点是黑色，则什么都不用做，插入算法结束。 如果该节点的父亲节点是红色，那么需要考虑叔叔节点的颜色： 如果叔叔节点(u)是红色，即此时叔叔节点和父亲节点是红色，祖父节点为黑色，则此时将父亲节点和叔叔节点置为黑色，将祖父节点置为红色，以祖父节点为当前节点，递归匹配情况。 如果叔叔节点(u)是黑色，此时根据新节点(n)、父亲节点(p)和祖父节点(g)的关系可以分为四种情况。 新节点(n)是父亲节点(p)的左节点，父亲节点(p)是祖父节点(g)的左节点，此时需要进行LL旋转，即以父亲节点(p)为轴心进行单项右旋。之后将父亲节点(p)设置为黑色，祖父节点(g)设置为红色。 新节点(n)是父亲节点(p)的右节点，父亲节点(p)是祖父节点(g)的右节点，此时需要进行RR旋转，即以父亲节点(p)为轴心进行单项左旋。之后将父亲节点(p)设置为黑色，祖父节点(g)设置为红色。 新节点(n)是父亲节点(p)的左节点，父亲节点(p)是祖父节点(g)的右节点，此时需要进行RL旋转，即以当前节点(n)为轴心进行先进行左旋后进行右旋。之后将当前节点(n)设置为黑色，祖父节点(g)设置为红色。 新节点(n)是父亲节点(p)的右节点，父亲节点(p)是祖父节点(g)的左节点，此时需要进行LR旋转，即以当前节点(n)为轴心进行先进行右旋后进行左旋。之后将当前节点(n)设置为黑色，祖父节点(g)设置为红色。 LL旋转是单项右旋，以父节点为轴心；RR旋转是单项左旋，以父节点为轴心。LR旋转是先左旋后右旋，以当前节点为轴心；RL旋转是先右旋后左旋，以当前节点为轴心。 有了以上的认知，我们来看看TreeMap中的put方法如何实现节点插入： public V put(K key, V value) { //用t表示二叉树的当前节点 Entry t = root; //t为null表示一个空树，即TreeMap中没有任何元素，直接插入 if (t == null) { //比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？ compare(key, key); // type (and possibly null) check //将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root root = new Entry<>(key, value, null); //容器的size = 1，表示TreeMap集合中存在一个元素 size = 1; //修改次数 + 1 modCount++; return null; } int cmp; //cmp表示key排序的返回结果 Entry parent; //父节点 // split comparator and comparable paths Comparator cpr = comparator; //指定的排序算法 //如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合 if (cpr != null) { do { parent = t; //parent指向上次循环后的t //比较新增节点的key和当前节点key的大小 cmp = cpr.compare(key, t.key); //cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点 if (cmp 0) t = t.right; //cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值 else return t.setValue(value); } while (t != null); } //如果cpr为空，则采用默认的排序算法进行创建TreeMap集合 else { if (key == null) //key值为空抛出异常 throw new NullPointerException(); /* 下面处理过程和上面一样 */ Comparable k = (Comparable) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp 0) t = t.right; else return t.setValue(value); } while (t != null); } //将新增节点当做parent的子节点 Entry e = new Entry<>(key, value, parent); //如果新增节点的key小于parent的key，则当做左子节点 if (cmp 上面的代码很好理解，实际上执行的是BST节点插入的过程，不同的是，这里可以根据开发者是否制定了比较器来决定插入的BST的插入顺序。对于红黑树来说，真正重要的是fixAfterInsertion方法，这个方法是进行树调整、平衡的过程，使其成为一个具备红黑树特征的平衡排序二叉树。其定义如下： /** * 新增节点后的修复操作 * x 表示新增节点 */ private void fixAfterInsertion(Entry x) { x.color = RED; //新增节点的颜色为红色 //循环 直到 x不是根节点，且x的父节点为红色 while (x != null && x != root && x.parent.color == RED) { //如果X的父节点（P）是其祖父节点（G）的左节点 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { //获取X的叔节点(U) Entry y = rightOf(parentOf(parentOf(x))); //如果X的叔节点（U） 为红色，此时将父节点和叔节点置为黑色，祖父节点置为红色，以祖父节点为当前节点，继续进行。 if (colorOf(y) == RED) { //将X的父节点（P）设置为黑色 setColor(parentOf(x), BLACK); //将X的叔节点（U）设置为黑色 setColor(y, BLACK); //将X的父节点的父节点（G）设置红色 setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } //如果X的叔节点（U为黑色）；这里会存在两种情况 else { //如果X节点为其父节点（P）的右子树，则先进行左旋在进行右旋，旋转中心是其父节点 if (x == rightOf(parentOf(x))) { //将X的父节点作为X x = parentOf(x); //左旋转 rotateLeft(x); } //将X的父节点（P）设置为黑色 setColor(parentOf(x), BLACK); //将X的父节点的父节点（G）设置红色 setColor(parentOf(parentOf(x)), RED); //以X的父节点的父节点（G）为中心右旋转 rotateRight(parentOf(parentOf(x))); } } //如果X的父节点（P）是其父节点的父节点（G）的右节点 else { //获取X的叔节点（U） Entry y = leftOf(parentOf(parentOf(x))); //如果X的叔节点（U） 为红色，此时将父节点和叔节点置为黑色，祖父节点置为红色，以祖父节点为当前节点，继续进行。 if (colorOf(y) == RED) { //将X的父节点（P）设置为黑色 setColor(parentOf(x), BLACK); //将X的叔节点（U）设置为黑色 setColor(y, BLACK); //将X的父节点的父节点（G）设置红色 setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } //如果X的叔节点（U为黑色）；这里会存在两种情况 else { //如果X节点为其父节点（P）的左子树，则先进行右旋后进行左旋，旋转中心是其父节点 if (x == leftOf(parentOf(x))) { //将X的父节点作为X x = parentOf(x); //右旋转 rotateRight(x); } //（情况五） //将X的父节点（P）设置为黑色 setColor(parentOf(x), BLACK); //将X的父节点的父节点（G）设置红色 setColor(parentOf(parentOf(x)), RED); //以X的父节点的父节点（G）为中心右旋转 rotateLeft(parentOf(parentOf(x))); } } } //将根节点G强制设置为黑色 root.color = BLACK; } 以上是红黑树调整的过程实现，其中坐旋转rotateLeft和rotateRight的代码实现如下： // 左旋转 private void rotateLeft(Entry p) { if (p != null) { //获取P的右子节点， Entry r = p.right; //将R的左子树设置为P的右子树 p.right = r.left; //若R的左子树不为空，则将P设置为R左子树的父亲 if (r.left != null) r.left.parent = p; //将P的父亲设置R的父亲 r.parent = p.parent; //如果P的父亲为空，则将R设置为跟节点 if (p.parent == null) root = r; //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树 else if (p.parent.left == p) p.parent.left = r; //否则R设置为P的父节点（G）的右子树 else p.parent.right = r; //将P设置为R的左子树 r.left = p; //将R设置为P的父节点 p.parent = r; } } 所谓左旋，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left ---> N ,N.left ---> P，该过程的动画如图所示（途中的E节点就相当于rotateLeft方法的参数p，即为轴点） 右旋方法定义如下： private void rotateLeft(Entry p) { if (p != null) { //获取P的右子节点，其实这里就相当于新增节点N（情况四而言） Entry r = p.right; //将R的左子树设置为P的右子树 p.right = r.left; //若R的左子树不为空，则将P设置为R左子树的父亲 if (r.left != null) r.left.parent = p; //将P的父亲设置R的父亲 r.parent = p.parent; //如果P的父亲为空，则将R设置为跟节点 if (p.parent == null) root = r; //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树 else if (p.parent.left == p) p.parent.left = r; //否则R设置为P的父节点（G）的右子树 else p.parent.right = r; //将P设置为R的左子树 r.left = p; //将R设置为P的父节点 p.parent = r; } } 过程与左旋转类似，不再赘述过程，其动画如下： 除此之外还有红黑树节点的着色方法setColor，就是将变更节点颜色，定义如下： private static void setColor(Entry p, boolean c) { if (p != null) p.color = c; } 至此，红黑树的插入操作完成。 public V remove(Object key) 这个方法用来寻找key值对应的树节点，找到后删除该节点。同样，在分析代码之前，我们先回顾下红黑树的删除操作： 红黑树的删除算法可以分为下面几个步骤： 定位：按照BST删除算法定位到应该被删除的那个节点，注意回顾一下二叉树节点删除算法：当被删除节点是叶子节点的时候，直接删除；当被删除节点只具有右子树或左子树之一的时候，将该节点的父节点的相应指针连接到该节点的那个子树上，然后删除该节点；当该节点兼备左右子树的时候，将该节点和左子树中的节点或右子树中的最小节点做交换，然后问题转换成删除前面两种情况。所以这里需要注意，最终需要被删除的那个节点并不一定是最初树中的位置。 如果最终被删除的节点(n)是红色的，那么不需要调整，红黑树的删除算法结束。因为删除一个红色节点，不影响红黑树的平衡性。 如果最终被删除的节点(n)是黑色的，那么该节点所在的路径上黑色节点总数减少1，红黑树失去平衡，需要调整。这时候需要考虑到其父节点(p)、兄弟节点(w)的情况分别进行处理，假设当前节点(n)是父节点(p)的左子节点，n是p的右子节点的情况可以用镜像堆成考虑。 如果兄弟节点(w)是红色的，此时需要交换父节点(p)和兄弟节点(w)的颜色，然后以父节点为轴进行左旋，完成后，当前节点(n)将具有新的兄弟节点。如下图： 之后将变成下面一种情况。 如果兄弟节点(w)是黑色的，此时需要考虑到兄弟节点的左右节点的颜色 如果兄弟节点(w)的两个子节点(x和y)都是黑色，那么此时将兄弟节点(w)设定为红色，将父节点(p)作为当前节点，递归匹配情况。 如果兄弟节点的左节点(x)为红色，右节点(y)为黑色，则需要将左节点(x)设置为黑色，兄弟节点(w)设置为红色，并以左节点(x)为轴进行右旋转。 如果兄弟节点的左节点(x)任意，右节点(y)为红色，则需要右节点(y)设置为黑色，并交换兄弟节点(w)和父节点(p)的颜色，再以兄弟节点(w)为轴进行左旋转。 至此调整结束。 注意，以上情况是当前节点是父节点的左节点的情况，可用镜像对对称来处理当前节点是父节点的右节点的情况，注意相关操作也成镜像堆成，比如当兄弟节点是黑节点，其做左节点为红色，右节点任意，此时需要将左节点设置为红色，然后交换兄弟节点和父节点的颜色，再以兄弟节点为轴进行右旋转。 remove方法的源码如下： public V remove(Object key) { Entry p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; } 其中deleteEntry是关键，定义如下： private void deleteEntry(Entry p) { modCount++; //修改次数 +1 size--; //元素个数 -1 /* * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 * ---------------------（1） */ if (p.left != null && p.right != null) { Entry s = successor(p); p.key = s.key; p.value = s.value; p = s; } //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代 Entry replacement = (p.left != null ? p.left : p.right); /* * 删除节点， * -----------------------（2） */ //如果替代节点不为空 if (replacement != null) { replacement.parent = p.parent; /* *replacement来替代P节点 */ //若P没有父节点，则跟节点直接变成replacement if (p.parent == null) root = replacement; //如果P为左节点，则用replacement来替代为左节点 else if (p == p.parent.left) p.parent.left = replacement; //如果P为右节点，则用replacement来替代为右节点 else p.parent.right = replacement; //同时将P节点从这棵树中剔除掉 p.left = p.right = p.parent = null; /* * 若P为红色直接删除，红黑树保持平衡 * 但是若P为黑色，则需要调整红黑树使其保持平衡 */ if (p.color == BLACK) fixAfterDeletion(replacement); } else if (p.parent == null) { //p没有父节点，表示为P根节点，直接删除即可 root = null; } else { //P节点不存在子节点，直接删除即可 if (p.color == BLACK) //如果P节点的颜色为黑色，对红黑树进行调整 fixAfterDeletion(p); //删除P节点 if (p.parent != null) { if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; } } } 其中successor方法是寻找左子树或右子树中的代替被删除节点的节点，定义如下： static TreeMap.Entry successor(Entry t) { if (t == null) return null; /* * 寻找右子树的最左子树 */ else if (t.right != null) { Entry p = t.right; while (p.left != null) p = p.left; return p; } /* * 选择左子树的最右子树 */ else { Entry p = t.parent; Entry ch = t; while (p != null && ch == p.right) { ch = p; p = p.parent; } return p; } } 从代码中看出，优先选择了右子树中的最小值作为代替。另外在进行节点删除后，需要进行调整和平衡，重点在于fixAfterDeletion的实现： private void fixAfterDeletion(Entry x) { // 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色 while (x != root && colorOf(x) == BLACK) { if (x == leftOf(parentOf(x))) { //若X节点为左节点 //获取其兄弟节点 Entry sib = rightOf(parentOf(x)); /* * 如果兄弟节点为红色 * 策略：改变W、P的颜色，然后以父节点为轴进行一次左旋转 */ if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); } /* * 若兄弟节点的两个子节点都为黑色 * 策略：将兄弟节点变成红色，将父亲节点作为当前节点 */ if (colorOf(leftOf(sib)) == BLACK && colorOf(rightOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { /* * 如果兄弟节点只有右子树为黑色 * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转 */ if (colorOf(rightOf(sib)) == BLACK) { setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); } /* *策略：交换兄弟节点和父节点的颜色， *同时将兄弟节点右子树设置为黑色，最后左旋转 */ setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; } } /** * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了 */ else { Entry sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); } if (colorOf(rightOf(sib)) == BLACK && colorOf(leftOf(sib)) == BLACK) { setColor(sib, RED); x = parentOf(x); } else { if (colorOf(leftOf(sib)) == BLACK) { setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); } setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; } } } setColor(x, BLACK); } 红黑树的删除操作比插入操作更加困难，所以慢慢掌握吧，别着急。 参考 红黑树数据结构剖析 treemap原理 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 11:05:49 "},"源码解读/java.util/NavigableMap.html":{"url":"源码解读/java.util/NavigableMap.html","title":"NavigableMap","keywords":"","body":"NavigableMap Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-14 21:55:48 "},"源码解读/java.util/Hashtable.html":{"url":"源码解读/java.util/Hashtable.html","title":"Hashtable","keywords":"","body":"Hashtable Hashtable和HashMap可谓是焦不离孟，孟不离焦，但凡提起其中一个，一定会用来做对比，两者之间有哪些不同呢？被问的多了，答案也就记住了：默认初始化的大小不同，对null值的允许程度不同，线程安全性不同。所谓的“三大不同”，为什么会有这样的不同呢？还是从源码里找答案。 Hashtable的结构如下： 由于HashMap和Hashtable很大程度是相似，所以下面只挑选几处重要的不同的地方进行学习。 public class Hashtable extends Dictionary implements Map, Cloneable, java.io.Serializable {...} 类声明，HashMap继承自AbstractMap，而Hashtable继承自Dictionary，除此之外相同。 构造方法 同样重载了四种构造方法。 public Hashtable(int initialCapacity, float loadFactor) {...} 指定初始化容量和负载因子。定义如下： public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity [initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); } private float loadFactor; private int threshold; private transient Entry[] table; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 显然Hashtable的设计没有HashMap来的细腻。其存储结构是\"哈希桶数组 + 链表\"的形式，没有红黑树这种骚操作。在对扩容阈值的估计上，简单采取了initialCapacity * loadFactor和MAX_ARRAY_SIZE + 1的最小值，没有2的倍数的约定，同样对于容量也没有2的倍数的约定。容量的最大值为Integer.MAX_VALUE - 8。 public Hashtable(int initialCapacity) {...} 只指定初始容量。定义如下： public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } 从这类可以看到，默认的负载因子为0.75，这一点和HashMap一致。 public Hashtable() 无参的默认构造方法，默认初始化容量为11，初始化负载因子为0.75。从这一定可以看出，Hashtable对容量大小并没有必须为2的倍数这种限定。 public Hashtable() { this(11, 0.75f); } public Hashtable(Map t) {...} 用一个映射关系来创建另外一个映射关系。定义如下： public Hashtable(Map t) { this(Math.max(2*t.size(), 11), 0.75f); putAll(t); } public synchronized void putAll(Map t) { for (Map.Entry e : t.entrySet()) put(e.getKey(), e.getValue()); } public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry entry = (Entry)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) && entry.key.equals(key)) { V old = entry.value; entry.value = value; return old; } } addEntry(hash, key, value, index); return null; } private void addEntry(int hash, K key, V value, int index) { modCount++; Entry tab[] = table; if (count >= threshold) { // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = key.hashCode(); index = (hash & 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry e = (Entry) tab[index]; tab[index] = new Entry<>(hash, key, value, e); count++; } protected void rehash() { int oldCapacity = table.length; Entry[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; for (int i = oldCapacity ; i-- > 0 ;) { for (Entry old = (Entry)oldMap[i] ; old != null ; ) { Entry e = old; old = old.next; int index = (e.hash & 0x7FFFFFFF) % newCapacity; e.next = (Entry)newMap[index]; newMap[index] = e; } } } 实现手段非常简单粗暴了，其大小简单粗暴取为该映射的大小的2倍与11的最大值。注意到，之后调用的putAll、put、addEntry方法都是同步方法，Hashtable中其他方法也都是同步方法，这也就是为什么hashtable为什么是线程安全的原因。注意put方法，当value为null的时候会抛出异常，这就确保了Hashtable不能存储值为null的映射。在addEntry方法中，如果key为null，那么hash = key.hashCode();这句话直接会抛出空指针异常，这就确保了Hashtable不能存储key为null的映射。后面的方法都比较简单。注意到，count表示实际存储的映射关系的个数，等同于HashMap中的size，当实际个数超过阈值的时候我们需要进行重新散列，方法就是扩容后再散列，新容量等于2倍的旧容量再加上1（HashMap的扩容规则是2倍）。后面的过程也比较简单，这里就不详细说了。 keys方法和elements方法 这两个方法都覆盖其父类Dictionary中的方法，定义如下: public synchronized Enumeration keys() { return this.getEnumeration(KEYS); } public synchronized Enumeration elements() { return this.getEnumeration(VALUES); } 注意到，这个方法的可见性是protected，即包内可见。所以我们在使用的时候都不怎么用到。 contains方法 Hashtable有三种contains方法，实际上只有两种用处，就是判断指定的key或者value是否存在。定义如下： public synchronized boolean contains(Object value) { if (value == null) { throw new NullPointerException(); } Entry tab[] = table; for (int i = tab.length ; i-- > 0 ;) { for (Entry e = tab[i] ; e != null ; e = e.next) { if (e.value.equals(value)) { return true; } } } return false; } public boolean containsValue(Object value) { return contains(value); } public synchronized boolean containsKey(Object key) { Entry tab[] = table; int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { return true; } } return false; } Hashtable同样有一些与HashMap类似的方法，比如remove、keyset、values、entrySet等，在此不做赘述。 总结一下HashMap和Hashtable的差异之处： HashMap继承自AbstractMap，Hashtable继承自Dictionary，这也是造成两者不同的主要原因。 HashMap默认初始容量为16，负载因子为0.75，约定容量和阈值必须为2的倍数，即一定为合数，扩容策略为2倍；Hashtable默认初始容量为11，负载因子为0.75，没有2的倍数的硬性约定，扩容策略为2倍加上1。（Hashtable的容量设计里面来自于“素数导致冲突的概率小于合数”，参考http://blog.csdn.net/liuqiyao_01/article/details/14475159） HashMap允许一个key为null的映射和多个value为null的映射；Hashtable不允许key为null或value为null的映射，否则会抛出空指针异常。 HashMap是非线程安全的，如果要建立线程安全的HashMap，则需要借助Collections；Hashtable是线程安全的。 HashMap发生冲突的使用链地址法，Hashtable使用再散列。 HashMap借助哈希桶 + 链表/红黑树的设计（JDK1.8）,Hashtable借助哈希桶 + 链表的设计方法。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-19 14:17:14 "},"源码解读/java.util/ArrayDeque.html":{"url":"源码解读/java.util/ArrayDeque.html","title":"ArrayDeque","keywords":"","body":"ArrayDeque Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 00:49:34 "},"源码解读/java.util/PriorityQueue.html":{"url":"源码解读/java.util/PriorityQueue.html","title":"PriorityQueue","keywords":"","body":"PriorityQueue PriorityQueue是优先队列，实际是就是堆。堆是一种特殊的树，具备根节点大于左右左子树上的节点或根节点小于左右子树上的节点，前者称为大根堆，后者称为小跟堆。 PriorityQueue使用数组实现堆，因为堆是完全二叉树，所以使用数组可以随机访问节点的父节点和子节点。注意，PriorityQueue不允许存在null元素。 public class PriorityQueue extends AbstractQueue implements java.io.Serializable 类声明，PriorityQueue继承自AbstractQueue，而这个抽象类实现了接口Quequ。 构造方法 PriorityQueue提供了7种重载的构造方法。下面四种构造方法用来指定队列的容量和比较器： public PriorityQueue() { this(DEFAULT_INITIAL_CAPACITY, null); } public PriorityQueue(int initialCapacity) { this(initialCapacity, null); } public PriorityQueue(Comparator comparator) { this(DEFAULT_INITIAL_CAPACITY, comparator); } public PriorityQueue(int initialCapacity, Comparator comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity 可以看到，默认的队列容量为11，默认的比较器为null，此时队列将按照自然顺序进行元素的比较。另外，优先队列的存储结构实际上是一个Object类型的数组，从0单元开始存储。对于完全二叉树来来说，queue[i]的左右孩子节点分别是queue[2i+1]和queue[2(i+1)]。 另外三种构造方法接收一个集合或者优先队列作为参数，定义如下： public PriorityQueue(Collection c) { if (c instanceof SortedSet) { SortedSet ss = (SortedSet) c; this.comparator = (Comparator) ss.comparator(); initElementsFromCollection(ss); } else if (c instanceof PriorityQueue) { PriorityQueue pq = (PriorityQueue) c; this.comparator = (Comparator) pq.comparator(); initFromPriorityQueue(pq); } else { this.comparator = null; initFromCollection(c); } } private void initFromCollection(Collection c) { initElementsFromCollection(c); heapify(); } public PriorityQueue(PriorityQueue c) { this.comparator = (Comparator) c.comparator(); initFromPriorityQueue(c); } private void initFromPriorityQueue(PriorityQueue c) { if (c.getClass() == PriorityQueue.class) { this.queue = c.toArray(); this.size = c.size(); } else { initFromCollection(c); } } public PriorityQueue(SortedSet c) { this.comparator = (Comparator) c.comparator(); initElementsFromCollection(c); } private void initElementsFromCollection(Collection c) { Object[] a = c.toArray(); // If c.toArray incorrectly doesn't return Object[], copy it. if (a.getClass() != Object[].class) a = Arrays.copyOf(a, a.length, Object[].class); int len = a.length; if (len == 1 || this.comparator != null) for (int i = 0; i 可以看到，当参数为SortedSet和PriorityQueue的实例的时候，由于元素已经是有序的，只需要将其中的存储结构变成数组即可，不需要调整，比如对于PriorityQueue的实例，直接取得该实例的存储结构。对于SortedSet实例，复制了一份该实例中的数组，但是注意，这个过程中需要检查元素是否存在null值，PriorityQueue是不允许null值出现的，将抛出空指针异常。 而对于其他集合，由于无序性，所以需要堆的构造，这里重要的操作在heapify方法中定义： private void heapify() { for (int i = (size >>> 1) - 1; i >= 0; i--) siftDown(i, (E) queue[i]); } private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } @SuppressWarnings(\"unchecked\") private void siftDownUsingComparator(int k, E x) { int half = size >>> 1; while (k 0) c = queue[child = right]; if (comparator.compare(x, (E) c) key = (Comparable)x; int half = size >>> 1; // loop while a non-leaf while (k ) c).compareTo((E) queue[right]) > 0) c = queue[child = right]; //这里比较左右孩子的大小，最终c是左右孩子中比较小的那一个节点 if (key.compareTo((E) c) 这里可以看到在得到一个无须的数组之后，需要从最后一个节点的父节点开始进行调整，这种调整是将以此节点为根节点的树调整为堆。siftDownUsingComparator和siftDownComparable主要是考虑到是否定义了比较器，如果定义了比较器，则根据比较器排序，如果没有定义比较器，则按照自然顺序进行排序。这个方法也是poll即出队方法的核心，我们下面再讨论。 PriorityQueue的主要操作是新建、插入和删除，构造函数承担了新建的任务，下面我们就只用讨论插入和删除操作。 插入 插入操作是在一个堆中插入一个新的节点，经过调整之后仍然是一个堆。PriorityQueue中提供了add和offer方法，前者直接调用后者，后者定义如下： public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i >= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; } private void grow(int minCapacity) { int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity > 1)); // overflow-conscious code if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity); } private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); } 这里我们看到，往其中插入元素的时候首先进行了扩容，扩容的政策是如果当前数组比较小（小于64），则增加2倍，如果比较大（大于64），则增加1倍+2。然后判断队列是否为空，为空则直接插入作为根节点，不为空则使用插入算法，而插入算法siftUp仍旧对是否指定比较器做了区分，我们着重看一下指定了比较器的插入算法： @SuppressWarnings(\"unchecked\") private void siftUpUsingComparator(int k, E x) { while (k > 0) { int parent = (k - 1) >>> 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) >= 0) break; queue[k] = e; k = parent; } queue[k] = x; } 由以上算法可以看出，新插入的节点一开始是被放到了数组的最后一个位置，然后比较其祖先节点序列，将大于它的往下移动，慢慢找到自己的位置，最后赋值到该位置，完成了插入操作。下图是该过程的示例： 删除 堆的删除的位置是定的，一定发生在根节点。PriorityQueue提供poll和remove方法，这两个方法是不一样的，首先来看poll方法： @SuppressWarnings(\"unchecked\") public E poll() { if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result; } poll删除的是根节点，它将根节点和最后一个节点交换，其根本还是从根节点开始进行\"下沉\"的操作，调用了siftDown方法，这个方法在前面已经讲过。 remove和poll不一样的是，它接受一个Object类型的参数，不仅可以删除头节点而且还可以用 remove(Object o) 来删除堆中的与给定对象相同的最先出现的对象。其定义如下： public boolean remove(Object o) { int i = indexOf(o); if (i == -1) return false; else { removeAt(i); return true; } } private int indexOf(Object o) { if (o != null) { for (int i = 0; i = 0 && i 而这个过程就比较麻烦，因为删除了这个节点后，不仅需要\"上浮\"还需要“下沉”操作。下面是一个remove(4)的过程： PriorityQueue默认的是小根堆，如果实现大根堆呢？可以传入自定义的比较器，例如： private static final int DEFAULT_INITIAL_CAPACITY = 11; PriorityQueue maxHeap=new PriorityQueue(DEFAULT_INITIAL_CAPACITY, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2-o1; } }); 这样得到的maxHeap就是一个大根堆。 参考 Java堆结构PriorityQueue完全解析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-22 15:03:59 "},"源码解读/java.util/Spliterator.html":{"url":"源码解读/java.util/Spliterator.html","title":"Spliterator","keywords":"","body":"Spliterator Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-30 15:41:40 "},"源码解读/java.util/Objects.html":{"url":"源码解读/java.util/Objects.html","title":"Objects","keywords":"","body":"Objects Objects和我们学到的Object类可不是同一个东西，后者是Java中所有类的父类，而前者是对象操作的工具类而已。没错，Objects类之于Object，就类似于Arrays之于Array，Collections之于Collection一样，只是一个工具类而已。 Objects工具类提供了对象操作的方法，它提供的方法都是静态方法。比如比较两个对象是否相等，返回对象的哈希码，取得对象的string值等等。 其实仔细想想这些方法是怎么实现的呢？还是调用了Object对象本身的方法。既然Object就可以解决的事情，为什么还要另外写一个工具类。原因大概有二：一是再封装一层，工具类的作用不就是为了方便么，比如说如果我们判断一个对象是不是null, 那么就每个地方都写object == null，这不是low的不是？二是为了解决特殊的对象null可能造成的NullPointException，这个工具类都提前帮你处理好的。 类结构如下： public final class Objects 类声明，被final修饰，说明不能被继承。 private Objects() {...} 构造方法，是私有的，说明这个类是没有办法实例化的。而这个私有构造方法是怎么实现的呢？ private Objects() { throw new AssertionError(\"No java.util.Objects instances for you!\"); } 实际上，这个类不能被继承，构造方法私有，按道理将说，不会被调用才是，但是这个方法仍旧在方法体中抛出了异常，这是防止有人调用它进行实例化？那什么时候可能被调用呢？难道是反射？ 另外需要注意的是，这个类抛出的异常是AssertionError，这是一个Error类的子类，属于JVM严重错误了。 public static boolean equals(Object a, Object b){...} 静态方法，顾名思义，就是比较两个对象是不是相等?什么是相等呢？如果两个对象指向同一个，那么可能相等。如果指向不一样时，对象按照自己的评判标准判定相等，那么它们就是相等的，比如String类型，如果对应字符位上是相等的，那么两者就是相等的。实现如下： public static boolean equals(Object a, Object b) { return (a == b) || (a != null && a.equals(b)); } public static boolean deepEquals(Object a, Object b){...} deepEquals方法是深层比较的方法，实际上调用的是Arrays的deepEquals0方法，说明这个方法主要是为数组对象服务的，其结果与Arrays的deepEquals比较结果一致。如果参数不是数组，那么与equals方法的结果是一直的。 public static boolean deepEquals(Object a, Object b) { if (a == b) return true; else if (a == null || b == null) return false; else return Arrays.deepEquals0(a, b); } static boolean deepEquals0(Object e1, Object e2) { assert e1 != null; boolean eq; if (e1 instanceof Object[] && e2 instanceof Object[]) eq = deepEquals ((Object[]) e1, (Object[]) e2); else if (e1 instanceof byte[] && e2 instanceof byte[]) eq = equals((byte[]) e1, (byte[]) e2); else if (e1 instanceof short[] && e2 instanceof short[]) eq = equals((short[]) e1, (short[]) e2); else if (e1 instanceof int[] && e2 instanceof int[]) eq = equals((int[]) e1, (int[]) e2); else if (e1 instanceof long[] && e2 instanceof long[]) eq = equals((long[]) e1, (long[]) e2); else if (e1 instanceof char[] && e2 instanceof char[]) eq = equals((char[]) e1, (char[]) e2); else if (e1 instanceof float[] && e2 instanceof float[]) eq = equals((float[]) e1, (float[]) e2); else if (e1 instanceof double[] && e2 instanceof double[]) eq = equals((double[]) e1, (double[]) e2); else if (e1 instanceof boolean[] && e2 instanceof boolean[]) eq = equals((boolean[]) e1, (boolean[]) e2); else eq = e1.equals(e2); // 如果都是非数组参数，那么结果与`equals`无异 return eq; } public static int hashCode(Object o){...} 用来返回对象的哈希值，本质还是调用对象的hashCode方法，但是它对null值做了特殊的处理，约定null值的哈希值为0。 public static int hashCode(Object o) { return o != null ? o.hashCode() : 0; } 这个hashCode方法被应用到了HashMap的使用中，对于key的哈希计算就是调用了这个方法。 public static int hash(Object... values){...} 注意这个hash方法和hashCode方法是不一样的。首先不一样的地方在于参数，它可以接受一组边长参数，最后返回的结果是这组参数共同组成的哈希值。定义如下： public static int hash(Object... values) { return Arrays.hashCode(values); } public static int hashCode(Object a[]) { if (a == null) return 0; int result = 1; for (Object element : a) result = 31 * result + (element == null ? 0 : element.hashCode()); return result; } 可以看到，实现原理还是Arrays类的静态方法hashCode，接受一个对象数组，使用每一个数组对象本身的哈希值，使用特定的规则来创建一个总的哈希值。这个规则是：a[0] * 31^ (n - 1) + a[1] * 31^ (n-2) + ... + a[n - 1] * 31，诶是不是有点熟悉？没错String类就是同样的规则来构建自己的哈希值的，它的对象数组就是字符数组。 toString方法 得到对象的String结果。重载了两种方法。 public static String toString(Object o){...} 这个比较简单，返回的是参数对象的string值。定义如下： public static String toString(Object o) { return String.valueOf(o); } public static String valueOf(Object obj) { return (obj == null) ? \"null\" : obj.toString(); } 而要注意的是，对于null值，输出的结果是\"null\"。 public static String toString(Object o, String nullDefault){...} 第二个方法给了一个对于null值，默认的输出参数。当对象为null时候，就输出这个默认的值。定义如下： public static String toString(Object o, String nullDefault) { return (o != null) ? o.toString() : nullDefault; } 这种设计也很熟悉，想起了HashMap的getOrDefault方法。 public static int compare(T a, T b, Comparator c){...} 比较两个对象，并且需要指定比较器。定义如下： public static int compare(T a, T b, Comparator c) { return (a == b) ? 0 : c.compare(a, b); } 很好理解，不多说。 requireNonNull方法 requireNonNull == \"要求不是null\"，如果参数是null就抛出异常。重载了三个方法。以下两个方法的区别是：第二个参数可以传递抛出的异常的message。 public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } public static T requireNonNull(T obj, String message) { if (obj == null) throw new NullPointerException(message); return obj; } 另外一个requireNonNull方法是JDK1.8新加入的方法，定义如下： public static T requireNonNull(T obj, Supplier messageSupplier) { if (obj == null) throw new NullPointerException(messageSupplier.get()); return obj; } 同样还是抛出空指针异常，与requireNonNull(Object, String)方法不同，本方法允许将消息的创建延迟，直到空检查结束之后。虽然在非空例子中这可能会带来性能优势， 但是决定调用本方法时应该小心，创建message supplier的开销低于直接创建字符串消息。　　 public static boolean isNull(Object obj){...} 判断一个对象是不是null，实现非常简单了不贴了。这个是JDK1.8的方法，被用到了JDK1.8函数式编程包中java.util.function.Predicate类的实现。 注意这个类提供的所有可用方法都是静态方法，毕竟是工具类么。这些方法有什么作用呢？一方面是在一些方面代替了Object对象的一些方法，避免了产生空指针异常的可能。另外它提供的对于null值检查的几种方法，广泛用于参数合法性校验。可以直接用，也可以再进行一层的封装，其成果仍旧是一工具类，比如StringUtil。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-19 23:27:53 "},"源码解读/java.util/Comparator.html":{"url":"源码解读/java.util/Comparator.html","title":"Comparator","keywords":"","body":"Comparator Java8 中提供的函数式接口比较器，其中的抽象方法为int compare(T t, T t)和boolean equals(Object object)。 结构如下： int compare(T o1, T o2); 比较两个参数，并返回正数、0和负数，分别代表大于，等于和小于。在Java8之间，经典的比较器是这么写的。 Comparator byName = new Comparator(){ @Override int compare(Developer o1, Developer o2){ return o1.getName().compareTo(o2.getName()); } } 1.8之后，上面的过程就可以精简很多： Comparator comparator = (Developer o1, Developer o2) -> o1.getName().compareTo(o2.getName()); boolean equals(Object obj); 用来判断对象是否相等。 正序逆序自然顺序 提供了几个静态方法来返回正序、逆序和自然序，其本质还是调用Collectors中的正序、逆序和自然顺序。 // 非静态方法，逆序 default Comparator reversed() { return Collections.reverseOrder(this); } // 静态方法， 逆序 public static > Comparator reverseOrder() { return Collections.reverseOrder(); } // 静态方法，自然序 public static > Comparator naturalOrder() { return (Comparator) Comparators.NaturalOrderComparator.INSTANCE; } null 值处理 提供了null值在排序中的特殊处理方法 // null 值最后会在排序的最前面 public static Comparator nullsFirst(Comparator comparator) { return new Comparators.NullComparator<>(true, comparator); } // null 值最后会在排序的最后面 public static Comparator nullsLast(Comparator comparator) { return new Comparators.NullComparator<>(false, comparator); } 比较器复合 thenComparing和comparingXXX方法提供了链式操作的契机。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 22:38:17 "},"源码解读/java.util/Optional.html":{"url":"源码解读/java.util/Optional.html","title":"Optional","keywords":"","body":"Optional Java8中引入这个类的作用就是为了解决NPE问题，可以说是非常有用了。 注意，这是一个类，而不是一个接口。 public final class Optional 类声明，被final修饰，不能被继承和修改。 构造方法 重载了两个构造方法，并且都是私有的。 private Optional() { this.value = null; } private Optional(T value) { this.value = Objects.requireNonNull(value); } 其中的value为该类的私有属性private final T value;，同样被final修饰，只能赋值一次。 构造方法是私有的，我们如何取得Optional的对象呢？接着往下读。 public static Optional empty() {..} 用来获取一个空的Optional对象，定义如下： public static Optional empty() { @SuppressWarnings(\"unchecked\") Optional t = (Optional) EMPTY; return t; } private static final Optional EMPTY = new Optional<>(); 可见，该方法返回的是在类加载之初就创建的静态常量EMPTY，此时value的值为null。 public static Optional of(T value){..} 这个方法用来获取指定value的Optional对象。 public static Optional of(T value) { return new Optional<>(value); } 可见，这个方法调用的是私有的构造方法，而这个构造方法中又调用了Objects.requireNonNull方法。如果此时参数value=null，则会抛出NPE。 所以至此我们大概也明白了，empty方法是专门用来获取value=null的Optional对象，而of是专门用来获取非null的指定value的Optional对象。 public static Optional ofNullable(T value) {..} 上面的of方法在参数为null的时候会抛出NPE，ofNullable允许参数为null。实际上，底层分别调用了empty和of方法。 public static Optional ofNullable(T value) { return value == null ? empty() : of(value); } public T get() {..} 用来获取非null的value值，如果value本身为空就会抛出NPE。 public T get() { if (value == null) { throw new NoSuchElementException(\"No value present\"); } return value; } public boolean isPresent() {..} 查看value是否存在，“存在”的含义就是“是否为null”。 public boolean isPresent() { return value != null; } public void ifPresent(Consumer consumer) {..} 这就是我们经常用到的方法了，只有当value存在的时候才进行数据消费，所以不会抛出异常。 public void ifPresent(Consumer consumer) { if (value != null) consumer.accept(value); } public Optional filter(Predicate predicate){..} 该方法对于Optional进行过滤，只有当value满足非null且满足某种断言时候，才返回自己本身，否则将返回空Optional。 public Optional filter(Predicate predicate) { Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty(); } public Optional map(Function mapper) {..} 和 public Optional flatMap(Function> mapper){..} 当value存在时，对齐进行某种处理，返回Optional对象，其value值与函数式接口处理结果有关。 public Optional map(Function mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Optional.ofNullable(mapper.apply(value)); } } public Optional flatMap(Function> mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Objects.requireNonNull(mapper.apply(value)); } } 这里需要注意下map和flatMap两者参数的不同，前者需要的参数是函数描述符为(T -> R)的函数型接口，而后者需要的是函数描述符为(T -> Optional)的函数型接口。 public T orElse(T other) {..} 当value为null的时候允许指定参数进行替换。 public T orElse(T other) { return value != null ? value : other; } public T orElseGet(Supplier other) {..} 当value为null的时候，指定其他get方法获取到value值。 public T orElseGet(Supplier other) { return value != null ? value : other.get(); } public T orElseThrow(Supplier exceptionSupplier) throws X {..} 当value值为null的时候允许抛出指定的异常。 public T orElseThrow(Supplier exceptionSupplier) throws X { if (value != null) { return value; } else { throw exceptionSupplier.get(); } public boolean equals(Object obj) {..} 判断两个Optional是否相等。 @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (!(obj instanceof Optional)) { return false; } Optional other = (Optional) obj; return Objects.equals(value, other.value); } 总结 说了这么多的方法，有几个关键的地方总结一下： 创建Optional： 通过使用empty、of和ofNullable分别创建指定空，指定非空value和value任意的Optional对象。 使用Optional： 常使用方法ifPresent来避免NPE。例如：User user = new User(\"aaa@mail.com\"); Optional opt = Optional.of(user); opt.ifPresent( u -> assertEquals(user.getEmail(), u.getEmail())); 上面这段代码，只有当u存在，即 u!= null的时候，后面的代码才会执行，也就避免了由于u为null造成的NPE问题。 返回默认值： 使用方法orElse或orElseGet方法来返回默认值：User result = Optional.ofNullable(user).orElseGet( () -> user2); 上面这段代码，当user为null的时候，将返回user2作为替换。 orElse()和orElseGet()方法还存在差异，具体实验如下： 首先看下Optional为空时候两者的行为：@Test public void givenEmptyValue_whenCompare_thenOk() { User user = null logger.debug(\"Using orElse\"); User result = Optional.ofNullable(user).orElse(createNewUser()); logger.debug(\"Using orElseGet\"); User result2 = Optional.ofNullable(user).orElseGet(() -> createNewUser()); } private User createNewUser() { logger.debug(\"Creating New User\"); return new User(\"extra@gmail.com\", \"1234\"); } 以上代码运行后都会调用createNewUser方法并创建一个对象，输出结果如下：Using orElse Creating New User Using orElseGet Creating New User 可以看到，当对象为null的时候，orElse和orElseGet并无不同。 下面测试当Optional不为空时候的情况：@Test public void givenPresentValue_whenCompare_thenOk() { User user = new User(\"john@gmail.com\", \"1234\"); logger.info(\"Using orElse\"); User result = Optional.ofNullable(user).orElse(createNewUser()); logger.info(\"Using orElseGet\"); User result2 = Optional.ofNullable(user).orElseGet(() -> createNewUser()); } 发现打印结果如下：Using orElse Creating New User Using orElseGet 在这个示例中，Optional对象包含非null值，两个方法都会返回这个值，只是orElse仍旧还会创建对象，与之相关，orElseGet方法就不会再创建对象。 所以基于性能的考虑，当方法调用比较密集的时候，比如Web服务或查询数据，我们最好还是使用orElseGet方法比较好。 抛出异常： 使用orElseThrow来抛出默认异常，例如：@Test(expected = IllegalArgumentException.class) public void whenThrowException_thenOk() { User result = Optional.ofNullable(user) .orElseThrow( () -> new IllegalArgumentException()); } 以上，当user为null的时候就会抛出IllegalArgumentException， 这样我们就避免单调地只抛出NPE了。 转换值： 方法map、flatMap和filter是用来转化值的，前两者将map的结果包装成一个新的Optional，最后一个则断言Optional能够通过某种测试。 下面是一个map方法的例子： @Test public void whenMap_thenOk() { User user = new User(\"anna@gmail.com\", \"1234\"); String email = Optional.ofNullable(user) .map(u -> u.getEmail()).orElse(\"default@gmail.com\"); assertEquals(email, user.getEmail()); } 上面的例子中，map的执行结果将被包装成一个Optional，然后进行接下来的链式调用orElse。对于flatMap来说，要特别注意函数描述符为(T -> Optional)，所以我们可以给User添加一个方法，用来返回Optional： public class User { private String position; public Optional getPosition() { return Optional.ofNullable(position); } //... } 既然 getter方法返回 String 值的 Optional，你可以在对 User 的 Optional 对象调用 flatMap() 时，用它作为参数。其返回的值是解除包装的 String 值： @Test public void whenFlatMap_thenOk() { User user = new User(\"anna@gmail.com\", \"1234\"); user.setPosition(\"Developer\"); String position = Optional.ofNullable(user) .flatMap(u -> u.getPosition()).orElse(\"default\"); assertEquals(position, user.getPosition().get()); } filter方法比较简单，就是用来过滤对象属性，比较简单，下面是一个根据邮箱验证接受或拒绝用户的示例： @Test public void whenFilter_thenOk() { User user = new User(\"anna@gmail.com\", \"1234\"); Optional result = Optional.ofNullable(user) .filter(u -> u.getEmail() != null && u.getEmail().contains(\"@\")); assertTrue(result.isPresent()); } 综合示例 Optional的使用能够避免NPE异常且让代码变得优雅。对于下面这样一段原始的代码： String isocode = user.getAddress().getCountry().getIsocode().toUpperCase(); 如果其中任何一个执行结果是null，那么这段代码都将抛出NPE异常。为了安全，原始而落后的写法是： if (user != null) { Address address = user.getAddress(); if (address != null) { Country country = address.getCountry(); if (country != null) { String isocode = country.getIsocode(); if (isocode != null) { isocode = isocode.toUpperCase(); } } } } 这段代码写得太“脏”了，难以维护，所以我们可以使用Optional对其进行维护，首先要重构类，使得get方法返回Optional对象： public class User { private Address address; public Optional getAddress() { return Optional.ofNullable(address); } // ... } public class Address { private Country country; public Optional getCountry() { return Optional.ofNullable(country); } // ... } 这样就能删除null的检查，全部替换为Optional： String result = Optional.ofNullable(user) .flatMap(User::getAddress) .flatMap(Address::getCountry) .map(Country::getIsocode) .orElse(\"default\"); 参考： 理解、学习与使用 JAVA 中的 OPTIONAL Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 22:31:27 "},"源码解读/java.util/java.util.regex/java.util.regex.html":{"url":"源码解读/java.util/java.util.regex/java.util.regex.html","title":"java.util.regex","keywords":"","body":"java.util.regex java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。 它主要包括两个类：Pattern和Matcher 。 一个Pattern是一个正则表达式经编译后的表现模式，一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL（还没学过……）的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 11:32:10 "},"源码解读/java.util/java.util.regex/Pattern.html":{"url":"源码解读/java.util/java.util.regex/Pattern.html","title":"Pattern","keywords":"","body":"Pattern Pattern是一个正则表达式经过编译后的表现模式。该类的内容有很多，暂时不纠细节，了解常用的方法即可。 Pattern是一个终类，并且构造方法是私有的。 compile 这个方法将给定的正则表达式编译并赋予给Pattern类。可以指定正则表达式和flag。 public static Pattern compile(String regex) { return new Pattern(regex, 0); } public static Pattern compile(String regex, int flags) { return new Pattern(regex, flags); } private Pattern(String p, int f) { pattern = p; flags = f; // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present if ((flags & UNICODE_CHARACTER_CLASS) != 0) flags |= UNICODE_CASE; // Reset group index count capturingGroupCount = 1; localCount = 0; if (pattern.length() > 0) { compile(); } else { root = new Start(lastAccept); matchRoot = lastAccept; } } flag具体是什么含义还没有弄明白，这个参数的取值可以是CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ，但是一般不常用。 public Matcher matcher(CharSequence input) {...} 该方法用来生成一个给定命名的Matcher对象。 public Matcher matcher(CharSequence input) { if (!compiled) { synchronized(this) { if (!compiled) compile(); } } Matcher m = new Matcher(this, input); return m; } 所以Pattern的使用套路经常是： String str = \"Hello World\"; Pattern pattern = Pattern.compile(\"^\\S$\"); Matcher matcher = pattern.matcher(str); 然后接下来真正匹配的工作就交给Matcher类了。 public static boolean matches(String regex, CharSequence input) {...} 编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况，也就是只进行一次匹配工作，因为这种情况下并不需要生成一个Matcher实例。 public static boolean matches(String regex, CharSequence input) { Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches(); } 这个方法的效果等同于： boolean res = Pattern.compile(regex).matcher(input).matches(); split方法 这个方法将目标字符串按照Pattern里所包含的正则表达式为模进行分割。效果类似于String的split方法： public String[] split(CharSequence input, int limit) {...} public String[] split(CharSequence input) {...} 其中limit参数的含义与String.split中的参数一致，下面是一个例子： import java.util.regex.*; public class Replacement { public static void main(String[] args) throws Exception { // 生成一个Pattern,同时编译一个正则表达式 Pattern p = Pattern.compile(\"[/]+\"); // 用Pattern的split()方法把字符串按\"/\"分割 String[] result = p.split(\"Kevin has seen《LEON》seveal times,because it is a good film.\" + \"/ 凯文已经看过《这个杀手不太冷》几次了，因为它是一部\" + \"好电影。/名词:凯文。\"); for (int i = 0; i 程序的输出结果为： Kevin has seen《LEON》seveal times,because it is a good film. 凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。 名词:凯文。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 11:51:24 "},"源码解读/java.util/java.util.regex/Matcher.html":{"url":"源码解读/java.util/java.util.regex/Matcher.html","title":"Matcher","keywords":"","body":"Matcher Matcher类是正则表达式的匹配器类。定义如下： public final class Matcher implements MatchResult 类声明，被final修饰，说明不可被继承。 构造方法 Matcher类的两个构造方法都是protected的，在Pattern中被调用，我们需要通过Pattern的静态方法compile来创建Matcher实例： Matcher() { } Matcher(Pattern parent, CharSequence text) { this.parentPattern = parent; this.text = text; // Allocate state storage int parentGroupCount = Math.max(parent.capturingGroupCount, 10); groups = new int[parentGroupCount * 2]; locals = new int[parent.localCount]; // Put fields into initial states reset(); } 这里有几个变量的含义需要说明一下： // 创建此对象的模式匹配。 Pattern parentPattern; // 匹配的目的字符串。 CharSequence text; // 组使用的存储。如果在匹配过程中跳过一个组，它们可能包含无效的值。存储的是当前匹配的各捕获组的first和last信息。 // groups[0]存储的是组零的first，groups[1]存储的是组零的last，groups[2]存储的是组1的first，groups[3]存储的是组1的last int[] groups; int[] locals; 最后，调用reset进行复位，将类的一些变量进行赋值，最终各个变量的结果如下： public Pattern pattern() {...} 返回parentPattern，即构造器传入的Pattern对象。 public Pattern pattern() { return parentPattern; } public int groupCount(){...} 返回匹配器中的捕获组个数。零组表示不在捕获组中，不计入个数 public int groupCount() { return parentPattern.capturingGroupCount - 1; } 示例： Pattern p = Pattern.compile(\"(\\\\w+)%(\\\\d+)\"); Matcher m = p.matcher(\"ab%12-cd%34\"); System.out.println(m.groupCount());// 2 start 和 end 重载了三种start方法和end方法，含义一一对应，这里只解释start方法。 // 返回当前匹配的子串的第一个字符在目标字符串中的索引位置 。 public int start() { if (first groupCount()) throw new IndexOutOfBoundsException(\"No group \" + group); return groups[group * 2]; } // 返回当前指定的命名捕获组中的子串的一个字符在目标字符串中的索引位置 public int start(String name) { return groups[getMatchedGroupIndex(name) * 2]; } public boolean find() {...} 在目标字符串里查找下一个匹配子串。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。 public boolean find() { int nextSearchIndex = last; if (nextSearchIndex == first) nextSearchIndex++; // If next search starts before region, start it at region if (nextSearchIndex to) { for (int i = 0; i 使用示例： Pattern p = Pattern.compile(\"(\\\\w+)%(\\\\d+)\"); Matcher m = p.matcher(\"ab%12-cd%34\"); while (m.find()) { System.out.println(\"group():\" + m.group()); System.out.println(\"start():\" + m.start()); System.out.println(\"end():\" + m.end()); System.out.println(\"group(1):\" + m.group(1)); System.out.println(\"start(1):\" + m.start(1)); System.out.println(\"end(1):\" + m.end(1)); System.out.println(\"group(2):\" + m.group(2)); System.out.println(\"start(2):\" + m.start(2)); System.out.println(\"end(2):\" + m.end(2)); System.out.println(); } 执行结果为： group():ab%12 start():0 end():5 group(1):ab start(1):0 end(1):2 group(2):12 start(2):3 end(2):5 group():cd%34 start():6 end():11 group(1):cd start(1):6 end(1):8 group(2):34 start(2):9 end(2):11 find()方法匹配了两个子串：ab%12和cd%34；每个子串有2组。 group 返回当前查找而获得的与组匹配的所有子串内容。 // 可知group()实际调用了group(int group)方法，参数group为0。组零表示整个模式 public String group() { return group(0); } // 返回当前查找而获得的与组匹配的所有子串内容 public String group(int group) { if (first groupCount()) throw new IndexOutOfBoundsException(\"No group \" + group); if ((groups[group*2] == -1) || (groups[group*2+1] == -1)) return null; return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString(); } // 返回当前指定名称的捕获组而获得的与组匹配的所有子串内容 public String group(String name) { int group = getMatchedGroupIndex(name); if ((groups[group*2] == -1) || (groups[group*2+1] == -1)) return null; return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString(); } 参考 java之Matcher类详解 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-15 14:10:23 "},"源码解读/java.util/java.util.Stream/java.util.stream.html":{"url":"源码解读/java.util/java.util.Stream/java.util.stream.html","title":"java.util.stream","keywords":"","body":"java.util.Stream Java8新特性之一——流式计算非常有用，能够以声明的方式处理数据集合。java.util.Stream中包含了流式计算的所有类。主要包含以下几个主要的类和接口： 主要的接口： 接口 功能 Item One Item Two 主要的类： | 类名 | 功能 | | :------------- | :------------- | | Item One | Item Two | Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-10 17:53:04 "},"源码解读/java.util/java.util.Stream/Stream.html":{"url":"源码解读/java.util/java.util.Stream/Stream.html","title":"Stream","keywords":"","body":"Stream 这个真的是Java8中最重要的一个设计了——流计算。Stream是流式计算中最基本的接口，结构如下： 注意看这些方法的返回值，有一些返回Stream对象的方法我们可以构成链式计算。 public interface Stream extends BaseStream> 类声明，其中BaseStream的接口声明如下： public interface BaseStream> extends AutoCloseable 可以看到，该接口继承了AutoCloseable接口，说明流可以自动关闭。话是这么说，但是事实上，所有的流都不需要关闭，通常，只有源为IO通道的流（如文件返回行（路径、字符集））将需要关闭，大多数流都由集合、数组或生成函数支持，这些函数不需要特殊的资源管理。（如果流确实需要关闭，则可以在try-with-resource语句中声明为资源）。 筛选操作 Stream filter(Predicate predicate); // 谓词筛选 Stream distinct(); //去重 Stream limit(long maxSize); // 截断，具有短路性， 原理是构建了一个指定大小的流，而不用对整个流做处理，这种也行能将无限流整合成有限流 Stream skip(long n); // 跳过，与limit互补，如果元素不够跳过的个数，则返回空流 其中distinct + toList操作可以使用toSet操作来代替。 必要的distinct操作可以减轻后序流操作的开销。 映射操作 切片可以理解为投影操作，即从众多的属性中摘取其中的一些特性。 Stream map(Function mapper); // 对流中的每个元素应用函数 IntStream mapToInt(ToIntFunction mapper); LongStream mapToLong(ToLongFunction mapper); DoubleStream mapToDouble(ToDoubleFunction mapper); Stream flatMap(Function> mapper); // 将各个流扁平化成单个流 IntStream flatMapToInt(Function mapper); LongStream flatMapToLong(Function mapper); DoubleStream flatMapToDouble(Function mapper); 其中flatMap的作用是将各个流扁平化成单个流，比如要提取给定单词列表[\"Hello\",\"World\"]，返回列表[\"H\",\"e\",\"l\", \"o\",\"W\",\"r\",\"d\"]，怎么办？ 首先可能想到的是使用map + Arrays.stream()方法，后者的作用是将数组转化为流，所以有了以下代码： menu.stream() .map(Dish::getName) .map(word -> word.split(\"\")) .map(Arrays::stream) // 将数组转为流 .distinct() .collect(toList()); 然而这是错误的，这个方法的返回值是List而不是List。 flatMap能解决这个问题： return menu.stream() .map(Dish::getName) .map(word -> word.split(\"\")) .flatMap(Arrays::stream) // 将各个流扁平化成单个流 .distinct() .collect(toList()); 使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来， 即扁平化为一个流。 另外，map、filter等是可以嵌套使用的，如下： /** * 只返回总和被3整数的数对 * @return */ private static List getFilterPairsList(){ List numbers1 = Arrays.asList(1, 2, 3); List numbers2 = Arrays.asList(3, 4); return numbers1.stream() .flatMap(i -> numbers2.stream() .filter(j -> (i + j) % 3 == 0) .map(j -> new int[]{i, j})) .collect(toList()); } 查找和匹配 以下运算都使用了短路运算 boolean anyMatch(Predicate predicate); // 检查谓词是否至少匹配一个元素 boolean allMatch(Predicate predicate); //检查谓词是否匹配所有元素 boolean noneMatch(Predicate predicate); // / 检查谓词是否全都匹配一个元素 Optional findFirst(); // 找到第一个 Optional findAny(); // 找到任意一个 findAny和findFirst其实有时候都能实现同一个功能，但是findFirst在并行上限制很多，所以尽可能还是用findAny。 规约 reduce操作使得每个元素按照流水线的方式进行计算。 T reduce(T identity, BinaryOperator accumulator); // identity ： 初始值, accumulator： 累加器 Optional reduce(BinaryOperator accumulator); // accumulator: 累加器， 注意返回值是Optional类型，当流中没有一个元素时候，由于没有初始值，所以无结果，所以结果会被包含在Optional中 U reduce(U identity, BiFunction accumulator, BinaryOperator combiner); 下面是使用 reduce的一些例子： // 求和 private static int reduceTest(){ int[] numbers = new int[]{1, 2, 3}; return Arrays.stream(numbers).reduce(0, Integer::sum) } // 得到最大值 private static OptionalInt reduceMax(){ int[] numbers = new int[]{1, 2, 3}; return Arrays.stream(numbers).reduce(Integer::max); } 分支合并框架 流操作的状态 有状态的操作： 后一次的操作需要知道前一次操作的结果，比如sorted、limit、skip、distinct、reduce。 无状态操作： 操作彼此无关，如filter、map 流操作的状态如下： Stream peek(Consumer action); 这个方法会产生一个包含所有元素的新流，接受Consumer实例。注意，这个方法产生的是“流”，所以是中间操作，应用如下： Stream.of(\"one\", \"two\", \"three\", \"four\") .filter(e -> e.length() > 3) .peek(e -> System.out.println(\"Filtered value: \" + e)) .map(String::toUpperCase) .peek(e -> System.out.println(\"Mapped value: \" + e)) .collect(Collectors.toList()); 程序将会输出： Filtered value: three Mapped value: THREE Filtered value: four Mapped value: FOUR 这个方法常常应用在debug方法中，用来查询流中间的内容。注意与forEach方法作区分，forEach方法是终端操作。 原始类型流特化 为了减少装箱拆箱地带来成本，Java8引入了三个原始的比特流：IntStream，DoubleStream和LongStream，能够分别将流中的元素转化为int、long和double。 这些原始流中具有特定的对于数字计算有意义的常用的方法，比如sum、avg、max、min等。 流转换的方法有三个： IntStream mapToInt(ToIntFunction mapper); LongStream mapToLong(ToLongFunction mapper); DoubleStream mapToDouble(ToDoubleFunction mapper); 相反，将数值流转为对象流的方法是数值流中的boxed方法。基本数据流的特性可以参考具体该接口的源码解读。 构建流 Stream提供了创建流的几种方法： // 创建空流 public static Stream empty() { return StreamSupport.stream(Spliterators.emptySpliterator(), false); } // 由值创建流 public static Stream of(T t) { return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false); } @SafeVarargs @SuppressWarnings(\"varargs\") // Creating a stream from an array is safe public static Stream of(T... values) { return Arrays.stream(values); } // 生成无限流 public static Stream iterate(final T seed, final UnaryOperator f) { Objects.requireNonNull(f); final Iterator iterator = new Iterator() { @SuppressWarnings(\"unchecked\") T t = (T) Streams.NONE; @Override public boolean hasNext() { return true; } @Override public T next() { return t = (t == Streams.NONE) ? seed : f.apply(t); } }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize( iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), false); } public static Stream generate(Supplier s) { Objects.requireNonNull(s); return StreamSupport.stream( new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false); } 常用of方法来创建流，如 Stream stream = Stream.of(\"Java8\", \"Lambda\", \"In\", \"Action\"); 另外，源码中看到，还能通过数组来创建流，因为Arrays类提供多个重载的stream方法，可以生成基本数据流和对象流： int[] numbers = {2, 3, 5, 7, 11, 13}; int sum = Arrays.stream(numbers).sum(); 另外，NIO中Files也提供了文件流的创建方法lines，这里先略过。 Stream还提供了创建无限流的方法：Stream.iterator和Stream.generate。从集合创建出来的流是有固定大小的，与之相对的“无限流”没有固定的大小，可以无穷无尽地计算下去，通常使用limit进行截断。 流可以是无界的，这是流和集合之间的区别。 其中iterator是依次生成的，我们可以根据这个特性来生成斐波那契数列： Stream.iterator(new int[]{0, 1}, t -> new int[]{t[1], t[0] + t[1]}) .limit(20) .map(t -> t[0]) .forEach(System.out::println); 而generate不是依次对每个新生成的值应用函数的。它接受一个Supplier类型的Lambda提供新的值。 比如生成5个任意的0~1之间的双精度浮点数，那么就可以这么做： Stream.generate(Math::random) .limit(5) .forEach(System.out::println) 计数 终端操作，计算流中元素的个数。 long count(); 排序 中间操作，且是有状态的操作： Stream sorted(); Stream sorted(Comparator var1); 注意第二个重载方法的参数为Comparator实例，可以自己实现，也可以使用Comparator接口提供的一些已有的排序，例如Comparator.naturalOrder、Comparator.reverseOrder。 高级归约 流处理的目的是为了完成各种数据提取、转换和归约，下面的方法就是流归约的方法，是终端操作： Object[] toArray(); A[] toArray(IntFunction var1); R collect(Supplier var1, BiConsumer var2, BiConsumer var3); R collect(Collector var1); 其中toArray方法能将流转为数组，collect的两个重载方法非常重要，一般来说，参数定义了归约操作的结果，例如Collector.toList就是将流转为线性组，另外还能进行分组等操作，具体参考Collectors。 builder static Stream.Builder builder() { return new StreamBuilderImpl(); } 流连接 static Stream concat(Stream var0, Stream var1) { Objects.requireNonNull(var0); Objects.requireNonNull(var1); java.util.stream.Streams.ConcatSpliterator.OfRef var2 = new java.util.stream.Streams.ConcatSpliterator.OfRef(var0.spliterator(), var1.spliterator()); Stream var3 = StreamSupport.stream(var2, var0.isParallel() || var1.isParallel()); return (Stream)var3.onClose(Streams.composedClose(var0, var1)); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-14 21:56:26 "},"源码解读/java.util/java.util.Stream/IntStream.html":{"url":"源码解读/java.util/java.util.Stream/IntStream.html","title":"IntStream/LongStream/DoubleStream","keywords":"","body":"IntStream/LongStream/DoubleStream 为了避免基本数据类型装箱开销而提供的基本类型流，类似的还有DoubleStream和LongStream。三者的结构差不过，所以这里以IntStream为例： 可以看到，其中很多的方法与Stream是一样的（那是因为两者都继承了BaseStream接口），所以这里单独看下基本数据流特有的几个方法。 整数有很多统计的场景，IntStream为我们提供了这些的接口方法： 描述 方法 求和 int sum() 计数 long count(); 求最小值 OptionalInt min() 求最大值 OptionInt max() 求平均值 OptionalDouble average() 获取数据统计（最大、最小、平均、计数） IntSummaryStatistics summaryStatistics(); 另外，三种基本数据流之间也能相互转换 流转换 方法名 IntStream -> LongStream LongStream asLongStream(); IntStream -> DoubleStream DoubleStream asDoubleStream(); LongStream和DoubleStream中也有类似的方法，命名都是\"xxxStream\"。 Stream通过mapToXxx方法转换为基本数据流，而基本数据流通过boxed方法转换为Stream。 另外，IntStream和LongStream有两个特殊的静态方法方法，用来产生某范围内的整数序列。 public static IntStream range(int startInclusive, int endExclusive) { if (startInclusive >= endExclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false); } } public static IntStream rangeClosed(int startInclusive, int endInclusive) { if (startInclusive > endInclusive) { return empty(); } else { return StreamSupport.intStream( new Streams.RangeIntSpliterator(startInclusive, endInclusive, true), false); } } 两者的区别在于： range不包含结束值，而rangeClosed包含结束值。例如“生成一个从1到100的偶数流”，则可以这么做： IntStream evenStream = IntSteam.rangeClosed(1, 100) .filter(n -> n % 2 == 0); 下面是一个数据流的比较综合的例子：寻找100以内的勾股数，例如[3,4,5] 首先想到勾股数需要满足a * a + b * b = c * c ，其中a和b的范围是[1, 100]，所以首先可以想到： IntStream.rangeClosed(1, 100) .filter(b -> Math.sqrt(a * a + b * b) % 1 == 0) .mapToObj(b -> new int[]{a, b, (int)Math.sqrt(a * a + b * b)}) 那么a是如何生成呢？ Stream pythagoreanTruples = IntStream.rangeClosed(1, 100).boxed() .flapMap(a -> IntStream.rangeClosed(1, 100) .filter(b -> Math.sqrt(a * a + b * b) % 1 == 0) .mapToObj(b -> new int[]{a, b, (int)Math.sqrt(a * a + b * b)}) ); 至此，上面的代码就可以生成勾股数流了，但是上面并不是最好的方案，因为开发计算过程发生了两次，所以更好的方法如下： Stream pytghagoreanTruples2 = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -> IntStream.rangeClosed(1, 100)) .mapToObj(b -> new double[]{a, b, Math.sqrt(a * a + b * b)}) .filter(t -> t[2] % 1 == 0); 然后我们利用截断操作limit，就可以限定从生成的流中要放回多少组勾股数了： pytghagoreanTruples2.limit(5) .forEach(t -> System.out.println(t[0] + “,” + t[1] + \", \" + t[2])); Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-13 22:26:03 "},"源码解读/java.util/java.util.Stream/Collector.html":{"url":"源码解读/java.util/java.util.Stream/Collector.html","title":"Collector","keywords":"","body":"Collector 注意Collector、COllectors、Collection和Collections的区别 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-13 23:03:37 "},"源码解读/java.util/java.util.Stream/Collectors.html":{"url":"源码解读/java.util/java.util.Stream/Collectors.html","title":"Collectors","keywords":"","body":"Collectors 提供了流的终端操作，具体来讲，它接收的参数是将流中的元素累积到汇总结果的各种方式，我们称之为“收集器”。 预定义收集器包括将流元素归约和汇总到一个值。如下： toList / toSet / toCollection toList 将流中所有元素收集到List中 List menu = Menu.getMunus.stream().collect(Collectors.toList()); toSet 将流中的所有元素收集到Set中，删除重复项 Set menus = Menu.getMenus.stream().collect(Collectors.toSet()); toCollection 将流中所有元素收集到给定的供应源的集合中 ArrayList menu = Menu.getMenus.stream().collect(Collectors.ttoCollection(ArrayList::new)) 计算和统计 counting 计算流中元素的个数，和Strem.count()的功能一样，这个方法，将每个元素映射为1，然后调用了reduce方法进行求求和，源码如下： public static Collector counting() { return reducing(0L, e -> 1L, Long::sum); } 一个计算例子如下： Long count = Menu.getMenus.stream().collect(counting); summingInt / summingLong / summingDouble 对流中元素的一个整数属性求和 Integer count = Menu.getMenus.stream().collect(summingInt(Menu::getCalories)); averagingInt / averageingLong / averageingDouble 计算流中元素integer属性的平均值， Double averageing = Menu.getMenus.stream().collect(averagingInt(Menu::getCalories))； summarizingInt / summarizingLong / summarizingDouble 计算流中元素的统计特性（最大 / 最小 / 平均 / 计数 / 总和） IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories)); 打印结果： IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800} maxBy & minBy 一个包括了流中按照给定比较器选出的最大 / 小元素的optional，如果为空返回的是Optional.empty()。 Optional fattest = Menu.getMenus.stream().collect(maxBy(Menu::getCalories)); reduce 【广式归约汇总】 之前的所有方法都是reduce工厂方法定义的规约的一个特殊情况。所以reduce是归约的一般化，其作用是从一个作为累加器的初始值开始,利用binaryOperator与流中的元素逐个结合,从而将流归约为单个值。 例如： int count=Menu.getMenus.stream().collect(reducing(0,Menu::getCalories,Integer::sum)); 有三种重载： public static Collector reducing(U identity, Function mapper, BinaryOperator op) { return new CollectorImpl<>( boxSupplier(identity), (a, t) -> { a[0] = op.apply(a[0], mapper.apply(t)); }, (a, b) -> { a[0] = op.apply(a[0], b[0]); return a; }, a -> a[0], CH_NOID); } public static Collector> reducing(BinaryOperator op) { class OptionalBox implements Consumer { T value = null; boolean present = false; @Override public void accept(T t) { if (present) { value = op.apply(value, t); } else { value = t; present = true; } } } return new CollectorImpl>( OptionalBox::new, OptionalBox::accept, (a, b) -> { if (b.present) a.accept(b.value); return a; }, a -> Optional.ofNullable(a.value), CH_NOID); } public static Collector reducing(T identity, BinaryOperator op) { return new CollectorImpl<>( boxSupplier(identity), (a, t) -> { a[0] = op.apply(a[0], t); }, (a, b) -> { a[0] = op.apply(a[0], b[0]); return a; }, a -> a[0], CH_NOID); } 注意，无论哪种重载，reducing其中最重要的参数是BinaryOperator接口实例，这就说明这个方法必须接口两个相同类型的参数，然后返回同样类型的值。 groupingBy / groupingByConcurrent 分组操作，这是一个非常非常常用的操作。groupingBy方法有是三个重载： // 单级分类， 使用分类函数 public static Collector>> groupingBy(Function classifier) { return groupingBy(classifier, toList()); } // 用来进行多级分类 public static Collector> groupingBy(Function classifier, Collector downstream) { return groupingBy(classifier, HashMap::new, downstream); } public static > Collector groupingBy(Function classifier, Supplier mapFactory, Collector downstream) { Supplier downstreamSupplier = downstream.supplier(); BiConsumer downstreamAccumulator = downstream.accumulator(); BiConsumer, T> accumulator = (m, t) -> { K key = Objects.requireNonNull(classifier.apply(t), \"element cannot be mapped to a null key\"); A container = m.computeIfAbsent(key, k -> downstreamSupplier.get()); downstreamAccumulator.accept(container, t); }; BinaryOperator> merger = Collectors.>mapMerger(downstream.combiner()); @SuppressWarnings(\"unchecked\") Supplier> mangledFactory = (Supplier>) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(mangledFactory, accumulator, merger, CH_ID); } else { @SuppressWarnings(\"unchecked\") Function downstreamFinisher = (Function) downstream.finisher(); Function, M> finisher = intermediate -> { intermediate.replaceAll((k, v) -> downstreamFinisher.apply(v)); @SuppressWarnings(\"unchecked\") M castResult = (M) intermediate; return castResult; }; return new CollectorImpl<>(mangledFactory, accumulator, merger, finisher, CH_NOID); } } 这里的源码实现可以不用在意，但是一些常见的使用常见需要熟悉： 单级别分类: 利用单参数的groupingBy方法，这是上是groupingBy(f, toList())的简略写法。如需要将菜肴按照类型分类：Map> dishesByType = menu.stream().collect(groupingBy(Dish::getType)); 结果就是这样：{FISH=[prawns, salmon], OTHER=[french fries, rice, season fruit, pizza], MEAT=[pork, beef, chicken]} 多级分类 利用groupingBy的双参数重载方法，可以进行n级的分类，可以得到一个n级树形结构的n级Map。 /** * 二级分类 * RES: {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]}, FISH={DIET=[prawns], NORMAL=[salmon]}, OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}} * @param menu * @return */ private Map>> getByCaloricLevel(List menu){ return menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish -> { if (dish.getCalories() 分组统计 更多的时候，我们需要的不仅仅是原数据的分类，而是分类之后的统计。例如： /** * 按照子组收集数据 * RES: {FISH=Optional[salmon], OTHER=Optional[pizza], MEAT=Optional[pork]} * @param menu * @return */ private Map> getMostCaloricValueByType(List menu){ return menu.stream().collect( groupingBy(Dish::getType, maxBy(Comparator.comparingInt(Dish::getCalories))) ); } 分组转换 分组收集之后将元素进行转换 ```java /** 按子组收集数据，查找某个子组中热量最高的Dish RES: FISH=salmon, OTHER=pizza, MEAT=pork} @return */ private Map getMostCaloricByType(List menu){ return menu.stream().collect( groupingBy(Dish::getType, collectingAndThen( maxBy(Comparator.comparingInt(Dish::getCalories)), Optional::get)) ); } 5. groupingBy和mapping结合使用 ```java /** * groupingBy 和 mapping 收集器的结合 * 获取每类食物下的热量分布 * RES: {OTHER=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], FISH=[DIET, NORMAL]} * @param menu * @return */ private Map> getCaloricLevelByType(List menu){ // return menu.stream().collect( // groupingBy(Dish::getType, mapping( // dish -> { // if (dish.getCalories() { if (dish.getCalories() mapping 接受两个参数，一个函数对流中的元素进行变换，另外一个将变换的结果收集起来。 public static Collector mapping(Function mapper, Collector downstream) { BiConsumer downstreamAccumulator = downstream.accumulator(); return new CollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper.apply(t)), downstream.combiner(), downstream.finisher(), downstream.characteristics()); } partitioningBy 分区函数，这个的分区是指根据谓词进行分区，即非true即false。所以自然可以想到，partitioningBy的参数一定有Predicate接口实例。 public static Collector>> partitioningBy(Predicate predicate) { return partitioningBy(predicate, toList()); } public static Collector> partitioningBy(Predicate predicate, Collector downstream) { BiConsumer downstreamAccumulator = downstream.accumulator(); BiConsumer, T> accumulator = (result, t) -> downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t); BinaryOperator op = downstream.combiner(); BinaryOperator> merger = (left, right) -> new Partition<>(op.apply(left.forTrue, right.forTrue), op.apply(left.forFalse, right.forFalse)); Supplier> supplier = () -> new Partition<>(downstream.supplier().get(), downstream.supplier().get()); if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) { return new CollectorImpl<>(supplier, accumulator, merger, CH_ID); } else { Function, Map> finisher = par -> new Partition<>(downstream.finisher().apply(par.forTrue), downstream.finisher().apply(par.forFalse)); return new CollectorImpl<>(supplier, accumulator, merger, finisher, CH_NOID); } } 一个典型的应用例子是： /** * 判断一个数是不是质数 * @param candidate * @return */ private boolean isPrime(int candidate){ int candidateRoot = (int) Math.sqrt((double) candidate); return IntStream.rangeClosed(2, candidateRoot) .noneMatch(i -> candidate % i == 0); } /** * 将1~n的数划分为质数和非质数 * @param n * @return */ private Map> partitionPrimes(int n){ return IntStream.rangeClosed(2, n).boxed() .collect( partitioningBy(candidate -> isPrime(candidate)) ); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-19 23:19:25 "},"源码解读/java.util/java.util.Stream/StreamSupport.html":{"url":"源码解读/java.util/java.util.Stream/StreamSupport.html","title":"StreamSupport","keywords":"","body":"StreamSupport Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-12 13:52:51 "},"源码解读/java.util/java.util.function/java.util.function.html":{"url":"源码解读/java.util/java.util.function/java.util.function.html","title":"java.util.function","keywords":"","body":"java.util.function java8 开始Java支持函数式编程，在子包java.util.function中包含了很多内建的函数式接口，这些接口都增加了@FunctionalInterface注解，以便能使用在lambda上。下面列出了Java8中的内建函数式接口： 总的来说，Java8 中的函数式接口可以分为以下四种类型： 断言型接口——Predicate【T -> boolean】 获取判断的结果。基础接口为Predicate，接口抽象方法为boolean test(T t);，接受一个T对象，返回boolean，函数描述符为T -> boolean。 Predicate本身又提供了and、or和negative逻辑，利用这些逻辑，可以进行谓词复合。 BiPredict提供了两个参数的断言支持，接口抽象方法为boolean test(T, U);，接受两个对象，返回boolean，函数描述符为(T, U) -> boolean。同样提供了and、or和negative逻辑。 无论是Predicate还是BiPredict，都是对于类的操作，而对于基本数据类型来说，会存在自动装箱和拆箱的开销。为了避免这一开销，Java8专门提供了针对于基本数据类型的段言型接口。 与Predicate对应，Java8针对int、long和double提供了IntPredicate、LongPredicate和DoublePredict。注意，并非所有的基本数据类型都有断言型接口。 另外，Java8并没有开放针对双参数的基本数据类型的断言型接口。 Predicate用来作为判断条件，比较常见的使用常见是filter参数或if条件。 函数型接口——Function 【T -> R】 用来进行数据转换。基础接口为Function。接口抽象方法为R apply(T t)， 接受一个T类型对象，返回一个R类型对象，函数描述符为T -> R。 Function本身提供了一些接口方法，比如前置操作compose、后置操作andThen和本身操作identity，可以进行函数复合，构成一条流程水的操作。 BiFunction是两个参数版本的Function操作，抽象方法为R apply(T t, U u)，接受两个对象，返回一个R类型的对象，函数描述符为(T, U) -> R。另外，除了apply方法，它还剩下一个方法andThen，用来设定后置操作。 Java8同样了对于基本数据类型的支持。对应于Function，Java8 提供了对于int、long和double数据类型的支持和它们三者和对象之间的转换操作，各自的关系如下： 基于BiFunction，Java只提供了object到三种基本数据类型(int | long | double)之间的函数型接口，分别对应ToIntBiFunction、ToLongBiFunction和ToDoubleBiFunction。 特别的，对于同一类型的数据转换，Java8中有专门定制的两个类：UnaryOperator和BinaryOperator，前者的函数描述符为T -> T，后者的函数描述符为(T, T) -> T。后者提供了minBy和maxBy方法，用来比较数字或字符串的大小。 消费型接口——Consumer【T -> ()】 用来进行数据消费。基础接口为Consumer。接口抽象方法为void accept(T t)，接受一个T类型对象，无返回，函数描述符为T -> ()。 Consumer本身还提供了 andThen方法，用来定义后置操作。 BiConsumer是双参数版本的Consumer，函数描述符为(T t, U u) -> void。 基于Consumer，Java8提供了对于int、long和double三种类型的数据消费的支持，分别对应IntConsumer、LongConsumer和DoubleConsumer。 基于BiConsumer，Java8提供了对于int、long和double三种类型的数据消费的支持，分别对应ObjIntConsumer、ObjLongConsumer和ObjDoubleConsumer。这三个类中的apply都接受一个对象和一个基本数据类型参数，无返回值。 供应型接口——Supplier【() -> T】 用于产生所需。基础接口为Supplier，接口抽象方法为T get()，无参数，返回T类型独享，函数描述符为() -> T。 Supplier接口本身无其他方法。 Java8提供了对于基本数据类型boolean、int、long和double的支持，分别对应类BooleanSupplier、IntSupplier、LongSupplier和DoubleSupplier。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 22:41:22 "},"源码解读/java.util/java.util.function/Predicate.html":{"url":"源码解读/java.util/java.util.function/Predicate.html","title":"Predicate","keywords":"","body":"Predicate 函数式接口。唯一的抽象方法是：boolean test(T t)，所以函数描述符是T -> boolean。主要用来进行过滤。 除此之外，基于Java 8 接口可以有默认方法的特性，Predicate接口含有其他的方法，具体接口结构如下： boolean test(T t); 抽象接口，测试参数是否符合某种测试条件。 default Predicate and(Predicate other){..} default Predicate and(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } 提供了逻辑与的Predicate判断。注意返回的是Predicate类型对象，所以return语句的断句是这样的(t) -> (test(t) && other.test(t))，由于该特性，所以可以进行链式运算。 例如： Predicate startWithJ = name -> name.startsWith(\"J\"); Predicate lengthLimit4 = name -> name.length() endWithE = name -> name.endsWith(\"e\"); List names = new ArrayList<>(Arrays.asList(\"James\", \"Bao\", \"Jane\", \"You\")); names = names.stream().filter(startWithJ.and(lengthLimit4).and(endWithE)).collect(Collectors.toList()); System.out.println(Arrays.toString(names.toArray(new String[names.size()]))); // [Jane] 同样的道理，Predicate还提供了对于or逻辑、xor逻辑和not逻辑的运算。 default Predicate or(Predicate other){..} default Predicate or(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } default Predicate negate(){..} default Predicate negate(){ return (t) -> !test(); } static Predicate isEqual(Object targetRef) {...} 返回一个判断对象是否相等的Predicate接口对象。 static Predicate isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-06 22:46:16 "},"源码解读/java.util/java.util.function/IntPredicate.html":{"url":"源码解读/java.util/java.util.function/IntPredicate.html","title":"IntPredicate/LongPredict/DoublePredict","keywords":"","body":"IntPredicate IntPredicate是为了避免基本数据类型装箱拆箱的开销而单独创建的针对基本数据类型int的函数式接口，其接口与Predicate没有两样。其结构如下： 与IntPredicate类似的还是有LongPredict和DoublePredict， 注意并不是每一种基本数据类型都有对应的Predicate的。 四个方法的内容不做具体展开，可以参考Predicate源码解读。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:13:30 "},"源码解读/java.util/java.util.function/BiPredict.html":{"url":"源码解读/java.util/java.util.function/BiPredict.html","title":"BiPredict","keywords":"","body":"BiPredict Predicate的函数描述符是T -> boolean， 即对一个参数做出的判断。而BiPredict接口两个参数，函数描述符是(T, U) -> boolean。同样具有and、negate和or的逻辑。具体如下： 具体方法及意义可以参考Predicate。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 10:54:25 "},"源码解读/java.util/java.util.function/Consumer.html":{"url":"源码解读/java.util/java.util.function/Consumer.html","title":"Consumer","keywords":"","body":"Consumer 函数式接口。唯一的接口是void accept(T t)，所以Consumer的函数描述符是T -> void。主要用来进行遍历处理。 具体的结果是： void accept(T t); 抽象方法。主要用来进行遍历处理。 default Consumer andThen(Consumer after) {..} 链式处理。 default Consumer andThen(Consumer after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-06 22:47:53 "},"源码解读/java.util/java.util.function/IntConsumer.html":{"url":"源码解读/java.util/java.util.function/IntConsumer.html","title":"IntConsumer/LongConsumer/DoubleConsumer","keywords":"","body":"IntConsumer 与IntPredicate的存在类似，IntConsumer也是为了避免基本数据类型的装箱拆箱操作而创建的函数式接口。结构如下： 与IntConsumer类似的还有LongConsumer和DoubleConsumer，注意，并不是每一种基本数据类型都有对应的Consumer的。 其接口方法参考Consumer的源码解析。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:14:34 "},"源码解读/java.util/java.util.function/BiConsumer.html":{"url":"源码解读/java.util/java.util.function/BiConsumer.html","title":"BiConsumer","keywords":"","body":"BiConsumer Consumer的函数描述符是T -> void，而 BiConsumer的函数描述符是(T, U) -> void。 具体方法可以类比Consumer。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:00:46 "},"源码解读/java.util/java.util.function/ObjIntConsumer.html":{"url":"源码解读/java.util/java.util.function/ObjIntConsumer.html","title":"ObjIntConsumer/ObjLongConsumer/object","keywords":"","body":"ObjIntConsumer/ObjLongConsumer/object 基于BiConsumer，提供对于int、long和double三种基本数据类型的支持。以ObjIntConsumer为例： @FunctionalInterface public interface ObjDoubleConsumer { /** * Performs this operation on the given arguments. * * @param t the first input argument * @param value the second input argument */ void accept(T t, double value); } accept接受两个参数： T类型对象和double类型数据，无返回值。函数描述符为(T, double) -> void。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 15:00:05 "},"源码解读/java.util/java.util.function/Function.html":{"url":"源码解读/java.util/java.util.function/Function.html","title":"Function","keywords":"","body":"Function Function代表的是接口一个参数，经过处理后产生另外一个类型结果的函数，函数描述符是T -> R， 其结构如下： R apply(T t); Function的关键函数，函数签名是T -> R。 default Function compose(Function before){..} 在apply之前需要执行的操作。这使得函数签名变成V -> T -> R。 default Function compose(Function before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } default Function andThen(Function after){..} default Function andThen(Function after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } 与compose相反，andThen约定的是apply之后的操作。 static Function identity(){..} 这个就比较奇怪了，返回的永远都是自己本身。 static Function identity() { return t -> t; } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-07 22:49:07 "},"源码解读/java.util/java.util.function/IntFunction.html":{"url":"源码解读/java.util/java.util.function/IntFunction.html","title":"IntFunction/LongFunction/DoubleFunction","keywords":"","body":"IntFunction 为了避免基本数据类型与其包装类之间转换的开销，Java中的八种基本数据类型都有其对应的Function接口。不同的是，Function的函数描述符是T -> R。接口中有4个方法，而xxxFunction中只有主要的抽象方法apple，函数描述符是int -> R。 与IntFunction类似的还有LongFunction和DoubleFunction，注意并不是每种基本数据类型都有对应的Function。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:17:53 "},"源码解读/java.util/java.util.function/IntToLongFunction.html":{"url":"源码解读/java.util/java.util.function/IntToLongFunction.html","title":"IntToLongFunction/IntToDoubleFunction/LongToDoubleFunction/LongToIntFunction","keywords":"","body":"IntToLongFunction/IntToDoubleFunction/LongToDoubleFunction/LongToIntFunction Function系中还提供了基本类型int、long和double之间的转换，int和long之间可以相互住转换，两者都能向double转换，所以才有了以下四类： IntToLongFunction 其中只有一个抽象方法，函数描述符是int -> long。 @FunctionalInterface public interface IntToLongFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ long applyAsLong(int value); } IntToDoubleFunction 其中只有一个抽象方法，函数描述符是int -> double。 @FunctionalInterface public interface IntToDoubleFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ double applyAsDouble(int value); } LongToIntFunction 其中只有一个抽象方法，函数描述符是long -> int。 @FunctionalInterface public interface LongToIntFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ int applyAsInt(long value); } LongToDoubleFunction 其中只有一个抽象方法，函数描述符是long -> double。 @FunctionalInterface public interface LongToDoubleFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ double applyAsDouble(long value); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:28:40 "},"源码解读/java.util/java.util.function/ToIntFunction.html":{"url":"源码解读/java.util/java.util.function/ToIntFunction.html","title":"ToIntFunction/ToDoubleFunction/ToLongFunction","keywords":"","body":"ToIntFunction/ToDoubleFunction/ToLongFunction 提供了对象到基本数据类型int、long和double的转换 ToIntFunction 只有一个抽象方法，函数描述符是T -> int。 @FunctionalInterface public interface ToIntFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ int applyAsInt(T value); } ToDoubleFunction 只有一个抽象方法，函数描述符是T -> double。 @FunctionalInterface public interface ToDoubleFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ double applyAsDouble(T value); } ToLongFunction 只有一个抽象方法，函数描述符是T -> long @FunctionalInterface public interface ToLongFunction { /** * Applies this function to the given argument. * * @param value the function argument * @return the function result */ long applyAsLong(T value); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:32:42 "},"源码解读/java.util/java.util.function/BiFunction.html":{"url":"源码解读/java.util/java.util.function/BiFunction.html","title":"BiFunction","keywords":"","body":"BiFunction Function的函数描述符是T -> R， 而BiFunction的函数描述符是(T, U) -> R（\b当然这一点其实也可以通过Function的compose方法做到），结构如下： BiFunction相比Function而言，其方法上有一定的剪枝，少了compose和identity方法。具体可以参考Function的源码解读。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:05:14 "},"源码解读/java.util/java.util.function/UnaryOperator.html":{"url":"源码解读/java.util/java.util.function/UnaryOperator.html","title":"UnaryOperator","keywords":"","body":"UnaryOperator UnaryOperator继承自Function，接受一个操作数并返回一个相同类型的对象，类定义如下： @FunctionalInterface public interface UnaryOperator extends Function { /** * Returns a unary operator that always returns its input argument. * * @param the type of the input and output of the operator * @return a unary operator that always returns its input argument */ static UnaryOperator identity() { return t -> t; } } UnaryOperator是一元运算，与其对应的二元运算是BiOperator。 下面是一个应用UnaryOperator运算的例子： public class UnaryOperatorTest { public static void main(String[] args) { List list = Arrays.asList(10, 20, 30, 40, 50); UnaryOperator operator = i -> i * i; unaryOperatorFun(operator, list).forEach(System.out::println); } private static List unaryOperatorFun(UnaryOperator unaryOperator, List list){ return list.stream().map(i -> unaryOperator.apply(i)).collect(Collectors.toList()); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 12:20:38 "},"源码解读/java.util/java.util.function/BinaryOperator.html":{"url":"源码解读/java.util/java.util.function/BinaryOperator.html","title":"BinaryOperator","keywords":"","body":"BinaryOperator BinaryOperator继承自BiFunction，是二元运算，接受两个操作数并返回一个相同类型的对象，定义如下： @FunctionalInterface public interface BinaryOperator extends BiFunction { /** * Returns a {@link BinaryOperator} which returns the lesser of two elements * according to the specified {@code Comparator}. * * @param the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the lesser of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static BinaryOperator minBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) the type of the input arguments of the comparator * @param comparator a {@code Comparator} for comparing the two values * @return a {@code BinaryOperator} which returns the greater of its operands, * according to the supplied {@code Comparator} * @throws NullPointerException if the argument is null */ public static BinaryOperator maxBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } 可以看到，该接口中定义了minBy和maxBy方法，用来比较数字或字符串的大小。注意到，这是一个静态方法，接受一个Comparator接口对象，返回的是BinaryOperator接口对象。 例如： // maxBy & minBy BinaryOperator bi = BinaryOperator.maxBy(Comparator.naturalOrder()); System.out.println(bi.apply(\"a\", \"b\")); // b 下面是一个使用BinaryOperator的例子： public class BinaryOperatorTest { public static void main(String[] args) { Map map = ImmutableMap.of(\"A\", \"a\", \"B\", \"b\", \"C\", \"c\"); BinaryOperator operator = (s1, s2) -> s1 + \"-\" + s2; binaryOperationFun(operator, map).forEach(System.out::println); } private static List binaryOperationFun(BinaryOperator binaryOperator, Map map){ List biList = new ArrayList<>(); map.forEach((s1, s2) -> biList.add(binaryOperator.apply(s1, s2))); return biList; } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 13:39:12 "},"源码解读/java.util/java.util.function/Supplier.html":{"url":"源码解读/java.util/java.util.function/Supplier.html","title":"Supplier","keywords":"","body":"Supplier Supplier的函数描述符是void -> T， 这与Consumer正好相反，可以用来创建对象。结构如下： 只有唯一的抽象方法get。 T get(); 这个方法用来获取产生的对象。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:10:03 "},"源码解读/java.util/java.util.function/BooleanSupplier.html":{"url":"源码解读/java.util/java.util.function/BooleanSupplier.html","title":"BooleanSupplier/IntSupplier/LongSupplier/DoubleSupplier","keywords":"","body":"BooleanSupplier/IntSupplier/LongSupplier/DoubleSupplier Supplier的函数函数描述符是() -> T，对于基本基本数据类型来说，为了避免拆箱装箱的麻烦，提供了对于基本数据类型boolean、int、long和double的支持。所以才有了以下四个类。 BooleanSupplier 函数描述符是() -> boolean。 @FunctionalInterface public interface BooleanSupplier { /** * Gets a result. * * @return a result */ boolean getAsBoolean(); } IntSupplier 函数描述符是() -> int。 @FunctionalInterface public interface IntSupplier { /** * Gets a result. * * @return a result */ int getAsInt(); } LongSupplier 函数描述符是() -> long。 @FunctionalInterface public interface LongSupplier { /** * Gets a result. * * @return a result */ long getAsLong(); } DoubleSupplier 函数描述符是() -> double。 @FunctionalInterface public interface DoubleSupplier { /** * Gets a result. * * @return a result */ double getAsDouble(); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 11:40:54 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.html","title":"java.util.concurrent","keywords":"","body":"java.util.concurrent 这个包是JDK5引入的新包，java.util.current包（常常成为JUC）中提供了对线程优化、管理的各项操作，使得线程的使用变得的心应手。该包提供了线程的运行，线程池的创建，线程生命周期的控制，线程间的协作等功能。如果一些类名看起来相似，可能是因为java.util.concurrent中的许多概念源自 Doug Lea的 util.concurrent 库。 作者Doug Lea大概是世界上对Java影响最大的人了。可以看下它关于并发文章，译文见 http://ifeve.com/doug-lea/ JDK 5.0 中的并发改进可以分为三组： JVM 级别更改。大多数现代处理器对并发对某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。CAS操作都封装在java不公开的类库sun.misc.Unsafe，这个类包含了对院子操作的封装，具体用本地代码实现。公开 CAS 可以开发高度可伸缩的并发 Java 类。这些更改主要由 JDK 库类使用，而不是由开发人员使用。 低级实用程序类 -- 锁定和原子类。使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。 高级实用程序类。这些类实现并发构建块，每个计算机科学文本中都会讲述这些类 -- 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多（如果不是全部）同步、wait() 和 notify() 的使用，从而提高性能、可读性和正确性。 JUC大致上又可以分为三个子包： 子包 作用 Atomic 原子数据的构建 Locks 基本锁的实现，最重要的是AQS框架和LockSupport Concurrent 构建的一些高级工具，比如线程池、并发队列等 Atomic和Locks是真正存在的子包，最后一个实际上并不存在这个子包，有一些类散落在JUC中。它们都是一些高级的使用程序类，主要的重要的类有下面这些： 类名 功能 Executors 线程池的工厂类 ThreadPoolExecutor 线程池 ScheduledThreadPoolExecutor ConcurrentHashMap ConcurrentLinkedDeque ConcurrentLinkedQueue CopyOnWriteArrayList CopyOnWriteArratSet CountDownLatch DelayQueue LinkedBlockingDeque LinkedBlockingQueue PriorityBlockingQueue ThreadPolExecutor 定义的接口有下面这些 接口 功能 Executor 线程启动类 ExecutorService 控制线程的执行和取消 ScheduledExecutorService 提供了线程启动时机的控制 Callable 提供了对线程的控制 Future 用于控制线程的执行 Java 8 API—— JUC 参考 Doug Lea并发编程文章全部译文 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-23 17:23:45 "},"源码解读/java.util/java.util.concurrent/Callable.html":{"url":"源码解读/java.util/java.util.concurrent/Callable.html","title":"Callable","keywords":"","body":"Callable Callable和Runnable一样，都表示一项任务，都能够让线程执行，从名字就能看出来。与Runnable一样，Callable是一个接口，并且是一个“功能接口”，里面之定义了一个方法call，接口结构如下： 整个接口定义如下： @FunctionalInterface public interface Callable { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; } 很容易就能看出Runnable和 Callable的区别： Runnable在java.lang包中，Callable在包java.util.concurrent中，是1.5之后添加的，为了区分线程的工作单元和执行机制。在Executor框架中，Runnable和Callable都是线程的工作单元。 Runnable中定义的run方法返回值是void，并且不能抛出可检异常，而Callable中定义的call方法具有返回值，并且会抛出可检异常。 Callable产生结果，这个结果是异步的（因为线程的调度无法预估），这个结果可以被Future接口的实例拿到。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-14 10:20:37 "},"源码解读/java.util/java.util.concurrent/Future.html":{"url":"源码解读/java.util/java.util.concurrent/Future.html","title":"Future","keywords":"","body":"Future Future可以拿到异步执行任务的结果。它定义了计算是否进行，取消计算进行，等待计算完成，取得执行结果。 这是一个接口，定义如下： boolean cancel(boolean mayInterruptIfRunning); 该方法用来尝试取消任务过程。如果任务已经完成，该尝试将失败。如果成功，并任务根本没开始之前就被调用了，那么任务将永远不被执行。如果任务已经开始了，但是没有结束，那么mayInterruptIfRunning参数确定执行这个任务的线程是否应该被中断以试图停止任务。 在此方法返回后，对isDone（）的后续调用将始终返回true。 如果此方法返回true，则后续调用isCancelled（）将始终返回true。 boolean isCancelled(); 查看任务是否已经被取消。 boolean isDone(); 查看任务是否已经结束。这里的“结束”并不代表执行结束，它可能是执行结束，还有可能是被抛出了异常，还有可能是被取消了。符合以上情况就会返回true。 V get() throws InterruptedException, ExecutionException; 取得任务的结果，注意，返回值只有当任务成功执行结束后才能正确返回，如果任务正在被执行中，调用该方法的线程将被阻塞，直到任务结束。 如果当前线程在等待的时候被中断，那么该方法将抛出InterruptedException。如果任务执行的线程抛出了异常，那么该方法将抛出ExecutionException。如果任务取消了，那么该方法将抛出CancellationException。V get(long timeout, TimeUnit unit) V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; get方法的重载，设定了等待的时间。如果在等待的时间内还得不到任务结果，那么方法将抛出TimeoutException。 Future的一个实现类是FutureTask。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 22:04:28 "},"源码解读/java.util/java.util.concurrent/FutureTask.html":{"url":"源码解读/java.util/java.util.concurrent/FutureTask.html","title":"FutureTask","keywords":"","body":"FutureTask FutureTask是最常用的Future的实现类，其主要的功能就是Future的功能，这里不多说。 需要特别注意的是，FutureTask可以用来包装Callable和Runnable对象，并且由于FutureTask实现了Runnable接口，所以它可以提交给Executor执行。 该类的结构如下： public class FutureTask implements RunnableFuture 类声明。前面说到FutureTask实现了Runnable接口，实际上，并不是直接实现的，是间接实现的。该类直接实现RunnableFuture接口，而该接口继承了Runnable和Future接口： public interface RunnableFuture extends Runnable, Future { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } 所以，FutureTask需要实现run方法。 构造函数 重载了两个构造函数。 public FutureTask(Callable callable){...} 接受一个Callable类型的参数，这里是对callable做了一层包装。定义如下： public FutureTask(Callable callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } /** The underlying callable; nulled out after running */ private Callable callable; private volatile int state; 可以看到，FutureTask保存了这个任务，然后将state实例变量为NEW。state变量用来表示任务的状态，有以下几种取值： private static final int NEW = 0; // 新建 private static final int COMPLETING = 1; //计算中 private static final int NORMAL = 2; //计算成功 private static final int EXCEPTIONAL = 3; //抛出异常 private static final int CANCELLED = 4; //被取消 private static final int INTERRUPTING = 5; //正在被中断 private static final int INTERRUPTED = 6; //已经被中断 那么任务的状态变化过程可能存在以下几种情况： NEW -> COMPLETING -> NORMAL NEW -> COMPLETING -> EXCEPTIONAL NEW -> CANCELLED NEW -> INTERRUPTING -> INTERRUPTED public FutureTask(Runnable runnable, V result) {..} 这里接受Runnable类型参数和预定的结果的类型。诶，不是说FutureTask会接受任务的执行结果返回值么？但是Runnable的run方法没有返回值啊？没错，但是Executor框架中的工具类Executors提供了一种转化方法，可以将Runnable类型对象转为Callable类型对象，该构造函数定义如下： public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } java中有很多有\"-s\"和没有\"-s\"的非常相似的类，一般来讲，有\"-s\"的都是没有\"-s\"的工具类，比如Objects - Object、Arrays - Array 、Collections - Collection和Executors - Executor。 public boolean cancel(boolean mayInterruptIfRunning){...} 用来取消任务，正如下Future接口中所说一样，如果在任务开始前就调用该方法，那么任务根本不会执行。如果任务已经结束，那么方法将返回false。否则将由mayInterruptIfRunning参数控制是否取消任务，即true表示取消任务，而false表示不取消。一般来说，调用这个方法都是为了取消任务的吧，谁那么无聊用false作为参数，虚晃一枪。该方法定义如下： public boolean cancel(boolean mayInterruptIfRunning) { if (!(state == NEW && UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { // in case call to interrupt throws exception if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); } } } finally { finishCompletion(); } return true; } 方法结构比较清晰，在finally中调用的finishCompletion方法定义如下： private void finishCompletion() { // assert state > COMPLETING; for (WaitNode q; (q = waiters) != null;) { if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; } break; } } done(); callable = null; // to reduce footprint } 额，没看懂。 public boolean isCancelled() {...} 判断任务是否被取消。定义如下： public boolean isCancelled() { return state >= CANCELLED; } 注意，这里判断当前任务状态是否大于CANCELLED，对照前面的状态常数，如果任务的状态正处于CANCELLED、INTERRUPTING或INTERRUPTED，则方法返回true。原来这个状态常量的设计并不是随便写的。 public boolean isDone() {..} 我理解的isDone含义是检查任务是否已经完成，这种完成不定是NORMAL，可以是除了NEW之外的其他状态。源码定义如下： public boolean isDone() { return state != NEW; } get方法 重载了另个get方法，区别在于一个会一直等下去或者当前线程在等待状态被中断，而另一个在有限时间内等待，超时了就抛出异常，道理是一样的，我们只需要看前一种计即可。 public V get() throws InterruptedException, ExecutionException { int s = state; if (s 只有当任务处于NEW或者COMPLETING状态，get方法才会尝试进行获取结果，这种尝试依靠awaitDone方法实现，定义如下： private int awaitDone(boolean timed, long nanos) throws InterruptedException { final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) { if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } int s = state; if (s > COMPLETING) { if (q != null) q.thread = null; return s; } else if (s == COMPLETING) // cannot time out yet Thread.yield(); else if (q == null) q = new WaitNode(); else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) { nanos = deadline - System.nanoTime(); if (nanos 其核心还是自旋。如果当前线程被中断了，则退出等待，并抛出异常。剩下的...有点看不懂了。 public void run() {} FutureTask间接实现了Runnable接口，所以必须是实现run方法。定义如下： public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable c = callable; if (c != null && state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s >= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 本质上执行的仍旧是Callable的实例方法的call方法。 使用FutureTask 利用FutureTask来获取任务的执行结果的基本流程是： 定义一个 Callable或Runnable实例（一般用匿名类实现），以此实例构造FutureTask的实例（注意不是Future的实例），然后以此实例构造Thread实例，调用Thread对象的start方法。 下面是一个FutureTask的最基础的使用方法： public class CallableAndFuture { public static void main(String[] args) { Callable callable = new Callable() { @Override public Integer call() throws Exception { return new Random().nextInt(); } }; FutureTask future = new FutureTask(callable); //注意这里future不能声明为`Future`,虽然这句话不会报错，但是下一句话`new Thread(future)`会编译报错，因为`Future`接口本身没有继承`Runnable`接口，只有`FutureTask`实现了`Runnable`接口 new Thread(future).start(); try{ Thread.sleep(5000); //主线程休眠，让任务执行线程有足够的时间执行任务 System.out.println(future.get()); }catch (InterruptedException e){ } catch (ExecutionException e) { e.printStackTrace(); } } } 程序执行将打印出一个任意的整数。 以上方法是我们手动创建一个线程用来执行任务。在JDK1.5之后，创建线程的办法更加多样化，我们可以将任务执行交给线程池来完成。 public class CallableAndFutureTest { public static void main(String[] args) { ExecutorService threadPoll = Executors.newSingleThreadExecutor(); Future future = threadPoll.submit(new Callable() { // 这里可以将future声明为Future @Override public Integer call() throws Exception { return new Random().nextInt(); } }); try { Thread.sleep(5000); System.out.println(future.get()); }catch (InterruptedException e){ e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 这样看着代码也简单了很多，我们无需取手动触发start，这样不用自己去管理线程的生命周期，非常方面，在1.5之后，线程池继续是线程操作的首选。 如果有多个执行结果，可以采取以下方法： public class CallableAndFutureTest1 { public static void main(String[] args) { ExecutorService threadPool = Executors.newSingleThreadExecutor(); CompletionService cs = new ExecutorCompletionService(threadPool); for(int i = 1; i () { public Integer call() throws Exception { return taskID; } }); } // 可能做一些事情 for(int i = 1; i 参考 Java线程(七)：Callable和Future Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 22:08:03 "},"源码解读/java.util/java.util.concurrent/ConcurrentHashMap.html":{"url":"源码解读/java.util/java.util.concurrent/ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"ConcurrentHashMap ConcurrentHashMap是实现高并发、高吞吐量的线程安全的HashMap，这个类服从与之相同的功能规范Hashtable（Hashtable是也是线程安全的），并且包括与每个方法相对应的方法的版本Hashtable。但是，即使所有操作都是线程安全的，检索操作也不需要锁定，并且也不支持以阻止所有访问的方式锁定整个表。这个类Hashtable在依赖于线程安全性的程序中是完全可互操作的，但是不依赖于它的同步细节。 /** * 写一段程序：多线程往map中put元素，要求每个元素只能被put一次 * 思路： 利用concurrentHashMap中的putIfAbsent方法 */ public class OnceOnlyMap { public static void main(String[] args) { String key = \"key\"; String value1 = \"value1\"; String value2 = \"value2\"; ConcurrentHashMap threadSafeMap = new ConcurrentHashMap(); new Thread(() -> { String ifAbsent = threadSafeMap.putIfAbsent(key, value1); if (Objects.equals(ifAbsent, null)) System.out.println(\"Successfully put the element into Map!\"); else System.out.println(\"The element is existing! The previous value is: \" + ifAbsent); }).start(); new Thread(() -> { String ifAbsent = threadSafeMap.putIfAbsent(key, value2); if (Objects.equals(ifAbsent, null)) System.out.println(\"Successfully put the element into Map!\"); else System.out.println(\"The element is existing! The previous value is: \" + ifAbsent); }).start(); } } 参考 ConcurrentHashMap能完全替代HashTable吗？ ConcurrentHashMap总结 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-14 14:49:52 "},"源码解读/java.util/java.util.concurrent/CountDownLatch.html":{"url":"源码解读/java.util/java.util.concurrent/CountDownLatch.html","title":"CountDownLatch","keywords":"","body":"CountDownLatch CountDown的意思是“倒计时”，“latch”的意思是\"门栓\"。所以CountDownLatch的意思是“倒计时后占有”？实际上，这个类的用法确实如此。它是一个同步辅助类，允许一个或多个线程等待，直到一组在其它线程中的操作执行完成。什么意思呢？比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 该类的定义如下： 又在里面见到了熟悉的老朋友Sync public class CountDownLatch 类声明，非常干净。这可不是一个锁。 对于线程的理解总能感觉乱糟糟的，总觉得什么都是锁，线程就是通过各种各样的锁实现的。这种想法是不对的。 private static final class Sync extends AbstractQueuedSynchronizer {..} 又是基于AQS的实现，定义如下： /** * Synchronization control For CountDownLatch. * Uses AQS state to represent count. */ private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } 可以看到，我们仍旧可以指定资源state的数量。 构造方法 只有一个构造方法： public CountDownLatch(int count) { if (count 其中count就是倒计时的值，从本质来讲，这个值执行的是AQS中state的值。 await方法 await方法是CountDownLatch中最重要的方法之一了，它的目的在于调用await()方法的线程会被挂起，直到条件满足了才能继续进行。满足什么条件呢？await有两个重载，这两个方法继续进行的满足条件是不一样的。 public void await() throws InterruptedException{..} 无参数的await方法。定义如下： public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } 调用这个方法的线程将被挂起，知道count的值减到0才能继续。 public boolean await(long timeout, TimeUnit unit) throws InterruptedException {..} 两个参数，一个是指时间，另一个是指时间单位。它与无参的await方法作用类似，不同的是，当count到达0之后，它还需要再等待一段时间才能继续。 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } public void countDown(){..} CountDownLatch另外一个重要的方法，其作用是倒计时，即count减去1。定义如下： public void countDown() { sync.releaseShared(1); } public long getCount(){..} 取得当前count的大小，很简单： public long getCount() { return sync.getCount(); } public String toString(){..} 返回的有用信息仍旧是当前的count量。定义如下： public String toString() { return super.toString() + \"[Count = \" + sync.getCount() + \"]\"; } 使用场景 CountDownLatch常常被使用到的场景：线程A需要等到其他几个线程完成之后才能进行，如果需要等待的线程的个数为n，那么就创建一个count=n的计数器，线程A需要等待，其他几个线程每完成一个线程后就将倒计时，等所有的线程都完成之后线程A继续。下面是一个使用示例： public class Test { public static void main(String[] args) { final CountDownLatch latch = new CountDownLatch(2); new Thread(){ public void run() { try { System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } }; }.start(); new Thread(){ public void run() { try { System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } }; }.start(); try { System.out.println(\"等待2个子线程执行完毕...\"); latch.await(); System.out.println(\"2个子线程已经执行完毕\"); System.out.println(\"继续执行主线程\"); } catch (InterruptedException e) { e.printStackTrace(); } } } 程序输出结果是： 线程Thread-0正在执行 线程Thread-1正在执行 等待2个子线程执行完毕... 线程Thread-0执行完毕 线程Thread-1执行完毕 2个子线程已经执行完毕 继续执行主线程 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 22:19:12 "},"源码解读/java.util/java.util.concurrent/CyclicBarrier.html":{"url":"源码解读/java.util/java.util.concurrent/CyclicBarrier.html","title":"CyclicBarrier","keywords":"","body":"CyclicBarrier 这个名字翻译过来是“回环栅栏”，通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做\"回环\"是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。 public class CyclicBarrier 类声明。 构造方法 提供了两个构造方法。 public CyclicBarrier(int parties) { this(parties, null); } public CyclicBarrier(int parties, Runnable barrierAction) { if (parties 其中参数parties指让多少个线程或者任务等待至barrier状态；参数s为当这些线程都达到barrier状态时会执行的内容。 await 重载了两个awit方法： public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException { return dowait(true, unit.toNanos(timeout)); } 第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务； 第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。 我们看下面几个例子就能知道await方法的作用了。 假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 程序的输出是： 线程Thread-0正在写入数据... 线程Thread-3正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。 仍旧是上面的例子，如果想要在所有线程写入完毕之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数。 public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N,new Runnable() { @Override public void run() { System.out.println(\"当前线程\"+Thread.currentThread().getName()); } }); for(int i=0;i 执行结果是： 线程Thread-0正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2正在写入数据... 线程Thread-3正在写入数据... 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 当前线程Thread-3 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。 下面来看一下await指定时间的效果 public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 执行结果是： 线程Thread-0正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-3正在写入数据... java.util.concurrent.TimeoutException Thread-1所有线程写入完毕，继续处理其他任务... Thread-0所有线程写入完毕，继续处理其他任务... at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) Thread-2所有线程写入完毕，继续处理其他任务... java.util.concurrent.BrokenBarrierException 线程Thread-3写入数据完毕，等待其他线程写入完毕 at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) Thread-3所有线程写入完毕，继续处理其他任务... 上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。 CyclicBarrier重用 CyclicBarrier是可以重用的，看下面这个例子： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 执行结果为： 线程Thread-0正在写入数据... 线程Thread-1正在写入数据... 线程Thread-3正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 Thread-0所有线程写入完毕，继续处理其他任务... Thread-3所有线程写入完毕，继续处理其他任务... Thread-1所有线程写入完毕，继续处理其他任务... Thread-2所有线程写入完毕，继续处理其他任务... CyclicBarrier重用 线程Thread-4正在写入数据... 线程Thread-5正在写入数据... 线程Thread-6正在写入数据... 线程Thread-7正在写入数据... 线程Thread-7写入数据完毕，等待其他线程写入完毕 线程Thread-5写入数据完毕，等待其他线程写入完毕 线程Thread-6写入数据完毕，等待其他线程写入完毕 线程Thread-4写入数据完毕，等待其他线程写入完毕 Thread-4所有线程写入完毕，继续处理其他任务... Thread-5所有线程写入完毕，继续处理其他任务... Thread-6所有线程写入完毕，继续处理其他任务... Thread-7所有线程写入完毕，继续处理其他任务... 从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。 参考 Java并发编程：CountDownLatch、CyclicBarrier和 Semaphore Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 21:14:13 "},"源码解读/java.util/java.util.concurrent/Semaphore.html":{"url":"源码解读/java.util/java.util.concurrent/Semaphore.html","title":"Semaphore","keywords":"","body":"Semaphore \"Semaphore\"翻译过来是“信号量”的意思。 “信号量”、“互斥”、“同步”...这些名词在并发编程中经常听到，它们之间有什么联系和区别呢？ 一些概念的区别 同步和互斥 首先是“互斥”和“同步”。 “互斥”是指控制同一个时刻只有一个线程可以对其进行操作，这种情况下，多个线程之间是互相排斥的。这种场景非常常见，比如10个售票窗口就有10个线程，而100张票是他们共同访问的资源，要控制每个时刻只能有一个线程能对其进行操作，这样才能保证不出现重复卖票的情况。互斥的实现是通过各种锁实现的，比如内置锁、1.5新加入的ReenrantLock “同步”的概念是用于线程间的通信，只要是进行线程间的配合工作，最常见的情况就是“生产者-消费者”模式。多个生产者和多个消费者就是多条执行线程，他们共同操作一个数据结构中的数据，数据结构中有时是没有数据的，这个时候消费者应该处于等待状态而不是不断的去访问这个数据结构。这里就涉及到线程间通信（当然此处还涉及到互斥，这里暂不考虑这一点），消费者线程一次消费后发现数据结构空了，就应该处于等待状态，生产者生产数据后，就去唤醒消费者线程开始消费。生产者线程某次生产后发现数据结构已经满了，也应该处于等待状态，消费者消费一条数据后，就去唤醒生产者继续生产。而线程同步可以通过Object的wait、notify和notifyAll以及1.5之后的Condition来解决。 其实这两个概念我们经常放在一起，因为另种操作是经常同时进行，比如上面提到的生产者-消费者模式，既有对统一资源的互斥访问，也有对线程的同步控制。 信号量和互斥量 信号量用于线程的同步，而互斥量用于线程的互斥。其实说法也并非这么绝对，信号量同样可以用来进行线程的互斥。 互斥量是一个特殊的信号量，特殊之处在于它只有0和1的概念，一个线程要么进入临界区，要么不进入临界区，很干脆，互斥量在Java中的实现是ReentrantLock。 而信号量则是一个非负数，它允许一定数量的线程进入临界区。信号量在Java中的实现是Semaphore。 互斥量的加锁和解锁必须由同一个线程分别对应使用，而信号量则可以由一个线程释放，另一个线程得到。 下面是一个信号量的定义： public class Semaphore{ private boolean signal = false; public synchronied take(){ this.signal = true; this.notifyAll(); } public synchronized release() throws InterruptedException{ while(! this.signal){ //while循环避免假唤醒 wait(); } this.signal = false; } } 使用场景如下： Semaphore semaphore = new Semaphore(); SendingThread sender = new SendingThread(semaphore)； ReceivingThread receiver = new ReceivingThread(semaphore); receiver.start(); sender.start(); public class SendingThread extends Thread{ Semaphore semaphore = null; public SendingThread(Semaphore semaphore){ this.semaphore = semaphore; } @Override public void run(){ while(true){ //do something, then signal this.semaphore.take(); } } } public class RecevingThread { Semaphore semaphore = null; public ReceivingThread(Semaphore semaphore){ this.semaphore = semaphore; } public void run(){ while(true){ this.semaphore.release(); //receive signal, then do something... } } } 老实说，这实际上是一个互斥量，因为它非0即1，并没有计数。而下面就是一个计数的信号量。 public class Semaphore{ private int signal = 0; public synchronied void take(){ this.signal ++; this.notifyAll(); } public synchronized void release() throws InterruptedException{ while(this.signals == 0) wait(); this.signals--; } } 以上的信号量是没有上界的，下面我们就创建一个有上界的信号量： public class BoundedSemaphore { private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound){ this.bound = upperBound; } public synchronized void take() throws InterruptedException{ while(this.signals == bound) wait(); this.signals++; this.notify(); } public synchronized void release() throws InterruptedException{ while(this.signals == 0) wait(); this.signals--; this.notify(); } } 这里看到，我们在创建BoundedSemaphore类的时候，可以指定上界，如果信号量已经达到上界，那么执行take的线程就将中止。 实际上，上面不就是消费者-生产者模式么？ Semaphore的实现 Java提供了内置的Semaphore类，其结构如下： 可以看到，Semaphore也是AQS的实现。其中最重要的仍然是Syn的抽象内部类的定义及它的两个实现NonfairSync和FairSync。 下面是Sync的源码定义： /** * Synchronization implementation for semaphore. Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) { setState(permits); } final int getPermits() { return getState(); } final int nonfairTryAcquireShared(int acquires) { for (;;) { int available = getState(); int remaining = available - acquires; if (remaining current) // underflow throw new Error(\"Permit count underflow\"); if (compareAndSetState(current, next)) return; } } final int drainPermits() { for (;;) { int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; } } } 在Sync构造函数中可以看到，它接受的的整形参数是加上就是AQS中资源的个数，而对于资源的获取，就是将资源的个数减去1，对于资源的释放，就是将资源的个数加上1。 其他代码暂时先不看了，总觉的AQS的基础没有打好，所以看这部分有点困难。 使用场景 Semaphore用来控制线程并发的个数，其中我们传入的参数就是允许并发的线程的个数。由于这种特性，经常用来限制获取某种资源的线程数量，比如数据库连接池中连个数的限制等。 下面是一个使用信号量来限制资源使用数量的例子：操场上有5个跑道，一个跑道一次只能有一个学生在上面跑步，一旦所有跑道在使用，那么后面的学生就需要等待，直到有一个学生不跑了。那么操场类的定义如下： /** * 操场，有5个跑道 * Created by Xingfeng on 2016-12-09. */ public class Playground { /** * 跑道类 */ static class Track { private int num; public Track(int num) { this.num = num; } @Override public String toString() { return \"Track{\" + \"num=\" + num + '}'; } } private Track[] tracks = { new Track(1), new Track(2), new Track(3), new Track(4), new Track(5)}; private boolean[] used = new boolean[5]; private Semaphore semaphore = new Semaphore(5, true); /** * 获取一个跑道 */ public Track getTrack() throws InterruptedException { semaphore.acquire(1); return getNextAvailableTrack(); } /** * 返回一个跑道 * * @param track */ public void releaseTrack(Track track) { if (makeAsUsed(track)) semaphore.release(1); } /** * 遍历，找到一个没人用的跑道 * * @return */ private Track getNextAvailableTrack() { for (int i = 0; i 创建了5个跑道对象，并使用一个boolean类型的数组记录每个跑道是否被使用了，初始化了5个许可证的Semaphore，在获取跑道时首先调用acquire(1)获取一个许可证，在归还一个跑道是调用release(1)释放一个许可证。接下来再看启动程序，如下： public class SemaphoreDemo { static class Student implements Runnable { private int num; private Playground playground; public Student(int num, Playground playground) { this.num = num; this.playground = playground; } @Override public void run() { try { //获取跑道 Playground.Track track = playground.getTrack(); if (track != null) { System.out.println(\"学生\" + num + \"在\" + track.toString() + \"上跑步\"); TimeUnit.SECONDS.sleep(2); System.out.println(\"学生\" + num + \"释放\" + track.toString()); //释放跑道 playground.releaseTrack(track); } } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Executor executor = Executors.newCachedThreadPool(); Playground playground = new Playground(); for (int i = 0; i Student类代表学生，首先获取跑道，一旦获取到就打印一句话，然后睡眠2s，然后再打印释放，最后归还跑道。 下面这个例子是源码中注释的给出的： class Pool { private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException { available.acquire(); return getNextAvailableItem(); } public void putItem(Object x) { if (markAsUnused(x)) available.release(); } // Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() { for (int i = 0; i 这里定义的是一个“池”，至于存在的是什么东西，其实就要看数组item是什么了。item数组是我们可获得的资源，用数组used来标识资源是否可用。同样声明一个Semaphore变量，其许可的数量正好是资源的数量，当申请一个资源的时候，先尝试获取许可，如果无法获得许可则线程挂起。直到许可被释放。在释放资源的时候，同时释放一个许可。 记住上面这个例子！ 参考 Java多线程编程--（3）线程互斥、同步的理解 Java并发编程——信号量与互斥量 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 21:52:50 "},"源码解读/java.util/java.util.concurrent/Executor.html":{"url":"源码解读/java.util/java.util.concurrent/Executor.html","title":"Executor","keywords":"","body":"Executor java.lang包为我们提供了线程操作的两个——Runnable和Thread，前者用来定义一个线程的工作单元，后者即为线程实现。Thread和Object都提供了线程状态转化的一些方法，所以我实现多线程程序的时，我们不仅需要手动创建线程，还需要手动进行线程的状态管理。 JDK1.5开始，JUC提供了Executor框架，线程池代替了原来线程的手动创建，而线程的状态转化无需我们过问。 Executor是最基本的接口。其结构如下 这也是一个功能性接口，只有一个方法executor。实际上，Executor的作用完全是为了代替手动创建Thread。例如之前new Thread(new (RunableTask())).start()完全可以用下面的方法代替： Executor executor = (anExecutor); executor.execute(new RunableTask()); executor.execute(new RunableTask()); 其中anExecutor当然是一个Executor的实现类的一个实例。而execute方法接收一个Runnable类型对象，这个方法的实现可能是： class DirectExecutor implements Executor{ @Override public void execute(Runnable runnable){ runnable.run(); } } 更常用的一种方法是： class DirectExecutor implements Executor{ @Override public void execute(Runnable runnable){ new Thread(runnable).start(); } } 下面这段代码是源码中给出的使用示例： class SerialExecutor implements Executor { final Queue tasks = new ArrayDeque(); final Executor executor; Runnable active; SerialExecutor(Executor executor) { this.executor = executor; } public synchronized void execute(final Runnable r) { tasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (active == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((active = tasks.poll()) != null) { executor.execute(active); } } } SerialExecutor是一个执行器，它用一个队列保存工作单元，并且按照顺序执行。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-23 00:07:17 "},"源码解读/java.util/java.util.concurrent/ExecutorService.html":{"url":"源码解读/java.util/java.util.concurrent/ExecutorService.html","title":"ExecutorService","keywords":"","body":"ExecutorService Executor接口定义了execute方法来启动线程，ExecutorService接口继承了该Executor，并定义了一些线程的管理操作。其接口结构如下： API如下： 方法 说明 void shutdown(); 这个方法会将之前提交的任务执行有序关闭，且不会等待这些任务是否已经完成，并且不会再接受新任务 List shutdownNow() 尝试停止所有正在执行的任务，暂停等待任务的处理，并返回正在等待执行的任务列表。此方法不会等待主动执行的任务终止。 使用awaitTermination来做到这一点。 boolean isShutdown(); 判断executor是否已经关闭 boolean isTerminated(); 如果所有任务在关闭后都完成，则返回true。 请注意，除非shutdown或shutdownNow先被调用，否则isTerminated从来就不是真的。 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException； 阻塞，直到所有任务在关闭请求后发生或发生超时，或者当前线程中断，无论哪个先发生。 Future submit(Callable task); 提交Callable类型返回值任务，并返回表示未完成任务结果的Future。 未来的get方法将在成功完成时返回任务的结果。 如果您想立即阻止等待任务，可以使用结构result = exec.submit（aCallable）.get（）; Future submit(Runnable task, T result); 提交Runnable类型任务并返回表示该任务的Future。 未来的get方法将在成功完成时返回给定的结果。 Future submit(Runnable task); 提交Runnable类型任务并返回表示该任务的Future。 Future的get方法在成功完成后将返回null。 List> invokeAll(Collection> tasks) throws InterruptedException; 执行给定的任务，返回一份持有其状态和结果的期货清单，当全部完成时。 Future.isDone（）对于返回列表的每个元素都是true。 请注意，完成的任务可能正常结束或通过抛出异常终止。 如果在进行此操作时修改了给定的集合，则此方法的结果未定义。 List> invokeAll(Collection> tasks,long timeout, TimeUnit unit) throws InterruptedException; 比上一个方法多了一个时间限定 T invokeAny(Collection> tasks) throws InterruptedException, ExecutionException; 执行给定的任务，当所有完成或超时到期时返回一份持有其状态和结果的期货清单，以先发生者为准。 Future.isDone（）对于返回列表的每个元素都是true。 返回后，尚未完成的任务将被取消。 请注意，完成的任务可能正常结束或通过抛出异常终止。 如果在进行此操作时修改了给定的集合，则此方法的结果未定义。 下面是是源码中的示例： class NetworkService implements Runnable { private final ServerSocket serverSocket; private final ExecutorService pool; public NetworkService(int port, int poolSize) throws IOException { serverSocket = new ServerSocket(port); pool = Executors.newFixedThreadPool(poolSize); } public void run() { // run the service try { for (;;) { pool.execute(new Handler(serverSocket.accept())); } } catch (IOException ex) { pool.shutdown(); } } } class Handler implements Runnable { private final Socket socket; Handler(Socket socket) { this.socket = socket; } public void run() { // read and service request on socket } } ExecutorService有两个具体常用的实现类：ThreadPoolExecutor和ScheduledThreadPollExecutor。也就是我们常说的线程池。 参考 ExecutorService引发的血案（二）ExecutorService使用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 01:14:06 "},"源码解读/java.util/java.util.concurrent/ThreadPoolExecutor.html":{"url":"源码解读/java.util/java.util.concurrent/ThreadPoolExecutor.html","title":"ThreadPoolExecutor","keywords":"","body":"ThreadPoolExecutor 线程池的使用解决了两个问题： 减少了每个任务的调用开销，所以在执行大量异步任务的是偶提供了改进的性能。 提供了一种限制和管理资源（包括线程）的方法，每个ThreadPoolExecutor还维护了一些基本统计信息，例如已经完成任务的数量。 ThreadPoolExecutor是我们最常用的线程池，其结果如下： 这个类中提供了很多可调参数和可扩展性的钩子，但是实际上，我们最常使用的是使用Executors工厂类中的三种方法： Executors.newCachedThreadPool()：创建无界线程池，带自动线程回收。 Executors.newFixedThreadPool（int)：创建固定大小的线程池。 Executors.newSingleThreadExecutor（）：创建单线程话线程池。 这些是我们常见的线程池的配置预设，极少情况下才需要我们手动配置和调整。配置和调整什么呢？可以有以下选择（以下内容翻译自Java 8 doc API中ThreadPoolExecutor的说明）： 核心和最大池大小 ThreadPoolExecutor将根据corePoolSize（参阅getCorePoolSize）和maximumPoolSize（请参阅getMaximumPoolSize）设置的边界自动调整线程池大小（参阅getPoolSize）。当方法execute(Runnable)中提交新任务并且少于corePoolSize线程正在处于运行时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求。如果有多余corePoolSize但是少于maximumPoolSize线程正在运行，则仅当队列已满时才会创建新的线程。通过设置corePoolSize和maximumPoolSize相同，我们可以创建一个固定大小的线程池；通过maximumPoolSize设置为基本无界的值（比如Integer.MAX_VALUE），可以让线程池容纳任意数量的并发任务。通常，核心和最大池大小只在构建时设置，但是也可以通过setCorePoolSize(int)和setMaxmumPoolSize(int)来动态更改。 按需建设 默认情况下，即使核心线程最初是在新任务到达时创建的，但是可以使用方法prestartCoreThread()或prestartAllCoreThreads()来动态重写。如果使用非空队列构建池，则可能需要预先启动线程。 创建新线程 没有特别说明，使用一个Executors.defaultThreadFactory()，它创建的线程都在同一个ThreadGroup中，并且具有相同的NORM_PRIORITY优先级和守护进程状态。通过提供不同的ThreadFactory，可以更改线程的名称、线程组、优先级、守护进程状态等。如果ThreadFactory在从newThread返回null时未能创建线程，则执行程序将继续，但可能无法执行任何任务。线程拥有modifyThread RuntimePermission。如果工作线程或使用该池的其他线程不具有此权限，则服务可能降级，配置更改可能无法及时生效，并且关闭池可能会保持可终止但尚未完成状态。 线程活跃数量 如果池当前拥有多个corePoolSize线程，那么多余的线程将被终止，如果他们的空闲时间已经超过了keepAliveTime（请参阅getKeepAliveTime(TimeUnit)）。这提供了一种在不积极使用池时减少资源消耗的方法。如果池在以后变的更加活跃，则将构建新线程。此参数也可以使用方法setKeepAliveTime(long, TimeUnit)动态更改，使用Long.MAX_VALUE值、TimeUnit.NANOSECONDS可有效地禁用在关闭之前终止空闲线程。默认情况下，保持活动策略仅适用于存在多余corePoolSize线程的情况。但是，只要keepAliveTime值不为0，方法allowCoreThreadTimeOut(boolean)也可用于将此超时策略应用于核心线程。 队列 任何BlockingQueue都可以用来传输和保存提交的任务。此队列的使用与池大小进行交互： 如果少于corePoolSize线程正在运行，那么Executor总是倾向于添加新线程而不是排队。 如果corePoolSize或更多线程正在运行，那么Executor总是倾向于排队请求而不是添加新线程。 如果请求不能排队，则会创建一个新线程，除非这会超多maximumPoolSize，在这种情况下，该任务将被拒绝。 有三个通用的排队策略： 直接切换。对于工作队列来说，一个很好的默认选择是SynchronousQueue，它将任务交给下城而不需要保留。这里，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此将构建新的新城。此策略咋处理可能具有内部依赖关系的请求集时避免锁定。直接切换通常需要无限制的maximumPoolSize来避免拒绝新提交的任务。这反过来又承认，当命令持续以平均速度超多可处理速度时，线程的无线增长称为可能。 无界队列。在所有corePoolSize线程繁忙时，使用无界队列（例如没有预定义容量的LinkedBlockingQueue）将倒置新任务在队列中等待。因此，不会创建corePoolSize线程。（因为maximumPoolSize的值没有任何作用。）当每个任务完全独立于其他任务时，这可能是适当的，因此任务不能影响其他任何执行。例如，在网页服务器中，虽然这种排队方式可以有效地消除瞬时突发请求，但是它承认当命令持续以平均速度快于处理的速度到达时，无限制的工作队列增长的可能性。 有界队列。有界队列（例如，ArrayBlockingQueue）有助于防止在使用有限的maximumPoolSize时资源耗尽，但可有更难以调整和控制。队列的大小和最大池大小可以彼此交换；使用大队列和小池可以最大限度地减少CPU的使用率，操作系统资源和上下文切换开销，但会导致任务的低吞吐量，如果任务经常被阻塞（例如，如果它们是I/O绑定的），那么系统可能会安排更多线程的时间，而不是我们设定的时间。使用小队列通常需要更大的池，这会使得CPU更加繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。 拒绝任务 当执行程序关闭时，以及执行程序对最大线程和工作队列容量使用有限边界并且达到饱和时，在方法execute（Runnable）中提交的新任务将被拒绝。 无论哪种情况，执行方法都会调用RejectedExecutionHandler的 RejectedExecutionHandler.rejectedExecution（Runnable，ThreadPoolExecutor）方法。 提供四个预定义的处理程序策略: 在默认的ThreadPoolExecutor.AbortPolicy中，该处理程序在拒绝时抛出运行时RejectedExecutionException。 在ThreadPoolExecutor.CallerRunsPolicy中，调用自身执行的线程运行该任务。 这提供了一个简单的反馈控制机制，可以减慢提交新任务的速度。 在ThreadPoolExecutor.DiscardPolicy中，无法执行的任务将被删除。 在ThreadPoolExecutor.DiscardOldestPolicy中，如果执行程序未关闭，则会删除工作队列头部的任务，然后重试执行（可能会再次失败，从而导致重复执行）。 可以定义和使用其他种类的RejectedExecutionHandler类。 这样做需要特别注意，特别是在政策旨在仅在特定容量或排队策略下工作时。 钩子方法 该类提供了在执行每个任务之前和之后调用的受保护的可覆盖beforeExecute（Thread，Runnable）和afterExecute（Runnable，Throwable）方法。 这些可以用来操纵执行环境; 例如，重新初始化ThreadLocals，收集统计信息或添加日志条目。 另外，可以重写方法terminate（）来执行Executor完全终止后需要完成的任何特殊处理。 如果钩子或回调方法抛出异常，则内部工作者线程可能会失败并突然终止。 队列维护 方法getQueue（）允许访问工作队列以用于监视和调试。 强烈建议不要将此方法用于任何其他目的。 提供两种提供的方法remove（Runnable）和purge（）可用于在大量排队的任务被取消时协助存储回收。 Finalization 一个程序中不再被引用且没有剩余线程的池将自动关闭。 如果您希望确保即使用户忘记调用shutdown（），也可以回收未引用的池，那么您必须通过设置适当的保持活动时间，使用零核心线程的下限和/或设置allowCoreThreadTimeOut（boolean）。 上面是对ThreadPoolExecutor的说明，讲了很多但是一头雾水，还是看看源码是如何实现的吧。 public class ThreadPoolExecutor extends AbstractExecutorService 类声明，直接继承自AbstractExecutorService，而这个抽象类又实现了ExecutorService接口，类结果如下： 构造方法 重载了四种构造方法。核心是下面这个 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize workQueue; /** * Timeout in nanoseconds for idle threads waiting for work. * Threads use this timeout when there are more than corePoolSize * present or if allowCoreThreadTimeOut. Otherwise they wait * forever for new work. */ private volatile long keepAliveTime; /** * Factory for new threads. All threads are created using this * factory (via method addWorker). All callers must be prepared * for addWorker to fail, which may reflect a system or user's * policy limiting the number of threads. Even though it is not * treated as an error, failure to create threads may result in * new tasks being rejected or existing ones remaining stuck in * the queue. * * We go further and preserve pool invariants even in the face of * errors such as OutOfMemoryError, that might be thrown while * trying to create threads. Such errors are rather common due to * the need to allocate a native stack in Thread.start, and users * will want to perform clean pool shutdown to clean up. There * will likely be enough memory available for the cleanup code to * complete without encountering yet another OutOfMemoryError. */ private volatile ThreadFactory threadFactory; /** * Handler called when saturated or shutdown in execute. */ private volatile RejectedExecutionHandler handler; 这个构造方法中的参数与线程的管理关系密切，我们必须弄明白各自的含义 corePoolSize 线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。这里需要注意的是：在刚刚创建ThreadPoolExecutor的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了prestartCoreThread/prestartAllCoreThreads事先启动核心线程。再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。 什么是核心线程呢？就是预先创建出来的，一直存活的线程。即使没有任务需要执行也一直活着，\"一直活着\"这种说法不准确，至少如果设置allowCoreThreadTimeOut=true的时候，核心线程超时后是会退出的。 maximumPoolSize 线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largestPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么说是曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()改变运行的最大线程的数目。 线程池中还有一个线程池大小的概念poolSize，这个量是指线程池中当前线程的实际数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize。 workQueue workQueue是BlockingQueue类型，这是一个阻塞队列，当新任务条件之后，发现corePool的数量大于等于corePoolSize的时候，将会将任务放到阻塞队列中。BlockingQueue是一个接口，在API中推荐使用三种该接口的实现类：SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue。这些具体说明可以参考其对应的源码解决的博文。 keepAliveTime和unit 如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。 allowCoreThreadTimeOut该属性用来控制是否允许核心线程超时退出。如果该值为false，那么核心线程保持为存活状态，不管是不是空闲，如果为true，那么核心线程的空闲时间如果达到了keepAliveTime，那么就会推出。如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态。可以知道：该属性只是用来控制核心线程的。 handler handler是RejectedExecutionHandler类型的变量，表示的是线程拒绝策略。RejectedExecutionHandler是一个接口，在ThreadPoolExecutor中有四种该接口的实现类： AbortPolicy 对拒绝任务抛弃处理，并且抛出异常。 /** * A handler for rejected tasks that throws a * {@code RejectedExecutionException}. */ public static class AbortPolicy implements RejectedExecutionHandler { /** * Creates an {@code AbortPolicy}. */ public AbortPolicy() { } /** * Always throws RejectedExecutionException. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task * @throws RejectedExecutionException always */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(\"Task \" + r.toString() + \" rejected from \" + e.toString()); } } CallerRunsPolicy 这个策略重试添加当前的任务，他会自动重复调用 execute() 方法，直到成功。 /** * A handler for rejected tasks that runs the rejected task * directly in the calling thread of the {@code execute} method, * unless the executor has been shut down, in which case the task * is discarded. */ public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a {@code CallerRunsPolicy}. */ public CallerRunsPolicy() { } /** * Executes task r in the caller's thread, unless the executor * has been shut down, in which case the task is discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } } DiscardPolicy 对拒绝任务直接无声抛弃，没有异常信息。 /** * A handler for rejected tasks that silently discards the * rejected task. */ public static class DiscardPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardPolicy}. */ public DiscardPolicy() { } /** * Does nothing, which has the effect of discarding task r. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } } DiscardOldestPolicy 对拒绝任务不抛弃，而是抛弃队列里面等待最久的一个线程，然后把拒绝任务加到队列。 /** * A handler for rejected tasks that discards the oldest unhandled * request and then retries {@code execute}, unless the executor * is shut down, in which case the task is discarded. */ public static class DiscardOldestPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardOldestPolicy} for the given executor. */ public DiscardOldestPolicy() { } /** * Obtains and ignores the next task that the executor * would otherwise execute, if one is immediately available, * and then retries execution of task r, unless the executor * is shut down, in which case task r is instead discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } } 以上，各类参数基本塑造了整个线程池的轮廓。在学习各种细节之前，我们用下面这张图来串联以下ThreadPoolExecutor的工作流程： 当调用ThreadPoolExecutor的execute提交任务后： 首先检查CorePool中线程的个数，如果此时CorePool中线程的数目于corePoolSize，那么创建新线程来执行任务。注意，这里是创建新线程，即使有空闲的核心线程，线程池也会优先创建新线程处理。 如果当前CorePool内的线程大于等于CorePoolSize，那么将线程尝试加入到BlockingQueue。 如果不能加入BlockingQueue，在小于MaxPoolSize的情况下创建线程执行任务。 如果线程数大于等于MaxPoolSize，那么执行拒绝策略。 对于线程池的工作过程，《编写高质量代码 改善Java程序的151个建议》这本书里举的这个例子很形象： public void execute(Runnable command){..} 这是线程池提交新任务的方法，定义如下 /** * Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}. * * @param command the task to execute * @throws RejectedExecutionException at discretion of * {@code RejectedExecutionHandler}, if the task * cannot be accepted for execution * @throws NullPointerException if {@code command} is null */ public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) SHUTDOWN * On invocation of shutdown(), perhaps implicitly in finalize() * (RUNNING or SHUTDOWN) -> STOP * On invocation of shutdownNow() * SHUTDOWN -> TIDYING * When both queue and pool are empty * STOP -> TIDYING * When pool is empty * TIDYING -> TERMINATED * When the terminated() hook method has completed * * Threads waiting in awaitTermination() will return when the * state reaches TERMINATED. * * Detecting the transition from SHUTDOWN to TIDYING is less * straightforward than you'd like because the queue may become * empty after non-empty and vice versa during SHUTDOWN state, but * we can only terminate if, after seeing that it is empty, we see * that workerCount is 0 (which sometimes entails a recheck -- see * below). */ private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; private static final int CAPACITY = (1 说实话具体的没怎么看懂，但是大概能理解，讲的就是我们上面画的那张图的工作流程。 public void shutdown() {..} /** * Initiates an orderly shutdown in which previously submitted * tasks are executed, but no new tasks will be accepted. * Invocation has no additional effect if already shut down. * * This method does not wait for previously submitted tasks to * complete execution. Use {@link #awaitTermination awaitTermination} * to do that. * * @throws SecurityException {@inheritDoc} */ public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } tryTerminate(); } /** * Lock held on access to workers set and related bookkeeping. * While we could use a concurrent set of some sort, it turns out * to be generally preferable to use a lock. Among the reasons is * that this serializes interruptIdleWorkers, which avoids * unnecessary interrupt storms, especially during shutdown. * Otherwise exiting threads would concurrently interrupt those * that have not yet interrupted. It also simplifies some of the * associated statistics bookkeeping of largestPoolSize etc. We * also hold mainLock on shutdown and shutdownNow, for the sake of * ensuring workers set is stable while separately checking * permission to interrupt and actually interrupting. */ private final ReentrantLock mainLock = new ReentrantLock(); /** * If there is a security manager, makes sure caller has * permission to shut down threads in general (see shutdownPerm). * If this passes, additionally makes sure the caller is allowed * to interrupt each worker thread. This might not be true even if * first check passed, if the SecurityManager treats some threads * specially. */ private void checkShutdownAccess() { SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkPermission(shutdownPerm); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { for (Worker w : workers) security.checkAccess(w.thread); } finally { mainLock.unlock(); } } } /** * Transitions runState to given target, or leaves it alone if * already at least the given target. * * @param targetState the desired state, either SHUTDOWN or STOP * (but not TIDYING or TERMINATED -- use tryTerminate for that) */ private void advanceRunState(int targetState) { for (;;) { int c = ctl.get(); if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) break; } } /** * Common form of interruptIdleWorkers, to avoid having to * remember what the boolean argument means. */ private void interruptIdleWorkers() { interruptIdleWorkers(false); } /** * Interrupts threads that might be waiting for tasks (as * indicated by not being locked) so they can check for * termination or configuration changes. Ignores * SecurityExceptions (in which case some threads may remain * uninterrupted). * * @param onlyOne If true, interrupt at most one worker. This is * called only from tryTerminate when termination is otherwise * enabled but there are still other workers. In this case, at * most one waiting worker is interrupted to propagate shutdown * signals in case all threads are currently waiting. * Interrupting any arbitrary thread ensures that newly arriving * workers since shutdown began will also eventually exit. * To guarantee eventual termination, it suffices to always * interrupt only one idle worker, but shutdown() interrupts all * idle workers so that redundant workers exit promptly, not * waiting for a straggler task to finish. */ private void interruptIdleWorkers(boolean onlyOne) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { for (Worker w : workers) { Thread t = w.thread; if (!t.isInterrupted() && w.tryLock()) { try { t.interrupt(); } catch (SecurityException ignore) { } finally { w.unlock(); } } if (onlyOne) break; } } finally { mainLock.unlock(); } } /** * Performs any further cleanup following run state transition on * invocation of shutdown. A no-op here, but used by * ScheduledThreadPoolExecutor to cancel delayed tasks. */ void onShutdown() { } /** * Transitions to TERMINATED state if either (SHUTDOWN and pool * and queue empty) or (STOP and pool empty). If otherwise * eligible to terminate but workerCount is nonzero, interrupts an * idle worker to ensure that shutdown signals propagate. This * method must be called following any action that might make * termination possible -- reducing worker count or removing tasks * from the queue during shutdown. The method is non-private to * allow access from ScheduledThreadPoolExecutor. */ final void tryTerminate() { for (;;) { int c = ctl.get(); if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty())) return; if (workerCountOf(c) != 0) { // Eligible to terminate interruptIdleWorkers(ONLY_ONE); return; } final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { try { terminated(); } finally { ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); } return; } } finally { mainLock.unlock(); } // else retry on failed CAS } } shutdown只是将空闲的线程interrupt() 了， 因此在shutdown（）之前提交的任务可以继续执行直到结束。 public List shutdownNow() {..} 与shutdown方法不同的是，shutdownNow方法将interrupt所有 线程， 因此大部分线程将立刻被中断。之所以是大部分，而不是全部 ，是因为interrupt()方法能力有限。但是调用该方法并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 /** * Attempts to stop all actively executing tasks, halts the * processing of waiting tasks, and returns a list of the tasks * that were awaiting execution. These tasks are drained (removed) * from the task queue upon return from this method. * * This method does not wait for actively executing tasks to * terminate. Use {@link #awaitTermination awaitTermination} to * do that. * * There are no guarantees beyond best-effort attempts to stop * processing actively executing tasks. This implementation * cancels tasks via {@link Thread#interrupt}, so any task that * fails to respond to interrupts may never terminate. * * @throws SecurityException {@inheritDoc} */ public List shutdownNow() { List tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); } finally { mainLock.unlock(); } tryTerminate(); return tasks; } 剩下的方法其实基本上都不太用到，比如修改corePoolSize的大小、修改maximumPoolSize的大小，这些量其实在创建池的时候已经定好了，很少改变。另外，更多的情况，我们是使用的是Executors工厂类来创建线程池。所以重点还是放在Executors上吧。其他方法如果有兴趣后面再整理。 参考 理解ThreadPoolExecutor源码(一)线程池的corePoolSize、maximumPoolSize和poolSize 深入理解java线程池—ThreadPoolExecutor Java 线程池 ThreadPoolExecutor.(包含拒绝策略CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy ) Java多线程研究05-ThreadPoolExecutor中workQueue、threadFactory和handle ThreadPoolExecutor线程池参数设置技巧 多线程之线程池newFixedThreadPool（二） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-18 20:05:31 "},"源码解读/java.util/java.util.concurrent/BlockingQueue.html":{"url":"源码解读/java.util/java.util.concurrent/BlockingQueue.html","title":"BlockingQueue","keywords":"","body":"BlockingQueue 阻塞队列，顾名思义，它首先是一个队列，在数据结构中起到的位置大致如下： 很显然，这是一个典型的生产者-消费者场景，线程1不断生产产品将其放到队列中，线程2不断从队列取出产品进行消费，当队列满的时候，生产队列将被阻塞；当队列空的时候，消费队列将被阻塞。 当1.5之前，强大的JUC包没有问世的时候，我们需要自己去控制这些阻塞和唤醒的逻辑，比如说wait方法和notifyAll方法的配合使用（可参考 “进程通信与线程通信”一文）。1.5之后，JUC为我们提供了一个线程的阻塞队列——BlockingQueue，其结构如下： 可以看到，BlockingQueue首先得是一个队列，而队列的操作无非就是出队和入队： 所以该接口中的方法可以归为两类： 入队方法 方法 描述 boolean offer(E e); 表示如果可能的话，将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; 可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 void put(E e) throws InterruptedException; 把anObject加到BlockingQueue里，如果BlockQueue没有空间，则调用此方法的线程被阻断，直到BlockingQueue里面有空间再继续。 　　　　 出队方法 方法 描述 E poll(long timeout, TimeUnit unit)throws InterruptedException; 从BlockingQueue取出一个队首的对象，如果在指定时间内，　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。 E take() throws InterruptedException; 取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入; int drainTo(Collection c); 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 这四类方法的特点是： ThrowsException：如果操作不能马上进行，则抛出异常 SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false Blocks：如果操作不能马上进行，操作会被阻塞 TimesOut：如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false BlockingQueue的实现主要有这么几类： ArrayBlockingQueue DelayQueue LinkedBlockingQueue PriorityBlockingQueue SynchronousQueue 生产者-消费者 下面是注解中给出的利用BlockingQueue实现的生产者-消费者的实现： class Producer implements Runnable { private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 10:32:43 "},"源码解读/java.util/java.util.concurrent/ArrayBlockingQueue.html":{"url":"源码解读/java.util/java.util.concurrent/ArrayBlockingQueue.html","title":"ArrayBlockingQueue","keywords":"","body":"ArrayBlockingQueue ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。它先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部 构造函数 /** Condition for waiting puts */ private final Condition notFull; /** Condition for waiting takes */ private final Condition notEmpty; /** Main lock guarding all access */ final ReentrantLock lock; /** The queued items */ final Object[] items; public ArrayBlockingQueue(int capacity) { this(capacity, false); } public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity c) { this(capacity, fair); final ReentrantLock lock = this.lock; lock.lock(); // Lock only for visibility, not mutual exclusion try { int i = 0; try { for (E e : c) { checkNotNull(e); items[i++] = e; } } catch (ArrayIndexOutOfBoundsException ex) { throw new IllegalArgumentException(); } count = i; putIndex = (i == capacity) ? 0 : i; } finally { lock.unlock(); } } offer方法 /** items index for next put, offer, or add */ int putIndex; //指向下一次入队元素的位置 /** Number of elements in the queue */ int count; public boolean offer(E e) { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try { if (count == items.length) return false; else { enqueue(e); return true; } } finally { lock.unlock(); } } public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) { if (nanos put方法 public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); enqueue(e); } finally { lock.unlock(); } } poll方法 /** * Shared state for currently active iterators, or null if there * are known not to be any. Allows queue operations to update * iterator state. */ transient Itrs itrs = null; /** items index for next take, poll, peek or remove */ int takeIndex; public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(\"unchecked\") E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x; } public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) { if (nanos take方法 public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); return dequeue(); } finally { lock.unlock(); } } peek public E peek() { final ReentrantLock lock = this.lock; lock.lock(); try { return itemAt(takeIndex); // null when queue is empty } finally { lock.unlock(); } } final E itemAt(int i) { return (E) items[i]; } remove public boolean remove(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { if (count > 0) { final int putIndex = this.putIndex; int i = takeIndex; do { if (o.equals(items[i])) { removeAt(i); return true; } if (++i == items.length) i = 0; } while (i != putIndex); } return false; } finally { lock.unlock(); } } drainTo public int drainTo(Collection c) { return drainTo(c, Integer.MAX_VALUE); } public int drainTo(Collection c, int maxElements) { checkNotNull(c); if (c == this) throw new IllegalArgumentException(); if (maxElements 0) { count -= i; takeIndex = take; if (itrs != null) { if (count == 0) itrs.queueIsEmpty(); else if (i > take) itrs.takeIndexWrapped(); } for (; i > 0 && lock.hasWaiters(notFull); i--) notFull.signal(); } } } finally { lock.unlock(); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 00:11:53 "},"源码解读/java.util/java.util.concurrent/LinkedBlockingQueue.html":{"url":"源码解读/java.util/java.util.concurrent/LinkedBlockingQueue.html","title":"LinkedBlockingQueue","keywords":"","body":"LinkedBlockingQueue 基本上看到属性就能明白这是怎么回事了： private final int capacity; private final AtomicInteger count; transient LinkedBlockingQueue.Node head; private transient LinkedBlockingQueue.Node last; private final ReentrantLock takeLock; private final Condition notEmpty; private final ReentrantLock putLock; private final Condition notFull; 构造方法 public LinkedBlockingQueue() { this(2147483647); } public LinkedBlockingQueue(int var1) { this.count = new AtomicInteger(); this.takeLock = new ReentrantLock(); this.notEmpty = this.takeLock.newCondition(); this.putLock = new ReentrantLock(); this.notFull = this.putLock.newCondition(); if (var1 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 00:23:05 "},"源码解读/java.util/java.util.concurrent/SynchronousBlockingQueue.html":{"url":"源码解读/java.util/java.util.concurrent/SynchronousBlockingQueue.html","title":"SynchronousBlockingQueue","keywords":"","body":"SynchronousBlockingQueue 特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。 /** * Adds the specified element to this queue, waiting if necessary for * another thread to receive it. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); if (transferer.transfer(e, false, 0) == null) { Thread.interrupted(); throw new InterruptedException(); } } /** * Retrieves and removes the head of this queue, waiting if necessary * for another thread to insert it. * * @return the head of this queue * @throws InterruptedException {@inheritDoc} */ public E take() throws InterruptedException { E e = transferer.transfer(null, false, 0); if (e != null) return e; Thread.interrupted(); throw new InterruptedException(); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 00:22:48 "},"源码解读/java.util/java.util.concurrent/Executors.html":{"url":"源码解读/java.util/java.util.concurrent/Executors.html","title":"Executors","keywords":"","body":"Executors Executor和Executors又是相差一个字符s，想到之前也有三对同样的命名：Array和Arrays、Collection和Collections、Object和Objects（这三对在之前说了说了很多遍了，今天终于来了新成员）。 Executor是一个接口，实际上是一个执行器，而Executors是一个工具类，专门为执行器提供服务的。所以里面有很多的静态方法，结果如下图所示： 这个类非常重要，因为它提供了生成线程池的一些常用方法。 public class Executors 类声明，很干净，因为它只是一个工具类，所以不存在任何的继承和实现。 构造函数 和大部分的工具类一样，Executors是不能实例化的，所以就将其构造函数私有化。略。 关于ExecutorService的支持 Executors是一个工厂类，生产的是各类的线程池。它们可能在容量、等待时间、阻塞队列选择、抛弃策略上的选择有所不同。实际上，创建它们的方法很简单，就是调用了ThreadPoolExecutor的不同的构造函数，赋予了不同的参数而已。下面来看看有哪些不同的线程池。 newFixedThreadPool newFixedThreadPool的目的是创建一个可重用固定线程数的线程池,以共享的无界队列方式来运行这些线程。有两个重定向方法。 /** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * {@code nThreads} threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly {@link ExecutorService#shutdown shutdown}. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if {@code nThreads ()); } /** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue, using the provided * ThreadFactory to create new threads when needed. At any point, * at most {@code nThreads} threads will be active processing * tasks. If additional tasks are submitted when all threads are * active, they will wait in the queue until a thread is * available. If any thread terminates due to a failure during * execution prior to shutdown, a new one will take its place if * needed to execute subsequent tasks. The threads in the pool will * exist until it is explicitly {@link ExecutorService#shutdown * shutdown}. * * @param nThreads the number of threads in the pool * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null * @throws IllegalArgumentException if {@code nThreads (), threadFactory); } 后面一个方法比前一个方法多了一个ThreadFactory参数的指定，其他都一样。 总的来说，newFixedThreadPool的参数如下： 参数 默认值 corePoolSize 自定义，nThreads maximumPoolSize 自定义，和corePoolSize保持一致 keepAliveTime 0 wordQueue 类型 LinkedBlockingQueue类型，默认长度为Integer.MAX_VALUE，是无界队列 threadFactory 默认的defaultFactory或者自定义 handler 默认AbortPolicy 对于newFixedThreadPool，有几个常见的问题： 为什么要将corePoolSize和maximumPoolSize设置成一样？ 因为newFixedThreadPool中用的是LinkedBlockingQueue（是无界队列），只要当前线程大于等于corePoolSize来的任务就直接加入到无界队列中，所以线程数不会超过corePoolSize，这样maximumPoolSize 没有用。例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 为什么队列使用LinkedBlockingQueue? 设置的corePoolSize和maximumPoolSize相同，则创建的线程池是大小固定的，要保证线程池大小固定则需要LinkedBlockingQueue（无界队列）来保证来的任务能够放到任务队列中，不至于触发拒绝策略。 为什么keepAliveTime会设置成0？因为corePoolSize和maximumPoolSize一样大，KeepAliveTime设置的时间会失效，所以设置为0。 FixedThreadPool的优点是能够保证所有的任务都被执行，永远不会拒绝新的任务；同时缺点是队列数量没有限制，在任务执行时间无限延长的这种极端情况下会造成内存问题。 newCachedThreadPool newCachedThreadPool创建了可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 /** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to {@code execute} will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using {@link ThreadPoolExecutor} constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } /** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available, and uses the provided * ThreadFactory to create new threads when needed. * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null */ public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue(), threadFactory); } 后面的方法比前面多了指定ThreadFactory参数的功能，其他都一样。 总的来说，newCachedThreadPool创建的线程池的参数如下： 参数 默认值 corePoolSize 0 maximumPoolSize Integer.MAX_VALUE keepAliveTime 60分钟 workQueue SynchronousQueue类型，默认大小是1 threadFactory 默认的defaultFactory或者自定义 handler 默认AbortPolicy 可以看到，由于corePoolSize为0，所以每次新的新任务到来的时候，总是先缓存到阻塞队伍中。而这个组设队伍是SynchronousQueue类型，这个队列类型非常特殊，是因为队列只能存储1个元素，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样，消费者移除数据操作必须等待生产者的插入。这个队列用于那些有依赖的线程，比如A线程必须在B线程之前进行，那么A作为生产者，B作为消费者。B将入队。而maximumPoolSize的大小是无限的，所以这就是为什么说newCachedThreadPool创建“缓存”线程池，可正式如此，CachedTheadPool对于对任务的处理策略是提交的任务会立即分配一个线程进行执行，线程池中线程数量会随着任务数的变化自动扩张和缩减，在任务执行时间无限延长的极端情况下会创建过多的线程。 同样，关于newCachedThreadPool也有一些问题： 为什么要将corePoolSize设置成0？ 答:因为队列使用SynchronousQueue，队列中只能存放一个任务，保证所有任务会先入队列，用于那些互相依赖的线程，比如线程A必须在线程B之前先执行。 队列使用SynchronousQueue？ 答：线程数会随着任务数量变化自动扩张和缩减，可以灵活回收空闲线程，用SynchronousQueue队列整好保证了CachedTheadPool的特点。 newSingleThreadExecutor /** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * {@code newFixedThreadPool(1)} the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } /** * Creates an Executor that uses a single worker thread operating * off an unbounded queue, and uses the provided ThreadFactory to * create a new thread when needed. Unlike the otherwise * equivalent {@code newFixedThreadPool(1, threadFactory)} the * returned executor is guaranteed not to be reconfigurable to use * additional threads. * * @param threadFactory the factory to use when creating new * threads * * @return the newly created single-threaded Executor * @throws NullPointerException if threadFactory is null */ public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), threadFactory)); } 总的来说newSingleThreadExecutor的参数设置如下： 参数 默认值 corePoolSize 1 maximumPoolSize 1 keepAliveTime 0 workQueue LinkedBlockingQueue， 长度默认为Integer.MAX_VALUE threadFactory 默认的defaultFactory或者自定义 handler 默认AbortPolicy 可见SingleThreadExecutor的线程池固定大小为1，任务队列无界限。特别注意的是，这里用FinalizableDelegatedExecutorService对ThreadPoolExecutor进行了包装，这个类定义如下： static class FinalizableDelegatedExecutorService extends DelegatedExecutorService { FinalizableDelegatedExecutorService(ExecutorService executor) { super(executor); } protected void finalize() { super.shutdown(); } } static class DelegatedExecutorService extends AbstractExecutorService { private final ExecutorService e; DelegatedExecutorService(ExecutorService executor) { e = executor; } public void execute(Runnable command) { e.execute(command); } public void shutdown() { e.shutdown(); } public List shutdownNow() { return e.shutdownNow(); } public boolean isShutdown() { return e.isShutdown(); } public boolean isTerminated() { return e.isTerminated(); } public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { return e.awaitTermination(timeout, unit); } public Future submit(Runnable task) { return e.submit(task); } public Future submit(Callable task) { return e.submit(task); } public Future submit(Runnable task, T result) { return e.submit(task, result); } public List> invokeAll(Collection> tasks) throws InterruptedException { return e.invokeAll(tasks); } public List> invokeAll(Collection> tasks, long timeout, TimeUnit unit) throws InterruptedException { return e.invokeAll(tasks, timeout, unit); } public T invokeAny(Collection> tasks) throws InterruptedException, ExecutionException { return e.invokeAny(tasks); } public T invokeAny(Collection> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return e.invokeAny(tasks, timeout, unit); } } 那么SingleThreadExecutor为什么要用FinalizableDelegatedExecutorService对ThreadPoolExecutor进行包装呢？ 因为SingleThreadExecutor是单线程化线程池，用DelegatedExecutorService包装为了屏蔽ThreadPoolExecutor动态修改线程数量的功能，仅保留Executor中的方法。 SingleThreadExecutor 适用于在逻辑上需要单线程处理任务的场景，同时无界的LinkedBlockingQueue保证新任务都能够放入队列，不会被拒绝；缺点和FixedThreadPool相同，当处理任务无限等待的时候会造成内存问题。 newScheduledThreadPool 创建定时任务线线程池： /** * Creates a thread pool that can schedule commands to run after a * given delay, or to execute periodically. * @param corePoolSize the number of threads to keep in the pool, * even if they are idle * @return a newly created scheduled thread pool * @throws IllegalArgumentException if {@code corePoolSize newWorkStealingPool /** * Creates a thread pool that maintains enough threads to support * the given parallelism level, and may use multiple queues to * reduce contention. The parallelism level corresponds to the * maximum number of threads actively engaged in, or available to * engage in, task processing. The actual number of threads may * grow and shrink dynamically. A work-stealing pool makes no * guarantees about the order in which submitted tasks are * executed. * * @param parallelism the targeted parallelism level * @return the newly created thread pool * @throws IllegalArgumentException if {@code parallelism 线程池的大小选择问题 如何去选择线程池？线程池应该设置多大？没有固定的答案，只有适合的答案 关于线程池大小问题，可以参考这个公式，仅仅是参考而已。启动线程数 = [ 任务执行时间 / ( 任务执行时间 - IO等待时间 ) ] x CPU内核数 计算示例可以参考 https://www.cnblogs.com/waytobestcoder/p/5323130.html 在控制线程池大小的基础上，尽量使用有界队列并且设置大小，避免OOM。 设置合理的驳回策略，适用于你的业务。 关于ThreadFactory的支持 ThreadFactory是函数式接口，顾名思义，是“线程工厂”，使用了工厂创建的设计模式，一般配合线程池使用。主要用来控制创建新线程时的一些行为，比如设置线程的优先级，名字等等。 接口定义如下： public interface ThreadFactory { /** * Constructs a new {@code Thread}. Implementations may also initialize * priority, name, daemon status, {@code ThreadGroup}, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or {@code null} if the request to * create a thread is rejected */ Thread newThread(Runnable r); } 就是用来创建线程的。该接口的实现类都散落在不同的类中，如下： DefaultThreadFactory 在Executes中定义了一个ThreadFactory的直接实现类DefaultThreadFactory： /** * The default thread factory */ static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; } public Thread newThread(Runnable r) { Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; } } DefaultThreadFactory创建的线程的名字采用下面的格式 pool-[线程池编号]-thread-[该线程池的线程编号] 然后优先级为Thread.NORM_PRIORITY。 PrivilegedThreadFactory 在Executors中，还定义了一个DefaultThreadFactory的子类PrivilegedThreadFactory，用于返回用于创建新线程的线程工厂，这些新线程与当前线程x具有相同的权限。 /** * Thread factory capturing access control context and class loader */ static class PrivilegedThreadFactory extends DefaultThreadFactory { private final AccessControlContext acc; private final ClassLoader ccl; PrivilegedThreadFactory() { super(); SecurityManager sm = System.getSecurityManager(); if (sm != null) { // Calls to getContextClassLoader from this class // never trigger a security check, but we check // whether our callers have this permission anyways. sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION); // Fail fast sm.checkPermission(new RuntimePermission(\"setContextClassLoader\")); } this.acc = AccessController.getContext(); this.ccl = Thread.currentThread().getContextClassLoader(); } public Thread newThread(final Runnable r) { return super.newThread(new Runnable() { public void run() { AccessController.doPrivileged(new PrivilegedAction() { public Void run() { Thread.currentThread().setContextClassLoader(ccl); r.run(); return null; } }, acc); } }); } } 从源码看出，PrivilegedThreadFactory extends DefaultThreadFactory从而具有与 defaultThreadFactory() 相同设置的线程。但增加了两个特性：ClassLoader和AccessControlContext，从而使运行在此类线程中的任务具有与当前线程相同的访问控制和类加载器。 关于Callable的支持 callable 重载了多个方法 // 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。callable(task)等价于callable(task, \bnull)。 public static Callable callable(Runnable task, T result) { if (task == null) throw new NullPointerException(); return new RunnableAdapter(task, result); } // RunnableAdapter类 /** * A callable that runs given task and returns given result */ static final class RunnableAdapter implements Callable { final Runnable task; final T result; RunnableAdapter(Runnable task, T result) { this.task = task; this.result = result; } public T call() { task.run(); return result; } } // 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。 // callable(PrivilegedExceptionAction action)和其类似，唯一的区别在于，前者可抛出异常。 public static Callable callable(final PrivilegedAction action) { if (action == null) throw new NullPointerException(); return new Callable() { public Object call() { return action.run(); }}; } //PrivilegedAction接口 public interface PrivilegedAction { T run(); } privilegedCallable // 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。 Callable privilegedCallable(Callable callable) privilegedCallableUsingCurrentClassLoader // 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。 Callable privilegedCallableUsingCurrentClassLoader(Callable callable) 参考 对线程池简单理解 再聊线程池 多线程之线程池newFixedThreadPool（二） java定时任务接口ScheduledExecutorService ThreadPoolExecutor线程池参数设置技巧 理解ThreadPoolExecutor源码(一)线程池的corePoolSize、maximumPoolSize和poolSize 深入理解java线程池—ThreadPoolExecutor ExecutorService引发的血案（二）ExecutorService使用 Java线程池 ExecutorService Java线程池ExecutorService Java并发包学习三ThreadFactory介绍 Java线程(\b\b五)：Executors、ThreadFactory Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 10:53:11 "},"源码解读/java.util/java.util.concurrent/ScheduledThreadPollExecutor.html":{"url":"源码解读/java.util/java.util.concurrent/ScheduledThreadPollExecutor.html","title":"ScheduledThreadPollExecutor","keywords":"","body":"ScheduledThreadPollExecutor ScheduledThreadPollExecutor继承自ThreadPoolExecutor，并实现了ScheduledExecutorService接口。 从名字就能看出来，这个类与定时相关。 定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。 需要注意,只有当调度任务来的时候，ScheduledExecutorService才会真正启动一个线程,其余时间ScheduledExecutorService都是出于轮询任务的状态 类的结构如下： Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 11:46:42 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.atomic/java.util.concurrent.atomic.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.atomic/java.util.concurrent.atomic.html","title":"java.util.concurrent.atomic","keywords":"","body":"java.util.concurrent.atomic 这个包是JUC的子包，里面提供了一组原子变量类。 其基本的也正是在多线程的环境下，当有多个线程同时执行这些类的实例包含的方法时候，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就行自旋锁一样，一直等到该方法执行完成，才有JVM等待队列中选择一个另一个线程进入。这是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程（或者说只是在硬件级别上阻塞了）。可以对基本数据、数组中的基本数据、对类中的基本数据进行操作。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-该-写操作。 这个包的组成结构如下： 大致可以分为四组： 分组 意义 包含的类 标量类(Scalar) 用来处理布尔、整数、长整数、对象四种数据，其内部实现不是简单的使用synchronized，而是使用CAS + volatile和native方法，从而避免了synchronized的高开销，执行效率大大为提升 AtomicBoolean、 AtomicInteger、AtomicLong和AtomicReference 数组类 进一步扩展了原子操作，对数组提供了支持，它们内部并不是向AtomicInteger一样维持一个valatile变量，而是全部由native方法实现 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 更新器类 基于反射，对指令类的volatile字段进行原子更新 AtomicLongFieldUpdater 、AtomicIntegerFieldUpdater 、AtomicReferenceFieldUpdater 复合标量类 防止ABA问题出现而构造的类。如什么是ABA问题呢，当某些流程在处理过程中是顺向的，也就是不允许重复处理的情况下，在某些情况下导致一个数据由A变成B，再中间可能经过0-N个环节后变成了A，此时A不允许再变成B了，因为此时的状态已经发生了改变，他们都是对atomicReference的进一步包装，AtomicMarkableReference和AtomicStampedReference功能差不多，有点区别的是：它描述更加简单的是与否的关系，通常ABA问题只有两种状态，而AtomicStampedReference是多种状态，那么为什么还要有AtomicMarkableReference呢，因为它在处理是与否上面更加具有可读性。 AtomicMarkableReference 、AtomicStampedReference 参考 java.util.concurrent包详细分析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-20 16:27:10 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.atomic/AtomicReference.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.atomic/AtomicReference.html","title":"AtomicReference","keywords":"","body":"AtomicReference 提供了引用变量的读写原子性操作。 什么叫提供原子性的操作呢？原子性是指同一个时间这个对象只能被一个线程操作，这叫原子性，那为什么说AtomicReference提供了原子性的操作呢？我们可以从源码中看到，这里面的所有方法，实际上调用的都是sun.misc.Unsafe类中的方法，而这个类中所有的方法都是native方法，应该和OS的硬件相关，从源码中我们并不知道怎么实现的。只要记住这是原子性的操作。 构造函数 private volatile V value; /** * Creates a new AtomicReference with the given initial value. * * @param initialValue the initial value */ public AtomicReference(V initialValue) { value = initialValue; } /** * Creates a new AtomicReference with null initial value. */ public AtomicReference() { } get方法 用来返回当前的引用。 /** * Gets the current value. * * @return the current value */ public final V get() { return value; } public final boolean compareAndSet(V expect, V update) {..} 如果当前值与给定的expect相等，（注意是引用相等而不是equals()相等），更新为指定的update值。 public final boolean compareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } private static final Unsafe unsafe = Unsafe.getUnsafe(); public final V getAndSet(V newValue){..} 原子地设为给定值并返回旧值。 public final V getAndSet(V newValue) { return (V)unsafe.getAndSetObject(this, valueOffset, newValue); } public final void set(V newValue) {..} 给当前值设定新值。注意这个方法不是原子地。 public final void set(V newValue) { value = newValue; } 使用 根据上面的操作，似乎有这样一种感觉，AtomicReference似乎起到了和“锁”类似的作用。我们看下面一个例子： 假设有一个类 Person，定义如下： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \"[name: \" + this.name + \", age: \" + this.age + \"]\"; } } 如果使用普通对象引用，那么在多线程环境下，对此对象的更新可能会导致不一样的结果，即存在同步问题。这个问题我们可以利用锁机制来解决。而另一个解决办法是利用原子对象引用AtomicReference来保证多线程环境下对象更新操作的一致性。 //普通引用 private static Person person; //原子性引用 private static AtomicReference aPerson; public static void main(String[] args){ person = new Person(\"Tom\", 18); aPerson = new AtomicReference(person); System.out.println(\"Atomic Person is \" + aPerson.get().toString()); Thread t1 = new Thread(new Task1()); Thread t1 = new Thread(new Task1()); Thread t2 = new Thread(new Task2()); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Now Atomic Person is \" + aRperson.get().toString()); } static class Task1 implements Runnable { public void run() { aRperson.getAndSet(new Person(\"Tom1\", aRperson.get().getAge() + 1)); System.out.println(\"Thread1 Atomic References \" + aRperson.get().toString()); } } static class Task2 implements Runnable { public void run() { aRperson.getAndSet(new Person(\"Tom2\", aRperson.get().getAge() + 2)); System.out.println(\"Thread2 Atomic References \" + aRperson.get().toString()); } } 以上程序的输出结果可能是： Atomic Person is [name: Tom, age: 18] Thread1 Atomic References [name: Tom1, age: 19] Thread2 Atomic References [name: Tom2, age: 21] Now Atomic Person is [name: Tom2, age: 21] 参考 AtomicReference 原子引用 Java 原子性引用 AtomicReference Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 17:50:41 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/java.util.concurrent.locks.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/java.util.concurrent.locks.html","title":"java.util.concurrent.locks","keywords":"","body":"java.util.concurrent.locks 这个包中的接口和类提供了一个框架，用于锁定和等待与内置同步和监视器不同的条件。该框架允许在使用Lock和Condition方面具有更大的灵活性的语法。 主要的接口 接口 功能 Lock 锁，比synchronized提供更广泛的线程操作 Condition 进程间通信 ReadWriteLock 维护一对关联的锁，一个用来读，一个用来写 主要的类： 类名 功能 AbstractOwnableSynchronizer AbstractQueuedLongSynchronizer AbstractQueuedSynchronizer JUC包的核心，最重要的基础设施类之一 LockSupport 线程阻塞和唤醒原语 ReentrantLock 可重入锁 ReentrantReadWriteLock 可重入的读写锁 ReentrantReadWriteLock.ReadLock 可重入的读写锁中的读锁 ReentrantReadWriteLock.WriteLock 可重入的读写锁中的写锁 StampedLock Lock接口支持在语义（可重入，公平等）方面不同的锁定规则，并且可以在非块结构的上下文中使用，包括手工和锁重新排序算法。主要实现是ReentrantLock。 ReadWriteLock接口类似地定义了可能在读者之间共享的锁，但是对作者是排他性的。只提供了一个实现ReentrantReadWriteLock，因为它涵盖了大多数标准的使用上下文。但程序员可能会创建自己的实现来覆盖非标准要求。 Condition接口描述可能与锁相关联的条件变量。这些使用方式与使用Object.wait访问的隐式监视器相似，但提供扩展功能。特别地，多个条件对象可以与单个锁相关联。为了避免兼容性问题，条件方法的名称与对应的对象版本不同。 AbstractQueuedSynchronizer类作为一个有用的超类，用于定义依赖排队阻塞线程的锁和其他同步器。 AbstractQueuedLongSynchronizer类提供相同的功能，但扩展了对64位同步状态的支持。两者都扩展了AbstractOwnableSynchronizer类，一个简单的类，可以帮助记录当前持有排他同步的线程。 LockSupport类提供了较低级别的阻止和解除阻塞支持，对于那些开发自己的定制锁类的开发人员来说，这是非常有用的 Java 8 API https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-21 18:26:35 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/AbstractQueuedSynchronizer.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/AbstractQueuedSynchronizer.html","title":"AbstractQueuedSynchronizer","keywords":"","body":"AbstractQueuedSynchronizer AQS是干什么的？总结成一句话： AQS利用CAS原子操作维护自身的状态，结合LockSupport对线程进行阻塞和唤醒从而实现更为灵活的同步操作。 AbstractQueuedSynchronizer翻译过来就是“抽象队列同步器”，它定义了一套多线程访问共同资源的同步器框架，之后的很多同步实现类都依赖于它，比如ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch等等。可以说，AbstractQueuedSynchronizer，简称AQS，是整个java.util.concurrent的核心。 其结构如下： 框架 该类维护了一个共享资源和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），下面这个图可以用来描述这个关系： AQS里面的CLH队列是CLH同步锁的一种变形。其主要从两方面进行了改造：节点的结构与节点等待机制。在结构上引入了头结点和尾节点，他们分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关，并且每个节点都引入前驱节点和后后续节点的引用；在等待机制上由原来的自旋改成阻塞唤醒。其结构如下 如图中所示，该类用一个变量volatile int state来表示这个被争用的资源，队头和队尾由两个变量来记录： private transient volatile Node head; private transient volatile Node tail; 而其中数据结构Node实际上是对Thread的一个包装，其定义如下： static final class Node { /** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node(); /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ /** 因为超时或者中断，结点会被设置为取消状态，被取消状态的结点不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态。处于这种状态的结点会被踢出队列，被GC回收 */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ /** 表示这个结点的继任结点被阻塞了，到时需要通知它 */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ /** 表示这个结点在条件队列中，因为等待某个条件而被阻塞 */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ /**使用在共享模式头结点有可能牌处于这种状态，表示锁的下一次获取可以无条件传播*/ static final int PROPAGATE = -3; /*当前node对象的等待状态，注意该状态并不是描述当前对象而是描述下一个节点的状态， * 从而来决定是否唤醒下一个节点，该节点总共有四个取值： * a. CANCELLED = 1：因为超时或者中断，结点会被设置为取消状态，被取消状态的结点不应该去竞争锁， * 只能保持取消状态不变，不能转换为其他状态。处于这种状态的结点会被踢出队列，被GC回收； * b. SIGNAL = -1：表示这个结点的继任结点被阻塞了，到时需要通知它； * c. CONDITION = -2：表示这个结点在条件队列中，因为等待某个条件而被阻塞； * d. PROPAGATE = -3：使用在共享模式头结点有可能牌处于这种状态，表示锁的下一次获取可以无条件传播； * e. 0： None of the above，新结点会处于这种状态。 * * 非负值标识节点不需要被通知（唤醒）。 */ volatile int waitStatus; //当前节点的上一个节点，如果是头节点那么值为null volatile Node prev; //当前节点的下一个节点 volatile Node next; //与Node绑定的线程对象 volatile Thread thread; //下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。 Node nextWaiter; /** * Returns true if node is waiting in shared mode. */ final boolean isShared() { return nextWaiter == SHARED; } /** * Returns previous node, or throws NullPointerException if null. * Use when predecessor cannot be null. The null check could * be elided, but is present to help the VM. * * @return the predecessor of this node */ final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } 另外从图中可以看到，这个队列叫做“CLH队列”。\"CLH\"即“Craig, Landin, and Hagersten locks”，即自旋锁，什么是自旋锁？自旋锁采用让当前线程不停地的在循环体内执行实现，当循环的条件被其他线程改变时 才能进入临界区。关于自旋锁的更多内容参见各类锁的辨析。 对于共享资源，就是这个state，AQS定义三种访问方式——getState、setState和compareAndSetState。 对于共享资源的占用方式，该类定义了两种方式： Exclusive，即独占式的，每次只能有一个线程能够执行。实现这种方式的锁例如ReentrantLock。 Share，即共享式的，多个线程能够同时执行。实现这种方式的锁例如Semaphore、CountDownLatch。 AQS是最基础的锁的框架定义，具体的同步争用器实现争用方式是不同的，它们借在AQS的线程等待队列的维护功能（如获取资源失败入队/唤醒出队等）基础上，只需实现各自的共享资源state获取和释放功能的实现，也就是实现了各具特色的锁。 自定义的同步争用器主要需要实现以下几种方法： 方法名 作用 isHeldExclusively() 该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int) 独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int) 独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int) 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int) 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 例如ReentrantLock，以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state + 1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state = 0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 例如CountDownLatch，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state = 0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 以上大概就是AQS对于JUC所作的贡献了，它之所以重要，就是提供了一个最基础、也是最重要的线程等待队列。 下面就从源码角度来分析一下AQS对于线程等待队列的实现。 public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable 类声明，这是一个抽象类，继承的抽象类AbstractOWnableSynchronizer类也是JUC中的一个重要的类，从名字就可以看出，“拥有某个锁的同步器”，其实就是排他锁。类结构如下： protected AbstractQueuedSynchronizer() { } 只有一个构造方法，且私有。那么如何初始化呢？这种与底层实现息息相关的类，一定不能让开发人员随便构造的，那么JVM总得初始化吧，如果实现？静态初始块。 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; private static final long headOffset; private static final long tailOffset; private static final long waitStatusOffset; private static final long nextOffset; static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\")); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\")); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\")); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\"waitStatus\")); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\"next\")); } catch (Exception ex) { throw new Error(ex); } } private transient volatile Node head; private transient volatile Node tail; private volatile int state; 这里进行了初始化的操作，Unsafe这个类封装了CAS的操作，是用本地方法实现的，我们不用去管到底如何实现。总之，它获取到了共享资源state、共享队列的头head和共享队列的尾tail，第一个等待节点和其后一个节点的地址，就此完成了初始化工作。 public final void acquire(int arg){...} 这个方法是独占模式下，线程获取共享资源的顶层入口，如果线程获取到了锁，那么线程直接返回，否则进入等待队列，直到获取到资源。整个过程忽略中断的影响，源码如下： public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 它的执行过程分为以下四个步骤： tryAcquire()：尝试直接去获取资源，如果成功则直接返回； addWaiter()：将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued()：使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 下面就每个过程进行具体的讲解： tryAcquire(int) 此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码： protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 诶？？？说好的获取资源呢？为什么抛出异常了？好吧，之前说到过，AQS只是一个框架，具体的实现还是依赖了具体的同步器的实现，这里只是提供了一个接口而已。诶，那为什么不用抽象方法？那是因为这只是独占模式下的实现，而共享模式下不用实现这个方法，如果写成抽象方法，那么采取共享模式的同步器也必须实现这个方法，这是不合理的。 addWaiter(Node) 这个方法是将当前线程加入到等待队伍的队尾，并且返回当前线程所在的节点。 //获取锁失败后，将其包装成节点 //1. 尝试将新节点以最快的方式设置为尾节点，如果CAS设置尾节点成功，返回附加着当前线程的节点。 // 2. 如果CAS操作失败，则调用enq方法，循环入队直到成功。 private Node addWaiter(Node mode) { //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享） Node node = new Node(Thread.currentThread(), mode); //尝试快速方式直接放到队尾。 Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } //上一步失败则通过enq入队。 enq(node); return node; } 其中enq方法定义如下： //循环插入队尾直到CAS成功。 private Node enq(final Node node) { //CAS\"自旋\"，直到成功加入队尾 for (;;) { Node t = tail; if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。 if (compareAndSetHead(new Node())) tail = head; } else {//正常流程，放入队尾 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。 acquireQueued(Node, int) OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，但是节点插入队尾后不会直接挂起，因为可能在插入的时候占有锁的线程已经运行结束了，所以会通过自旋进行锁的竞争。 那么下一步的工作是：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧： //自旋获取锁，直至异常退出或获取锁成功，但是并不是busy acquire，因为当获取失败后会被挂起，由前驱节点释放锁时将其唤醒。 //同时由于唤醒的时候可能有其他线程竞争，所以还需要进行尝试获取锁，体现的非公平锁的精髓。 final boolean acquireQueued(final Node node, int arg) { boolean failed = true;//标记是否成功拿到资源 try { boolean interrupted = false;//标记等待过程中是否被中断过 //又是一个“自旋”！ for (;;) { final Node p = node.predecessor();//拿到前驱 //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。 if (p == head && tryAcquire(arg)) {////如果node的前驱节点是head节点，尝试获取锁，如果获取锁成功，说明head节点已经释放锁了，将node设为head开始运行。 setHead(node); setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。 p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！ failed = false; return interrupted;//返回等待过程中是否被中断过 } //如果自己可以休息了，就进入waiting状态，直到被unpark() if (shouldParkAfterFailedAcquire(p, node) && //判断当前node在获取锁失败后是否可以挂起，通过pred的状态判断 parkAndCheckInterrupt())////挂起线程，等待node的前驱节点唤醒。 interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true } } finally {//中间出现异常，导致获取锁失败，取消当前锁的自旋尝试获取锁 if (failed) cancelAcquire(node); } } 其中shouldParkAfterFailedAcquire这个方法主要用于检查状态，看看自己是否真的可以去休息了，即进入waiting状态，源码如下： //更新前驱节点的状态，是否可以挂起当前获取锁失败的节点。 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus;//拿到前驱的状态 if (ws == Node.SIGNAL) //pred节点的状态为signal，说明node无法获取锁，可以安全挂起。 return true; if (ws > 0) { /* * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。 * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！ */ do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { compareAndSetWaitStatus(pred, ws, Node.SIGNAL);//将前驱节点的状态设置为SIGNAL，代表node需要被运行。 //更新可能失败，所以也不能够直接返回true。 } return false; } 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。 另外parkAndCheckInterrupt()方法的意思是如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。源码如下： //挂起线程 private final boolean parkAndCheckInterrupt() { LockSupport.park(this);//调用park()使线程进入waiting状态 return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。 } park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。 现在重新回到acquireQueued()方法，总结下该函数的具体流程： 结点进入队尾后，检查状态，找到安全休息点； 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己； 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。 现在再重新回到acquire()方法，总结下流程： 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回； 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 这个方法非常重要，用下面这张图可以总结一下： public final boolean release(int arg){...} release是acquire的反操作，此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码： public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head;//找到头结点 if (h != null && h.waitStatus != 0) unparkSuccessor(h);//唤醒等待队列里的下一个线程 return true; } return false; } 逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！ 下面同样进行分步讲解： tryRelease(int) 此方法尝试去释放指定量的资源。下面是tryRelease()的源码： protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } 和tryAcquire一样，tryRelease同样需要自定义的同步器去实现，正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了， release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！ 所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。 unparkSuccessor(Node) 此方法用于唤醒等待队列中下一个线程。下面是源码： private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. * * 如果waitStatus小于0，那么将下一个节点设置成头节点 */ int ws = node.waitStatus; if (ws 0) {//如果为空或已取消 s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus 这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head && tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT! 总结一下：release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。 public final void acquireShared(int arg) {...} 此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码： public final void acquireShared(int arg) { if (tryAcquireShared(arg) 这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是： tryAcquireShared()尝试获取资源，成功则直接返回； 失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。 下面进行分步讲解： doAcquireShared(int) 此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED);//加入队列尾部 boolean failed = true;//是否成功标志 try { boolean interrupted = false;//等待过程中是否被中断过的标志 for (;;) { final Node p = node.predecessor();//前驱 if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的 int r = tryAcquireShared(arg);//尝试获取资源 if (r >= 0) {//成功 setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程 p.next = null; // help GC if (interrupted)//如果等待过程中被打断过，此时将中断补上。 selfInterrupt(); failed = false; return; } } //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt() if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。 跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。 setHeadAndPropagate(Node, int)private void setHeadAndPropagate(Node node, int propagate) { Node h = head; setHead(node);//head指向自己 //如果还有剩余量，继续唤醒下一个邻居线程 if (propagate > 0 || h == null || h.waitStatus 此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！doReleaseShared()我们留着下一小节的releaseShared()里来讲。 现在总结一下acquireShared()的流程： tryAcquireShared()尝试获取资源，成功则直接返回； 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。 其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。 public final boolean releaseShared(int arg) {...} 此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码： public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) {//尝试释放资源 doReleaseShared();//唤醒后继结点 return true; } return false; } 此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。 其中doReleaseShared()的方法定义如下： private void doReleaseShared() { for (;;) { Node h = head; if (h != null && h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h);//唤醒后继 } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; } if (h == head)// head发生变化 break; } } 此方法主要用于唤醒后继。 参考 java锁的种类以及辨析（一）：自旋锁 Java并发之AQS详解 关于AQS的一点总结 AbstractQueuedSynchronizer-源码走读 40个Java多线程问题总结 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 10:10:08 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/LockSupport.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/LockSupport.html","title":"LockSupport","keywords":"","body":"LockSupport AQS提供了线程等待队列的操作，其中线程阻塞和唤醒操作是通过LockSupport的静态方法来进行的。实际上，LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。 类结构如下 注意到，该类对外提供的都是静态方法，其中park()和unpark()分别用来阻塞线程和解除阻塞。而且park()和unpark()不会遇到Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 因为park() 和 unpark()有许可的存在；调用park()的线程和另一个试图将其unpark()的线程之间的竞争将保持活性。 而事实上，这些方法都是抵用了Unsafe中的接口来实现阻塞和非阻塞的。比较难以理解，所以这里只需要知道这个API的说明即可。 方法 含义 public static void park() 为了线程调度，禁用当前线程，除非许可可用。 public static void park(Object blocker) 为了线程调度，在许可可用之前禁用当前线程。 public static void unpark(Thread thread) 如果给定线程的许可尚不可用，则使其可用。 public static void parkNanos(long nanos) 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。 public static void parkNanos(Object blocker, long nanos) 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。 public static Object getBlocker(Thread t) 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。 public static void parkUntil(long deadline) 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 public static void parkUntil(Object blocker, long deadline) 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 下面是利用synchronized来进行同步的一段程序： public class WaitTest1 { public static void main(String[] args) { ThreadA ta = new ThreadA(\"ta\"); synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁” try { System.out.println(Thread.currentThread().getName()+\" start ta\"); ta.start(); System.out.println(Thread.currentThread().getName()+\" block\"); // 主线程等待 ta.wait(); System.out.println(Thread.currentThread().getName()+\" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+\" wakup others\"); notify(); // 唤醒“当前对象上的等待线程” } } } } 我们可以利用阻塞原语LockSupport来实现： public class LockSupportTest { private static Thread mainTread; public static void main(String[] args) { Thread ta = new LockSupportTest().new ThreadA(\"test Thread\"); mainTread = Thread.currentThread(); //获得主线程 System.out.println(Thread.currentThread().getName() + \" start thread ta\"); ta.start(); System.out.println(Thread.currentThread().getName() + \" blocked\"); LockSupport.park(mainTread);//当前主线程阻塞 System.out.println(Thread.currentThread().getName() + \" continue\"); } private class ThreadA extends Thread{ public ThreadA(String name){ super(name); } @Override public void run() { System.out.println(Thread.currentThread().getName() + \" wake up other threads\"); LockSupport.unpark(mainTread); } } } 代码运行结果为： main start thread ta main blocked ta wake up other threads main continue 经常会问到park和wait方法有什么不同，两者都是让线程进入等待阻塞，不同的是，wait方法是通过锁来进行同步的，即让线程阻塞之前，必须要获得锁。而park是阻塞原语，是不需要获得锁的。 什么是原语？内核或微核提供核外调用的过程或函数称为原语(primitive)，就理解为一组机器指令。 参考 Java多线程系列--“JUC锁”07之 LockSupport Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 16:50:41 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/Lock.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/Lock.html","title":"Lock","keywords":"","body":"Lock 这个接口及相关实现类是在JDK1.5中加入的。先看下接口： void lock(); 获取锁。 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。 如果该锁被另一个线程持有，则该线程不可被调度（disabled for thread scheduling purposes）（即阻塞状态，CPU不会给该线程分配时间片）直到该线程获取到该锁，并且在获取到锁后，将保持计数设置为1 void lockInterruptibly() throws InterruptedException; 如果当前线程未被中断，则获取锁。 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数器置为1。 如果当前线程已经保持该锁，则将保持计数器加1，并将该方法返回。 如果锁被另一个线程保持，则处于线程调度的目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程一直处于休眠状态： 锁由当前线程获得；或者 其他某个线程中断当前线程。 如果当前线程获得该锁，则将锁保持器置为1. 如果当前线程： 在进入方法时已经设置了该线程的终端状态；或者 在等待获取锁的同时被终端。 则抛出InterruptedException，并且清除当前线程的已终端状态。 在此实现中，因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应普通锁的获取或冲入获取。 抛出：InterruptedException 如果单钱线程已经中断。 boolean tryLock(); 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。 即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的）， 而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公 平性也如此。如果希望遵守此锁的公平设置，则使用tryLock(0, TimeUnit.SECONDS) ，它几乎是等效的（也检测中断）。 如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 如果锁被另一个线程保持，则此方法将立即返回 false 值。 返回：如果锁是自由的并且被当前线程获取，或者当前线程已经保持该锁，则返回 true；否则返回false。 一个典型的使用场景是： Lock lock = ...; if (lock.tryLock()) { try { // manipulate protected state } finally { lock.unlock(); } } else { // perform alternative actions } boolean tryLock(long time, TimeUnit unit) throws InterruptedException; 和无参数的tryLock方法功能相同。但是允许在指定的时间内尝试，拿不到锁的情况下就等待一段时间，超出时间后再返回结果，比较聪明的做法。tryLock()和tryLock(0, TimeUnit.SECONDS)是等效的。 lock、tryLock和lockInterruptibly方法的区别 上面讲了三种Lock接口中获取锁的方式：lock()、lockInterruptibly和tryLock，有什么不同？ lock()：调用后一直阻塞到获得锁，拿不到锁誓不罢休。忽略interrupt。 lockInterruptibly：调用后一直阻塞到获得锁，但是会响应中断，这个方法优先考虑响应中断，而不是响应锁的普通获取或重入获取。 tryLock：立即返回，获得锁就返回true，没有就返回false。 关于线程中断有很多要讲的，这里略过，讲下线程的打扰机制。每个线程都有一个打扰标志，这里分为两种情况： 线程在sleep或wait或join，此时如果别的进程调用此进程的interrupt()方法，此线程会被唤醒并要求处理InterruptedException。具体见ThreadAPI。 如果此线程在运行中，则不会收到提醒。但是线程的“打扰标志”会被设置，可以通过isInterrupted()查看并作出处理。 lockInterruptibly()和上面的第一种情况是一样的，线程在请求lock并且被阻塞的时候，如果被interrupt，则“此线程会被要求处理InterruptedException查看并作出处理”。 void unlock(); 释放锁 Condition newCondition(); 返回绑定到此Lock实例的新Condition实例。 在等待条件之前，锁必须由当前线程保持。 对Condition.await（）的调用将在等待之前将原子地释放锁，并在等待返回之前重新获取锁。 参考： Java中Lock，tryLock，lockInterruptibly有什么区别？ Java中的锁-Lock接口解析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 10:10:50 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/ReentrantLock.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/ReentrantLock.html","title":"ReentrantLock","keywords":"","body":"ReentrantLock 这篇文章讲的最明白： http://blog.csdn.net/pengdandezhi/article/details/67082171 Reentrant这个单词的意思是“可重入”，所以ReentrantLock的意思就是\"可重入锁\"。它允许把锁的实现作为Java类，而不是作为语言的特性来实现。它除了在扩展性上与同步方法和声明的隐式监控锁不同外，在基本行为和语义上都相同。还支持取锁的公平与不公平的选择。 这里提到了两个陌生的概念。 什么是“可重入”？ 可重入的锁即表示该锁能够支持一个线程对资源的重复加锁。实际上synchorinized也支持隐式重入，而对于ReentrantLock而言，对于已经获取到锁的线程，再次调用lock()方法时可以获取锁而不被阻塞。 什么是公平获取锁？什么是不公平获取锁。如果在绝对时间上，先对于锁进行获取请求一定先被满足，那么这个锁就是公平的，反之就是不公平。ReentrantLock可以通过构造函数来控制到底是公平锁还是不公平锁。实际上非公平锁的效率远远大于公平锁。 类结构如下： 一个拥有可重入锁的线程最后成功锁定，但尚未解锁它。当这个锁并没有被其他线程拥有时，一个线程调用锁，将成功的返回请求的这个锁。如果当前线程已经拥有该锁了，该方法会立刻返回。这可以通过isHeldByCurrentThread()和getHoldCount()两个方法检查。 public class ReentrantLock extends Object implements Lock, Serializable 类声明，可以看到类继承Object，实现了Lock接口和Serializable接口。 abstract static class Sync extends AbstractQueuedSynchronizer{..} AQS是整个JUC的核心，对于各种锁的实现来说，他们并不直接继承AQS，而是定义内部类来继承AQS。在学习AQS的时候说到，同步锁的实现实际上只需要重写AQS中的tryAcquire-tryRelease或者tryAcquireShared-tryReleaseShare，具体是那个要看采取独占模式还是共享模式。 Sync就是ReentrantLock中对于AQS的实现，这是一个静态抽象内部类，非常重要。其定义如下： abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 诶？看到这里有一个疑问，这是一个抽象类，不能实例化，那怎么用？并且，没有看到tryAcquire方法？没错，Sync是ReentrantLock中对于AQS的抽象实现，真正的实现是Sync的两个实现类NonfairSync和FairSync，他们分别对应了不公平的锁的获取方式和公平的锁的获取方式。 这里提到了公平锁和非公平锁，什么是公平锁？什么是非公平锁。 公平锁是指在加锁之前，是否有排队等待的线程，优先排队等待的线程，先来先得。 而非公平锁是指加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。 下面是知乎上对于公平锁和非公平锁的一个回答： 基于AQS的锁(比如ReentrantLock)原理大体是这样: 有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status--.锁会记录当前持有的线程。 当A线程拥有锁的时候，status>0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。 如果A线程恰好释放，--status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁。 此时非公平锁实现：C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁，而最终是C抢到了锁。 公平锁：C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁 链接：https://www.zhihu.com/question/36964449/answer/69843172 static final class NonfairSync extends Sync{} 对于AQS独占策略、非公平性的锁的获取，定义如下： static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } 这个实现类中能看到tryAcquire的实现，它覆盖了超父类AQS的tryAcquire方法。 static final class FairSync extends Sync{} 对于Sync的实现，与NonfairSync相反，这是\"公平锁\"的实现，定义如下： static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; final void lock() { acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 可以看到的是，这个采取“公平”的策略，重写了tryAcquire方法， 构造函数 有两个重载的构造函数，无参数的构造方法定义如下： public ReentrantLock() { sync = new NonfairSync(); } private final Sync sync; 可以看到，无参数的构造方法创建的ReenrantLock对象默认采取的是独占的非公平锁。 另外接受一个boolean类型参数的ReenrantLock构造方法，定义如下： public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 这里可进行自定义的创建规则，当参数是true的时候创建的是公平锁。 public void lock{...} 重写了Lock的lock()方法，定义如下： public void lock() { sync.lock(); } public void lockInterruptibly() throws InterruptedException{...} 重写了Lock接口中的方法，定义如下： public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } tryLock方法 重载了两个方法，同样都是依靠sync对象实现的，无参的方法定义如下： public boolean tryLock() { return sync.nonfairTryAcquire(1); } 有参的方法定义如下： public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } public void unlock(){...} public void unlock() { sync.release(1); } public Condition newCondition(){...} public Condition newCondition() { return sync.newCondition(); } ReentrantLock的使用 synchronized隐式获得和释放锁，而ReentrantLock将锁作为了一个Java对象，需要手动获得和手动释放。另外，synchronized都是公平锁，而我们可以在创建ReentrantLock的时候选择锁的公平性。 Lock lock1 = new ReentrantLock(); //默认为不公平锁 Lock lock2 = new ReentrantLock(true); //声明为公平锁，但是效率比不同锁要低 ReentrantLock可以适用于以下适用场景： 防止重入执行（忽略重复触发） Lock lock = new ReentrantLock(); if(lock.tryLock()){ //如果锁已经被lock了，那么立即返回false,达到忽略操作的效果 try{ //操作 }finally{ lock.unlock();//这一步一定不要忘记了！！！ } } 这种方法使用与防止重入执行，比如一个定时任务,第一次定时任务未完成,重复发起了第二次,直接返回flase。再例如用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行。 同步执行，类似于synchronized Lock lock = new ReentrantLock(); lock.lock(); //如果已经被其他资源锁定，那么线程会在这里等待，达到暂停的效果 try{ //操作 }finally{ lock.unlock();//一定不要忘记！！！ } 尝试等待执行 ReentrantLock lock = new ReentrantLock(true); //公平锁 try { if (lock.tryLock(5, TimeUnit.SECONDS)) { //如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行 try { //操作 } finally { lock.unlock(); } } }catch (InterruptedException e) { e.printStackTrace(); //当前线程被中断时(interrupt)，会抛InterruptedException } 这种方法如果发现该操作正在执行,等待一段时间，如果规定时间未得到锁，放弃。防止资源处理不当，线程队列溢出,出现死锁。 可中断锁的同步执行 public ReentrantLockTest{ private static Lock reenT = new ReentrantLock(); //不公平锁 public static void lockInterruptTest(){ try { reenT.lockInterruptibly(); //操作 System.out.println(\"aaaa\"+Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } finally { reenT.unlock(); } } public static void main(String[] args) { //同时启动1000个线程，去进行i++计算，看看实际结果 for (int i = 0; i 对于同步锁，一定要注意的是，要在finally块中手动释放锁！！！如果没有释放，等于是在程序中埋下了一颗定时炸弹。 参考 ReentrantLock实现原理深入探究 ReentrantLock的使用 Java中的公平锁和非公平锁实现详解 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 20:07:37 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/ReentrantReadWriteLock.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/ReentrantReadWriteLock.html","title":"ReentrantReadWriteLock","keywords":"","body":"ReentrantReadWriteLock JUC中各种锁（比如ReentrantLock），基本上都是排他锁，即同一时刻只能有一个线程进行访问，对资源的占有采取的是独占策略。 而读写锁允许同一时刻有多个读线程访问，但是在写线程访问时，其他读线程和写线程都会被阻塞。 所以说，读写锁同时采取了独占策略和分享策略。 在没有读写锁支持的（Java 5 之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键字进行同步），这样做的目的是使读操作都能读取到正确的数据，而不会出现脏读。 改用读写锁实现上述功能，只需要在读操作时获取读锁，而写操作时获取写锁即可，当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。 读写锁维护了一对锁，读锁和写锁，通过锁的分离，使得并发性比一般的排他锁有了很大的提高。ReentrantReadWriteLock就是这样的Java提供的可重入的读写锁。其结果如下： ReentrantReadWriteLock支持如下性能： 公平性：支持非公平（默认）和公平性锁获取方式，前者吞吐量大于后者 锁重入性：其内部的WriteLock可以获取ReadLock，但是反过来ReadLock想要获得WriteLock则永远都不要想。 锁降级： WriteLock可以降级为ReadLock，顺序是：先获得WriteLock再获得ReadLock，然后释放WriteLock，这时候线程将保持Readlock的持有。反过来ReadLock想要升级为WriteLock则不可能，为什么？参上一条。 3.ReadLock可以被多个线程持有并且在作用时排斥任何的WriteLock，而WriteLock则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。 不管是ReadLock还是WriteLock都支持Interrupt，语义与ReentrantLock一致。 WriteLock支持Condition并且与ReentrantLock语义一致，而ReadLock则不能使用Condition，否则抛出UnsupportedOperationException异常。 我们首先了解一下可重入读写锁的基本工作过程。这个过程在博文 http://blog.csdn.net/qyp199312/article/details/70598480 中图文并茂的展示了公平可重入读写锁和非公平可重入读写锁的工作过程，生动形象，可以参考。 我们还是从源码角度看看这些性能是如何实现的。 public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable 类声明，可见ReentrantReadWriteLock实现ReadWriteLock接口，而该接口的结构如下： 接口定义了两个锁，一个读锁，一个写锁。注意，ReentrantReadWriteLock并没有继承Lock类，也没有继承AQS。回想一下ReentrantLock也没有继承Lock类，而是利用内部类实现了AQS。这一点和ReentrantLock一样。 构造方法 ReentrantReadWriteLock提供了两个构造方法。 public ReentrantReadWriteLock() { this(false); } public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } 区别在于前者默认构造的是非公平锁，而后者可指定公平性。和ReentrantLock一样，ReentrantLock中定义了一个抽象内部类Sync，该类继承了AQS抽象类，并且定义了Sync的两个实现类：NonfairSync和FairSync，两者重新定义了tryAcquire和tryRelease方法。 Sync内部抽象类中重要的是tryAcquire方法、tryRelease方法、tryReleaseShare方法、tryReadLock方法和tryWriteLock方法。我们逐个来看一下这些方法的实现： tryAcquire protected final boolean tryAcquire(int acquires) { /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); int c = getState(); int w = exclusiveCount(c); if (c != 0) { // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) > MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); // Reentrant acquire setState(c + acquires); return true; } if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; } 代码开头的注解解释了这个方法的含义： 如果当前写锁非0和读锁非0，并且其拥有者并不是当前的线程，则获取失败。 如果当前锁已经饱和，即已经达到上限了，则获取失败。 否则，如果该线程是可重入获取或队列策略允许，则该线程可以锁定。 如果是这样，更新状态并设置所有者。 tryRelease /* * Note that tryRelease and tryAcquire can be called by * Conditions. So it is possible that their arguments contain * both read and write holds that are all released during a * condition wait and re-established in tryAcquire. */ protected final boolean tryRelease(int releases) { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); setState(nextc); return free; } tryRelease方法用来释放锁。在注释中写到tryRelease和tryAcquire可以被Condition调用。 tryReadLock /** * Performs tryLock for read, enabling barging in both modes. * This is identical in effect to tryAcquireShared except for * lack of calls to readerShouldBlock. */ final boolean tryReadLock() { Thread current = Thread.currentThread(); for (;;) { int c = getState(); if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return false; int r = sharedCount(c); if (r == MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); if (compareAndSetState(c, c + SHARED_UNIT)) { if (r == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; } return true; } } } 尝试获取读锁。 tryWriteLock /** * Performs tryLock for write, enabling barging in both modes. * This is identical in effect to tryAcquire except for lack * of calls to writerShouldBlock. */ final boolean tryWriteLock() { Thread current = Thread.currentThread(); int c = getState(); if (c != 0) { int w = exclusiveCount(c); if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w == MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); } if (!compareAndSetState(c, c + 1)) return false; setExclusiveOwnerThread(current); return true; } 尝试获取写锁。这个很好办了，只有当前没有读锁和写锁都没有被获取，获取写锁是自己，这时候自己才能获取写锁。 另外，由于继承ReadWriteLock，所以ReentrantReadWriteLock必须提供获取读写锁的方法。该类定义分别定义了读锁和写锁两个静态内部类。这两个类都实现了Lock接口。 从源码中可以看到，读写锁采取的默认策略也是非公平。 WriteLock和ReadLock ReentrantReadWriteLock中定义了两个内部类：WriteLock和 ReadLock。这两个类都实现Lock接口，即实现了lock、tryLock和lockInterruptibly等方法，而这些方法中，真正的实现仍旧是Syn中的各种方法。 /** * The lock returned by method {@link ReentrantReadWriteLock#readLock}. */ public static class ReadLock implements Lock, java.io.Serializable { private static final long serialVersionUID = -5992448646407690164L; private final Sync sync; /** * Constructor for use by subclasses * * @param lock the outer lock object * @throws NullPointerException if the lock is null */ protected ReadLock(ReentrantReadWriteLock lock) { sync = lock.sync; } /** * Acquires the read lock. * * Acquires the read lock if the write lock is not held by * another thread and returns immediately. * * If the write lock is held by another thread then * the current thread becomes disabled for thread scheduling * purposes and lies dormant until the read lock has been acquired. */ public void lock() { sync.acquireShared(1); } /** * Acquires the read lock unless the current thread is * {@linkplain Thread#interrupt interrupted}. * * Acquires the read lock if the write lock is not held * by another thread and returns immediately. * * If the write lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of two things happens: * * * * The read lock is acquired by the current thread; or * * Some other thread {@linkplain Thread#interrupt interrupts} * the current thread. * * * * If the current thread: * * * * has its interrupted status set on entry to this method; or * * is {@linkplain Thread#interrupt interrupted} while * acquiring the read lock, * * * * then {@link InterruptedException} is thrown and the current * thread's interrupted status is cleared. * * In this implementation, as this method is an explicit * interruption point, preference is given to responding to * the interrupt over normal or reentrant acquisition of the * lock. * * @throws InterruptedException if the current thread is interrupted */ public void lockInterruptibly() throws InterruptedException { sync.acquireSharedInterruptibly(1); } /** * Acquires the read lock only if the write lock is not held by * another thread at the time of invocation. * * Acquires the read lock if the write lock is not held by * another thread and returns immediately with the value * {@code true}. Even when this lock has been set to use a * fair ordering policy, a call to {@code tryLock()} * will immediately acquire the read lock if it is * available, whether or not other threads are currently * waiting for the read lock. This &quot;barging&quot; behavior * can be useful in certain circumstances, even though it * breaks fairness. If you want to honor the fairness setting * for this lock, then use {@link #tryLock(long, TimeUnit) * tryLock(0, TimeUnit.SECONDS) } which is almost equivalent * (it also detects interruption). * * If the write lock is held by another thread then * this method will return immediately with the value * {@code false}. * * @return {@code true} if the read lock was acquired */ public boolean tryLock() { return sync.tryReadLock(); } /** * Acquires the read lock if the write lock is not held by * another thread within the given waiting time and the * current thread has not been {@linkplain Thread#interrupt * interrupted}. * * Acquires the read lock if the write lock is not held by * another thread and returns immediately with the value * {@code true}. If this lock has been set to use a fair * ordering policy then an available lock will not be * acquired if any other threads are waiting for the * lock. This is in contrast to the {@link #tryLock()} * method. If you want a timed {@code tryLock} that does * permit barging on a fair lock then combine the timed and * un-timed forms together: * * {@code * if (lock.tryLock() || * lock.tryLock(timeout, unit)) { * ... * }} * * If the write lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until one of three things happens: * * * * The read lock is acquired by the current thread; or * * Some other thread {@linkplain Thread#interrupt interrupts} * the current thread; or * * The specified waiting time elapses. * * * * If the read lock is acquired then the value {@code true} is * returned. * * If the current thread: * * * * has its interrupted status set on entry to this method; or * * is {@linkplain Thread#interrupt interrupted} while * acquiring the read lock, * * then {@link InterruptedException} is thrown and the * current thread's interrupted status is cleared. * * If the specified waiting time elapses then the value * {@code false} is returned. If the time is less than or * equal to zero, the method will not wait at all. * * In this implementation, as this method is an explicit * interruption point, preference is given to responding to * the interrupt over normal or reentrant acquisition of the * lock, and over reporting the elapse of the waiting time. * * @param timeout the time to wait for the read lock * @param unit the time unit of the timeout argument * @return {@code true} if the read lock was acquired * @throws InterruptedException if the current thread is interrupted * @throws NullPointerException if the time unit is null */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } /** * Attempts to release this lock. * * If the number of readers is now zero then the lock * is made available for write lock attempts. */ public void unlock() { sync.releaseShared(1); } /** * Throws {@code UnsupportedOperationException} because * {@code ReadLocks} do not support conditions. * * @throws UnsupportedOperationException always */ public Condition newCondition() { throw new UnsupportedOperationException(); } /** * Returns a string identifying this lock, as well as its lock state. * The state, in brackets, includes the String {@code \"Read locks =\"} * followed by the number of held read locks. * * @return a string identifying this lock, as well as its lock state */ public String toString() { int r = sync.getReadLockCount(); return super.toString() + \"[Read locks = \" + r + \"]\"; } } /** * The lock returned by method {@link ReentrantReadWriteLock#writeLock}. */ public static class WriteLock implements Lock, java.io.Serializable { private static final long serialVersionUID = -4992448646407690164L; private final Sync sync; /** * Constructor for use by subclasses * * @param lock the outer lock object * @throws NullPointerException if the lock is null */ protected WriteLock(ReentrantReadWriteLock lock) { sync = lock.sync; } /** * Acquires the write lock. * * Acquires the write lock if neither the read nor write lock * are held by another thread * and returns immediately, setting the write lock hold count to * one. * * If the current thread already holds the write lock then the * hold count is incremented by one and the method returns * immediately. * * If the lock is held by another thread then the current * thread becomes disabled for thread scheduling purposes and * lies dormant until the write lock has been acquired, at which * time the write lock hold count is set to one. */ public void lock() { sync.acquire(1); } /** * Acquires the write lock unless the current thread is * {@linkplain Thread#interrupt interrupted}. * * Acquires the write lock if neither the read nor write lock * are held by another thread * and returns immediately, setting the write lock hold count to * one. * * If the current thread already holds this lock then the * hold count is incremented by one and the method returns * immediately. * * If the lock is held by another thread then the current * thread becomes disabled for thread scheduling purposes and * lies dormant until one of two things happens: * * * * The write lock is acquired by the current thread; or * * Some other thread {@linkplain Thread#interrupt interrupts} * the current thread. * * * * If the write lock is acquired by the current thread then the * lock hold count is set to one. * * If the current thread: * * * * has its interrupted status set on entry to this method; * or * * is {@linkplain Thread#interrupt interrupted} while * acquiring the write lock, * * * * then {@link InterruptedException} is thrown and the current * thread's interrupted status is cleared. * * In this implementation, as this method is an explicit * interruption point, preference is given to responding to * the interrupt over normal or reentrant acquisition of the * lock. * * @throws InterruptedException if the current thread is interrupted */ public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } /** * Acquires the write lock only if it is not held by another thread * at the time of invocation. * * Acquires the write lock if neither the read nor write lock * are held by another thread * and returns immediately with the value {@code true}, * setting the write lock hold count to one. Even when this lock has * been set to use a fair ordering policy, a call to * {@code tryLock()} will immediately acquire the * lock if it is available, whether or not other threads are * currently waiting for the write lock. This &quot;barging&quot; * behavior can be useful in certain circumstances, even * though it breaks fairness. If you want to honor the * fairness setting for this lock, then use {@link * #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) } * which is almost equivalent (it also detects interruption). * * If the current thread already holds this lock then the * hold count is incremented by one and the method returns * {@code true}. * * If the lock is held by another thread then this method * will return immediately with the value {@code false}. * * @return {@code true} if the lock was free and was acquired * by the current thread, or the write lock was already held * by the current thread; and {@code false} otherwise. */ public boolean tryLock( ) { return sync.tryWriteLock(); } /** * Acquires the write lock if it is not held by another thread * within the given waiting time and the current thread has * not been {@linkplain Thread#interrupt interrupted}. * * Acquires the write lock if neither the read nor write lock * are held by another thread * and returns immediately with the value {@code true}, * setting the write lock hold count to one. If this lock has been * set to use a fair ordering policy then an available lock * will not be acquired if any other threads are * waiting for the write lock. This is in contrast to the {@link * #tryLock()} method. If you want a timed {@code tryLock} * that does permit barging on a fair lock then combine the * timed and un-timed forms together: * * {@code * if (lock.tryLock() || * lock.tryLock(timeout, unit)) { * ... * }} * * If the current thread already holds this lock then the * hold count is incremented by one and the method returns * {@code true}. * * If the lock is held by another thread then the current * thread becomes disabled for thread scheduling purposes and * lies dormant until one of three things happens: * * * * The write lock is acquired by the current thread; or * * Some other thread {@linkplain Thread#interrupt interrupts} * the current thread; or * * The specified waiting time elapses * * * * If the write lock is acquired then the value {@code true} is * returned and the write lock hold count is set to one. * * If the current thread: * * * * has its interrupted status set on entry to this method; * or * * is {@linkplain Thread#interrupt interrupted} while * acquiring the write lock, * * * * then {@link InterruptedException} is thrown and the current * thread's interrupted status is cleared. * * If the specified waiting time elapses then the value * {@code false} is returned. If the time is less than or * equal to zero, the method will not wait at all. * * In this implementation, as this method is an explicit * interruption point, preference is given to responding to * the interrupt over normal or reentrant acquisition of the * lock, and over reporting the elapse of the waiting time. * * @param timeout the time to wait for the write lock * @param unit the time unit of the timeout argument * * @return {@code true} if the lock was free and was acquired * by the current thread, or the write lock was already held by the * current thread; and {@code false} if the waiting time * elapsed before the lock could be acquired. * * @throws InterruptedException if the current thread is interrupted * @throws NullPointerException if the time unit is null */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } /** * Attempts to release this lock. * * If the current thread is the holder of this lock then * the hold count is decremented. If the hold count is now * zero then the lock is released. If the current thread is * not the holder of this lock then {@link * IllegalMonitorStateException} is thrown. * * @throws IllegalMonitorStateException if the current thread does not * hold this lock */ public void unlock() { sync.release(1); } /** * Returns a {@link Condition} instance for use with this * {@link Lock} instance. * The returned {@link Condition} instance supports the same * usages as do the {@link Object} monitor methods ({@link * Object#wait() wait}, {@link Object#notify notify}, and {@link * Object#notifyAll notifyAll}) when used with the built-in * monitor lock. * * * * If this write lock is not held when any {@link * Condition} method is called then an {@link * IllegalMonitorStateException} is thrown. (Read locks are * held independently of write locks, so are not checked or * affected. However it is essentially always an error to * invoke a condition waiting method when the current thread * has also acquired read locks, since other threads that * could unblock it will not be able to acquire the write * lock.) * * When the condition {@linkplain Condition#await() waiting} * methods are called the write lock is released and, before * they return, the write lock is reacquired and the lock hold * count restored to what it was when the method was called. * * If a thread is {@linkplain Thread#interrupt interrupted} while * waiting then the wait will terminate, an {@link * InterruptedException} will be thrown, and the thread's * interrupted status will be cleared. * * Waiting threads are signalled in FIFO order. * * The ordering of lock reacquisition for threads returning * from waiting methods is the same as for threads initially * acquiring the lock, which is in the default case not specified, * but for fair locks favors those threads that have been * waiting the longest. * * * * @return the Condition object */ public Condition newCondition() { return sync.newCondition(); } /** * Returns a string identifying this lock, as well as its lock * state. The state, in brackets includes either the String * {@code \"Unlocked\"} or the String {@code \"Locked by\"} * followed by the {@linkplain Thread#getName name} of the owning thread. * * @return a string identifying this lock, as well as its lock state */ public String toString() { Thread o = sync.getOwner(); return super.toString() + ((o == null) ? \"[Unlocked]\" : \"[Locked by thread \" + o.getName() + \"]\"); } /** * Queries if this write lock is held by the current thread. * Identical in effect to {@link * ReentrantReadWriteLock#isWriteLockedByCurrentThread}. * * @return {@code true} if the current thread holds this lock and * {@code false} otherwise * @since 1.6 */ public boolean isHeldByCurrentThread() { return sync.isHeldExclusively(); } /** * Queries the number of holds on this write lock by the current * thread. A thread has a hold on a lock for each lock action * that is not matched by an unlock action. Identical in effect * to {@link ReentrantReadWriteLock#getWriteHoldCount}. * * @return the number of holds on this lock by the current thread, * or zero if this lock is not held by the current thread * @since 1.6 */ public int getHoldCount() { return sync.getWriteHoldCount(); } } 哎，读这个源码还是好吃力。 读写锁的用途 读写锁是为了提高并发数，特别适用于读多写少的场景。下面是一个读写锁的应用场景： package com.thread; import java.util.Random; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest { public static void main(String[] args) { final Queue3 q3 = new Queue3(); for(int i=0;i 下面的代码使用读写锁实现缓存器： package com.thread; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class CacheDemo { private Map map = new HashMap();//缓存器 private ReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) { } public Object get(String id){ Object value = null; rwl.readLock().lock();//首先开启读锁，从缓存中去取 try{ value = map.get(id); if(value == null){ //如果缓存中没有释放读锁，上写锁 rwl.readLock().unlock(); rwl.writeLock().lock(); try{ if(value == null){ value = \"aaa\"; //此时可以去数据库中查找，这里简单的模拟一下 } }finally{ rwl.writeLock().unlock(); //释放写锁 } rwl.readLock().lock(); //然后再上读锁 } }finally{ rwl.readLock().unlock(); //最后释放读锁 } return value; } } 参考ReentrantReadWriteLock读写锁的使用 参考 轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理 ReentrantReadWriteLock读写锁的使用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-03 18:32:02 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/Condition.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/Condition.html","title":"Condition","keywords":"","body":"Condition Conditon用来是实现进程的同步。在1.5之前，我们使用的是Object的wait、notify和notifyAll方法，配合synchronied关键字来进行线程的同步。 而Conditon接口也提供了类似于Object监视器的方法，通过与Lock来实现等待-通知模式。 他们两者的比较如下表： API说明如下： 方法 说明 void await() throws InterruptedException 当前线程进入等待状态，直到被通知（signal）或者被中断时，当前线程进入运行状态，从await()返回； void awaitUninterruptibly() 当前线程进入等待状态，直到被通知，对中断不做响应； long awaitNanos(long nanosTimeout) throws InterruptedException 在接口1的返回条件基础上增加了超时响应，返回值表示当前剩余的时间，如果在nanosTimeout之前被唤醒，返回值 = nanosTimeout - 实际消耗的时间，返回值 boolean await(long time, TimeUnit unit) throws InterruptedException 同样是在接口1的返回条件基础上增加了超时响应，与接口3不同的是：①可以自定义超时时间单位；②返回值返回true/false，在time之前被唤醒，返回true，超时返回false。 Â boolean awaitUntil(Date deadline) throws InterruptedException 当前线程进入等待状态直到将来的指定时间被通知，如果没有到指定时间被通知返回true，否则，到达指定时间，返回false； void signal() 唤醒一个等待在Condition上的线程； void signalAll() 唤醒等待在Condition上所有的线程。 下面是源码注释中给出的一个例子： class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; } finally { lock.unlock(); } } } 这里定义了一个缓冲区类Buffer，缓冲区为空的时候读操作要收到阻塞，缓冲区为满的是的时候写操作收到阻塞。上面代码中分别定义了notFull和notEmpty来控制阻塞和唤醒。 类似的，我们可以利用Conditon来创建一个有界队列，当队列为空的时候出队操作阻塞，当队列为满的时候入队操作组设。（其实和上面是一个意思，换汤不换药） AQS的内部类ConditionObject是Condition的实现类。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 23:59:46 "},"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/AbstractOwnableSynchronizer.html":{"url":"源码解读/java.util/java.util.concurrent/java.util.concurrent.locks/AbstractOwnableSynchronizer.html","title":"AbstractOwnableSynchronizer","keywords":"","body":"AbstractOwnableSynchronizer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-22 14:30:35 "},"源码解读/java.io/java-io.html":{"url":"源码解读/java.io/java-io.html","title":"java.io","keywords":"","body":"java.io java.io是一套Java用来读写数据（输入和输出）的API。这个包并没有涵盖所有的输入输出类型，例如，并不包括GUI或者网页上的输入输出，这些输入输出在其他地方都涉及，比如Swing工程中JFC(Java Foundation Classes)类，或者J2EE里的Servlet和HTTP包。java.io包主要涉及文件，网络数据流，内存缓冲等的输入输出。 这里的类主要可以分为三类 流式部分。这是java.io的主体，概括起来是“两个对象和一个桥梁”，两个对象是指“字符流char stream”和“字节流byte stream”，一个桥梁是指字节流到字符流的桥梁，对应于输入和输出是InputStreamReader和OutputStreamWriter。 辅助类，只要是文件FIle。 与文件读取相关的安全类与本地操作相关的文件系统的类。 我们还是将重点放到流式部分。 分类如下: 包主要包含的类如下： 类名 功能 File 封装了对文件系统进行操作的功能 Reader 用于读取字符流的抽象类 BufferedReader 从字符输入流读取文本，缓冲字符，以提供字符，数组和行的有效读取 InputStreamReader InputStreamReader是从字节流到字符流的桥梁：它读取字节，并使用指定的字符集将其解码为字符 FileReader 用于读取字符文件的方便的流 StringReader 用于读取字符串的流 PipedReader CharArrayReader FilterReader PushbackReader Writer 用于写入字符流的抽象类 BufferedWriter 将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入。 OutputStreamWriter FileWriter StringWriter PipedWriter CharArrayWriter FilterReader InputStream FileInputStream FilterInputStream BufferedInputStream DataInputStream PushbackInputStream ObjectInputStream PipedInputStream SequenceInputStream StringBufferInputStream ByteArrayInputStream OutputStream FileOutputStream FilterOutputStream BufferedOutputStream PrintStream ObjectOutputStream PipedOutputStream ByteArrayOutputStream 哎看到这个真的是要长叹一声啊，太多了。其实我们常用的就是加粗的几个类。 参考： Java IO教程 Java IO最详解 Java IO Java IO流学习总结 Java IO流学习总结一：输入输出流 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:27:47 "},"源码解读/java.io/File.html":{"url":"源码解读/java.io/File.html","title":"File","keywords":"","body":"File 流的本质是对文件的处理，所以在学习具体的流之前，先要学习File类。 public class File implements Serializable, Comparable 类声明，可以看到File实现了Serializable接口和Comparable接口，所以这个类中一定会定义一个serialVersionUID。 静态构造块 这个类中有一个静态构造块，定义如下： static { try { sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe(); PATH_OFFSET = unsafe.objectFieldOffset( File.class.getDeclaredField(\"path\")); PREFIX_LENGTH_OFFSET = unsafe.objectFieldOffset( File.class.getDeclaredField(\"prefixLength\")); UNSAFE = unsafe; } catch (ReflectiveOperationException e) { throw new Error(e); } } 其中PATH_OFFSET，PREFIX_LENGTH_OFFSET，UNSAFE是声明在静态代码块之前的类变量，定义如下： private static final long PATH_OFFSET; private static final long PREFIX_LENGTH_OFFSET; private static final sun.misc.Unsafe UNSAFE; 这段代码其实没能看懂具体有什么作用o(╯□╰)o 构造方法 File类定义了6种构造方法，其中有两种是私有的。 public File(String pathname){...} 这是一个最常用的公共构造方法。用指定的路径pathname创建文件对象。定义如下： public File(String pathname) { if (pathname == null) { throw new NullPointerException(); } this.path = fs.normalize(pathname); this.prefixLength = fs.prefixLength(this.path); } 当参数为null时会抛出空指针异常。否则将文件路径转为抽象路径，什么是抽象路径？ 输入参数pathname是文件路径及文件名的字符串表达形式，不同的操作系统有不同的表达形式。这个类提供了一个“抽象路径”，这个pathname会转化为abstract pathname，即与系统无关的文件名表达形式，并用path、prefixLength两个变量存储输入参数的pathname转化后的变量。下面就是这两个变量的声明。 private final String path; private final transient int prefixLength; 一个抽象路径包含两个部分： 一个可选的依赖系统的前缀字符串，例如一个用于UNIX根目录的磁盘驱动器说明符“/”，或者一个Microsoft Windows UNC路径名的“\\\\” 零个或多个字符串名称的序列 抽象路径名中的第一个名称可能是目录名称，或者在Microsoft Windows UNC路径名的情况下是主机名。 抽象路径名中的每个后续名称表示一个目录; 最后一个名称可以表示目录或文件。 空的抽象路径名没有前缀和空名称序列。 字符串文件路径是如何转化为抽象路径的呢？其过程是方法normalize的具体实现。normalize是一个抽象方法。在mac os x系统性下，在dubug模式下可以发现最后执行的是FileSystem的实现类UnixFileSystem重写的normalize方法。可见，将路径名字符串转换为抽象路径名或从抽象路径名转换本质上是系统依赖的。它会自动转化为某个操作系统的路径以及去除重复和多余的分隔符等。 下面是UnixFileSystem类中的normalize方法的定义： public String normalize(String pathname) { int n = pathname.length(); char prevChar = 0; for (int i = 0; i 这个方法只会执行一次，为什么？因为path被final修饰，所以File类的实例是不可变的，也就是说一旦创建，由File对象表示的抽象路径永远不会改变。 当抽象路径名转换为路径名字符串时，每个名称将与默认分隔符字符的单个副本分隔开。 默认名称分隔符由系统属性file.separator定义，并在该类的公共静态字段separator和separatorChar中可用。 当路径名字符串转换为抽象路径名时，其中的名称可能由默认名称分隔符或由底层系统支持的任何其他名称 - 分隔符分隔。 路径名，无论是抽象路径还是字符串形式，都可以是绝对路径或相对路径。 关于路径的具体解释可以看另一篇博客。 由于存在平台的差异，所以一般我们不把字符串直接写成c:\\\\zuidaima\\\\1.txt这种形式，而是采用separator跨平台分隔符，例如： File f3 =new File(\"c:\"+File.separator+\"abc\"); public File(String parent, String child){...} 该方法用于从父路径名字符串和子路径名字符串创建新的File实例。 public File(String parent, String child) { if (child == null) { throw new NullPointerException(); } if (parent != null) { if (parent.equals(\"\")) { this.path = fs.resolve(fs.getDefaultParent(), fs.normalize(child)); } else { this.path = fs.resolve(fs.normalize(parent), fs.normalize(child)); } } else { this.path = fs.normalize(child); } this.prefixLength = fs.prefixLength(this.path); } 如果parent为null，那么将创建新的File实例，就像在给定子路径名字符串中调用单参数File构造函数一样。否则，将使用父路径名字符串表示目录，并将子路径名字符串用于表示目录或文件。 如果子路径名字符串为绝对值，则以系统相关方式将其转换为相对路径名。 如果parent是空字符串，则通过将子代码转换为抽象路径名并根据系统相关的默认目录解析结果来创建新的File实例。 否则，每个路径名字符串将转换为抽象路径名，并针对父对象解析子抽象路径名。 讲了这么多，实际上就是将一个完整的路径分开写了而已。比如调用上一个构造函数创建文件File f1 =new File(\"c:\\\\zuidaima\\\\1.txt\");如果想要在同一个目录下创建另一个txt文件，那么就可以用File f2 =new File(\"c:\\\\zuidaima\",\"2.txt\");这种方式。 public File(File parent, String child){...} 和上面一个构造函数好像，注意这个方法的第一个参数是File类型。 public File(File parent, String child) { if (child == null) { throw new NullPointerException(); } if (parent != null) { if (parent.path.equals(\"\")) { this.path = fs.resolve(fs.getDefaultParent(), fs.normalize(child)); } else { this.path = fs.resolve(parent.path, fs.normalize(child)); } } else { this.path = fs.normalize(child); } this.prefixLength = fs.prefixLength(this.path); } 下面是一个使用这个构造函数的例子： File f3 =new File(\"c:\"+File.separator+\"abc\");//separator 跨平台分隔符 File f4 =new File(f3,\"3.txt\"); public File(URI uri){...} 将URI 转换为一个抽象路径名来创建一个新的 File 实例。URI 的具体形式与系统有关，因此，由此构造方法执行的转换也与系统有关。定义如下： public File(URI uri) { // Check our many preconditions if (!uri.isAbsolute()) throw new IllegalArgumentException(\"URI is not absolute\"); if (uri.isOpaque()) throw new IllegalArgumentException(\"URI is not hierarchical\"); String scheme = uri.getScheme(); if ((scheme == null) || !scheme.equalsIgnoreCase(\"file\")) throw new IllegalArgumentException(\"URI scheme is not \\\"file\\\"\"); if (uri.getAuthority() != null) throw new IllegalArgumentException(\"URI has an authority component\"); if (uri.getFragment() != null) throw new IllegalArgumentException(\"URI has a fragment component\"); if (uri.getQuery() != null) throw new IllegalArgumentException(\"URI has a query component\"); String p = uri.getPath(); if (p.equals(\"\")) throw new IllegalArgumentException(\"URI path component is empty\"); // Okay, now initialize p = fs.fromURIPath(p); if (File.separatorChar != '/') p = p.replace('/', File.separatorChar); this.path = fs.normalize(p); this.prefixLength = fs.prefixLength(this.path); } 这个方法到现在都没有用到过，所以暂时不知道是什么意思，先不看了。 private File(String pathname, int prefixLength){...} 这是一个内部的构造方法，用来已经规范化的路径名字符串的内部构造函数。定义如下： private File(String pathname, int prefixLength) { this.path = pathname; this.prefixLength = prefixLength; } private File(String child, File parent){...} 另一个内部的构造方法，定义如下： private File(String child, File parent) { assert parent.path != null; assert (!parent.path.equals(\"\")); this.path = fs.resolve(parent.path, child); this.prefixLength = parent.prefixLength; } 其他方法都是一些路径访问、文件属性方法，不用太深究了，下面是API的总结，会用就行： 方法 描述 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public String getParent() 返回此抽象路径名的父路径名字符串，如果此路径名没有指定父目录，则返回null public File getParentFile() 返回此抽象路径名的父路径名的抽象路径名，如果此路名没有指定父目录，则返回null public String getPath() 将次抽象路径名转化为一个路径名字符串 public boolean isAbsolute() 测试此抽象路径名是否为绝对路径名 public String getAbsolutePath() 返回抽象路径名的绝对路径名字符串 public String getCanonicalPath() throws IOException 返回抽象路径名的规范路径名字符串 public boolean canExecute() 判断文件是否可执行 public boolean canRead() 测试应用程序是否可以读取此抽象路径名表示的的文件 public boolean canWrite() 测试应用程序是否可以修改此抽象路径名表示的文件 public boolean exists() 测试此抽象路径名表示的文件或目录是否存在 public boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录 public boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件 public long lastModify() 返回此抽象路径名表示的文件最后一次被需改的时间 public long length() 返回由此抽象路径名表示的文件的长度 public boolean createNewFile() throws IOException 当且仅当不存在具有此抽象路径名指定的文件时，原子地创建由此抽象路径名执行的一个新的空文件，注意这个方法的返回值是boolean值 public boolean delete() 删除此抽象路径名表示的文件或目录 public void deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录 public String[] list() 返回由此抽象路径名表示的目录中的文件和目录的名称锁组成的字符串数组 public String[] list(FilenameFilter filter) 返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。 public File[] listFiles() 返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。 public boolean mkdir() 创建此抽象路径名指定的目录。只能创建多级目录 public boolean mkdirs() 创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。创建多级目录 public boolean renameTo(File dest） 重新命名此抽象路径名表示的文件。 public boolean setLastModified(long time) 设置由此抽象路径名所指定的文件或目录的最后一次修改时间。 public boolean setReadOnly() 标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。 public static File createTempFile(String prefix, String suffix, File directory) throws IOException 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。 public static File createTempFile(String prefix, String suffix) throws IOException 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 public int compareTo(File pathname) 按字母顺序比较两个抽象路径名。 public int compareTo(Object o) 按字母顺序比较抽象路径名与给定对象。 public boolean equals(Object obj) 测试此抽象路径名与给定对象是否相等。 public String toString() 返回此抽象路径名的路径名字符串。 上面简单罗列了一下常见的用法，一些常用的操作例子可以参考：Java File操作汇总 其中有些方法需要明确概念、适用场景和雷区。 getPath、getAbsolutePath和getCanonicalPath的区别 这三个方法都不管文件是不是真是存在，只要有文件引用就可以了。前两个的区别很好解释：getPath输出的是创建的时候用的路径字符串，getAbsolutePath输出的是绝对路径。getCanonicalPath方法不但输出全路径，而且把一些..、.这样的符号解析出来了。看下面的例子。 File file = new File(\"..\\\\src\\\\test1.txt\"); System.out.println(file.getPath()); System.out.println(file.getAbsolutePath()); try { System.out.println(file.getCanonicalPath()); }catch (Exception e){ e.getStackTrace(); } 输出的结果是： ..\\\\src\\\\test1.txt D:\\workspace\\test\\..\\src\\test1.txt D:\\workspace\\src\\test1.txt 输出结果可以看到三者明显的不同。另外这篇博文http://www.blogjava.net/dreamstone/archive/2007/08/08/134968.html 中有写一个由windows和linux大小写敏感问题造成结果差异，可以看一下。 renameTo方法的应用 这个方法名字上看就是\"重命名\"的意思，但是这个方法经常用来拷贝文件。仔细看方法签名，public boolean renameTo(File dest），参数是目标文件，难道重命名参数不应该是String么？而且返回值是boolean，所以还存在重命名不成功的时候。看下面这个测试： public static void main(String[] args) { File source = new File(\"/Users/baoxiaofang/Documents/aaa.txt\"); if (!source.exists()){ try { source.createNewFile(); }catch (Exception e){ e.getStackTrace(); } } File dest1 = new File(\"/Users/baoxiaofang/Documents/bbb.txt\"); File dest2 = new File(\"/Users/baoxiaofang/Documents/ccc.txt\"); System.out.println(\"dest1 is exist? \" + dest1.exists()); System.out.println(\"dest2 is exist? \" + dest2.exists()); System.out.println(\"source rename to dest1 \" + source.renameTo(dest1)); System.out.println(\"source rename to dest2 \" + source.renameTo(dest2)); } 执行结果是： dest1 is exist? false dest2 is exist? true source rename to dest1 true source rename to dest2 false 该程序中首先保证了源文件source一定存在，然后分给renameTo到一个不存在的文件bbb.txt，和一个已存在的文件ccc.txt，结果发现，前者成功而后者不成功，并且最后看文件夹发现有一个bbb.txt和ccc.txt，而原来的aaa.txt不见了。所以可以得出结论：使用renameTo重命名文件，首先要保证源文件存在（这个可以做实验验证一下确实是这样），不管这个源文件是一个“文件”还是一个“目录”。最重要的一点是，要保证参数dest是一个不存在的对象。满足以上两点才能重命名成功。这个方法和linux下的mv命令不是一样。 但是这个方法有人做过测试，很不靠谱，参考http://www.iteye.com/topic/149328， 所以拷贝文件还是用FileUtilsc.copyFileToDirectory(File,File)比较好。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:12:22 "},"源码解读/java.io/Reader.html":{"url":"源码解读/java.io/Reader.html","title":"Reader","keywords":"","body":"Reader Reader是字符输入流的基础类，结构如下 注意到这里只有两个抽象方法read(char[], int, int)和close()，一般子类只用重写这两个方法即可，但是一般地，子类会重写覆盖其他的一些非抽象方法以得到更好的性能。 public abstract class Reader implements Readable, Closeable 类声明，注意这是一个抽象类，实现了Readable和Closeable接口。 构造方法 Reader类有两个构造方法，全部都是protected。 protected Reader(){...} 无参数构造方法，定义如下： protected Reader() { this.lock = this; } 这类的lock是一个protected的成员变量，定义如下： protected Object lock; 这个量有什么作用呢？从名字就猜出来了，锁，同步用的。在无参数的构造方法中，这个同步对象指定为自己。能不能指定为别人呢？可以，用另一个有参数的构造方法就行。 protected Reader(Object lock){...} 这个构造方法使用一个Object实例作为参数，这个实例就是锁。定义如下： protected Reader(Object lock) { if (lock == null) { throw new NullPointerException(); } this.lock = lock; } read方法 这是Reader中最核心的方法了，一共重载了4个。 public int read(java.nio.CharBuffer target) throws IOException{...} 该方法尝试将字符读入指定的字符缓冲区。缓冲区用作字符存储库：唯一的更改是put操作的结果。不执行缓冲器的翻转或倒带。 public int read(java.nio.CharBuffer target) throws IOException { int len = target.remaining(); char[] cbuf = new char[len]; int n = read(cbuf, 0, len); if (n > 0) target.put(cbuf, 0, n); return n; } 这类的参数target就是字符缓冲区，这个类继承Buffer抽象类。target.remaining()方法得到了缓冲区剩余的大小，其定义如下： public final int remaining() { return limit - position; } 用此长度构造一个字符数组，调用的方法是一个抽象方法abstract public int read(char cbuf[], int off, int len) throws IOException;这个方法需要子类去实现，该方法返回的是字符的个数，如果已经达到流的结尾，则返回-1。如果在读的过程中发生错误，则抛出IOException异常。如果读取成功，target就把这个字符串数组加入到字符缓冲区，最后返回的是字符的个数。这里有一个疑问，为什么不直接往字符缓冲区中写呢？是怕中间产生读写错误么？ public int read() throws IOException{..} 无参数的read方法，读取的是单个字符。这个在字符不可用的时候将会阻塞，知道字符可用或者发生IO错误或者到达字符流的结尾。这里面仍旧调用了上面的read方法。方法返回值是-1（已经到达流结尾时）或者这个字符的int值。 public int read() throws IOException { char cb[] = new char[1]; if (read(cb, 0, 1) == -1) return -1; else return cb[0]; } public int read(char cbuf[]) throws IOException{...} 将字符读取到字符串数组，定义如下： public int read(char cbuf[]) throws IOException { return read(cbuf, 0, cbuf.length); } abstract public int read(char cbuf[], int off, int len) throws IOException; 首先方法，子类必须实现。也是其他几种重载的read方法的核心。 public long skip(long n) throws IOException{...} 方法用来跳过某些字符。参数n就是被跳过的字符的个数。在某个字符可用、发生 I/O 错误或者已到达流的末尾前，此方法一直阻塞。定义如下： public long skip(long n) throws IOException { if (n 0) { int nc = read(skipBuffer, 0, (int)Math.min(r, nn)); if (nc == -1) break; r -= nc; } return n - r; } } 这里有一个变量maxSkipBufferSize，这是Java定义的能跳过的最大字符个数，定义为private static final int maxSkipBufferSize = 8192;其中skipBuffer是一个字符数组类型的成员变量，用来保存被跳过的字符。最后返回的是实际上跳过的字符个数。另外注意到跳过的这个过程是线程安全的。 这里面的数量关系还挺绕的。比如实际上只有3个字符，但是参数n为5。那么nn=5，r=5, 执行返回的nc=3，r=5-3=2。下一循环时候，nc=-1退出循环，返回的值是5-2=3。即实际上跳过的字符个数是3个。 public boolean ready() throws IOException{...} 判断是否准备读取此流。返回值：如果保证下一个 read() 不阻塞输入，则返回 True，否则返回 false。注意，返回 false 并不保证阻塞下一次读取。定义如下： public boolean ready() throws IOException { return false; } 注意到，看这个方法只会返回false。也就是说并不保证阻塞下一次读取？？？？不是很理解这个方法设计意图。应该是让子类重写的吧。 public boolean markSupported(){...} 告诉这个流是否支持mark()操作。 默认实现始终返回false。子类应该覆盖此方法。 什么是mark操作？ public void mark(int readAheadLimit) throws IOException{...} 标记流中的当前位置。 对reset（）的后续调用将尝试将流重新定位到此位置。 并非所有字符输入流都支持mark（）操作。 public void mark(int readAheadLimit) throws IOException { throw new IOException(\"mark() not supported\"); } public void reset() throws IOException{...} 重置流。 如果流已被标记，则尝试在标记处重新定位。 如果流未被标记，则尝试以某种方式将其重置为特定的流，例如通过将其重新定位到其起始点。 并不是所有的字符输入流都支持reset（）操作，有些支持reset（），而不支持mark（）。 public void reset() throws IOException { throw new IOException(\"reset() not supported\"); } abstract public void close() throws IOException; 关闭流并释放与之相关联的任何系统资源。 一旦流已关闭，进一步的read（），ready（），mark（），reset（）或skip（）调用将抛出一个IOException。 关闭以前关闭的流无效。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:17:17 "},"源码解读/java.io/BufferedReader.html":{"url":"源码解读/java.io/BufferedReader.html","title":"BufferedReader","keywords":"","body":"BufferedReader 直接继承Reader，目标媒介是缓冲。从字符输出流中读取文本，缓冲字符，以提供字符、数组和行有效读，为其他字符输入流添加一些缓冲功能。结构定义如下： 我们平常都是用如下的方式来使用这个类： BufferedReader in = new BufferedReader(new FileReader(\"foo.in\")); 为什么FileReader已经是一个Reader了，为什么还要在它外面包裹一层？为了缓冲。为什么需要缓冲呢？原因很简单，效率问题！缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。 那干嘛不干脆一次性将全部数据都读取到缓冲中呢？第一，读取全部的数据所需要的时间可能会很长。第二，内存价格很贵，容量不像硬盘那么大。 构造方法 定义了两个构造方法。 public BufferedReader(Reader in, int sz){...} 定义了一个字符输入流，指定缓冲区大小。定义如下： public BufferedReader(Reader in, int sz) { super(in); if (sz 首先执行了父类Reader的构造方法，即把字符输出缓冲区作为锁。定义了输入流in，cb是字符数组，是字符缓冲区，nextChar是下一个要读取的字符在cb缓冲区中的位置 ，nChars是cb缓冲区中字符的总的个数。 public BufferedReader(Reader in){..} 只接受一个输入流作为参数，缓冲区大小默认为8192，即8k，定义如下： public BufferedReader(Reader in) { this(in, defaultCharBufferSize); } private void ensureOpen() throws IOException{...} 该方法用来确保流未关闭。定义如下： private void ensureOpen() throws IOException { if (in == null) throw new IOException(\"Stream closed\"); } private void fill() throws IOException{...} 该函数用来填充缓冲区，这个函数会在两种情况下被调用： 缓冲区没有数据时，通过fill()可以向缓冲区填充数据。 缓冲区数据被读完，需更新时，通过fill()可以更新缓冲区的数据。 定义如下： private void fill() throws IOException { int dst; // dst表示“cb中填充数据的起始位置”。 if (markedChar = readAheadLimit) { /* Gone past read-ahead limit: Invalidate mark */ // 若“当前标记的长度”超过了“标记上限(readAheadLimit)”， // 则丢弃标记！ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; } else { if (readAheadLimit 0) { nChars = dst + n; nextChar = dst; } } 其中一些变量定义如下： private int nChars, nextChar; private static final int INVALIDATED = -2; private static final int UNMARKED = -1; private int markedChar = UNMARKED; private int readAheadLimit = 0; /* Valid only when markedChar > 0 */ 其中INVALIDATED表示“标记无效”，它与UNMARKED的区别是：(01)UNMARKED是压根就没有设置过标记;(02)而INVALIDATED是设置了标记，但是被标记位置太长，导致标记无效！其中UNMARKED表示没有设置“标记” 。markedChar表示“标记” 。readAheadLimit表示“标记”能标记位置的最大长度。 fill方法的详细解释可以参考 http://blog.csdn.net/asivy/article/details/18704449 read方法 read方法用来实现从缓存中读取字符，有2个重载方法，其中一个是重写了父类的read的方法，一个实现了父类的抽象方法。 public int read() throws IOException{..} 该方法重写了父类方法，用来从缓存中读取单个字符，最后以int的形式返回。定义如下： public int read() throws IOException { synchronized (lock) { ensureOpen(); for (;;) { if (nextChar >= nChars) { fill(); if (nextChar >= nChars) return -1; } if (skipLF) { skipLF = false; if (cb[nextChar] == '\\n') { nextChar++; continue; } } return cb[nextChar++]; } } } 该方法线程安全，首先保证流正处理打开状态。如果要读取的位置已经超过了最大字符数，说明缓冲区的数据已经被读完，那么需要调用fill方法读入新的数据；如果读完还是大于，那么说明之前就已经到达了input的结尾，所以返回-1。skipLF即skip Line Feed，是“是否忽略换行符”标记。若要“忽略换行符”， 则对下一个字符是否是换行符进行处理。最后返回下一个字符。 public int read(char cbuf[], int off, int len) throws IOException{...} 实现了父抽象类Reader的抽象方法，这个方法将缓冲区的数据写入到cbuf数组中，其中off是数组的偏移量，len是写入的长度。 public int read(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off cbuf.length) || (len cbuf.length) || ((off + len) 这几个实际上是对read1方法的包装，添加了\"同步处理\"和“阻塞式读取”的功能，定义如下： private int read1(char[] cbuf, int off, int len) throws IOException { if (nextChar >= nChars) { /* If the requested length is at least as large as the buffer, and if there is no mark/reset activity, and if line feeds are not being skipped, do not bother to copy the characters into the local buffer. In this way buffered streams will cascade harmlessly. */ if (len >= cb.length && markedChar = nChars) return -1; if (skipLF) { skipLF = false; if (cb[nextChar] == '\\n') { nextChar++; if (nextChar >= nChars) fill(); if (nextChar >= nChars) return -1; } } int n = Math.min(len, nChars - nextChar); System.arraycopy(cb, nextChar, cbuf, off, n); nextChar += n; return n; } 首先，比较nextChar和nChars的值，如果前者大于等于或者，说明缓冲区的数据已经被读完，则更新缓冲区数据。如果已经读完仍然大于，说明input已经被读取完了，此时返回-1。如果要“忽略换行符”，则进行相应的处理。之后进行字符串拷贝。 readLine方法 readLine提供了读取一行的方法。重载了两个方法。 public String readLine() throws IOException{...} 无参构造方法，定义如下： public String readLine() throws IOException { return readLine(false); } 调用的是有参构造方法，默认参数false。 String readLine(boolean ignoreLF) throws IOException{...} 其中的参数ignoreLF表示是否忽略换行符。 String readLine(boolean ignoreLF) throws IOException { StringBuffer s = null; int startChar; synchronized (lock) { // 确保底层的inputStream未被关闭 ensureOpen(); // ignoreLF在BufferedReader中始终为false // 而skipLF则会在读到\"\\r\"字符之后被设置为true，通过这样来忽略掉之后的\"\\n\" boolean omitLF = ignoreLF || skipLF; // 接下来是两个循环，第一层bufferLoop主要是用来往底层的数组里填充字符，这个底层数组就相当于一个缓冲区 // 而这个缓冲区的大小可以通过BufferedReader(Reader in, int // sz)这个构造方法的第二个参数来指定，默认为8192bytes // 而charLoop则是用来遍历底层数组，每次读完底层数组里的数据，就把这些数据写到一个StringBuffer里， // 直到读到\"\\r\"或\"\\n\"的时候，写入最后一批数据之后就返回结果并退出整个循环 bufferLoop: for (;;) { // nextChar表示下一个要读的字符的位置、nChars=从inputstream中读入的字符数+nextChar if (nextChar >= nChars) fill(); // 读到了inputstream的末尾 if (nextChar >= nChars) { /* EOF */ if (s != null && s.length() > 0) return s.toString(); else return null; } boolean eol = false; char c = 0; int i; /* Skip a leftover '\\n', if necessary */ if (omitLF && (cb[nextChar] == '\\n')) nextChar++; skipLF = false; omitLF = false; // 退出这一层循环有两种情况：1、读到\"\\r\"或者\"\\n\" 2、底层数组cb被读完了 charLoop: for (i = nextChar; i 额，有点复杂，还是先不看了。 public long skip(long n) throws IOException{...} 重写覆盖了父类的skip方法。定义如下： public long skip(long n) throws IOException { if (n 0) { if (nextChar >= nChars) fill(); if (nextChar >= nChars) /* EOF */ break; if (skipLF) { skipLF = false; if (cb[nextChar] == '\\n') { nextChar++; } } long d = nChars - nextChar; if (r 过程比较好理解，首先检查了缓冲区是不是已经被读完，是的话重新填充。之后对换行符做处理。之后判断剩余的字符和所要求的字符长度做比较。 public boolean ready() throws IOException{...} 用来判断”下一个字符”是否可读。定义如下： public boolean ready() throws IOException { synchronized (lock) { ensureOpen(); /* * If newline needs to be skipped and the next char to be read * is a newline character, then just skip it right away. */ if (skipLF) { /* Note that in.ready() will return true if and only if the next * read on the stream will not block. */ if (nextChar >= nChars && in.ready()) { fill(); } if (nextChar public boolean markSupported(){...} 始终返回true，因为BufferedReader支持mark(), reset()。 public void mark(int readAheadLimit) throws IOException{...} 该方法用来标记当前BufferedReader的下一个要读取位置。定义如下： public void mark(int readAheadLimit) throws IOException { if (readAheadLimit public void reset() throws IOException{...} 重置BufferedReader的下一个要读取位置，将其还原到mark()中所保存的位置。 public void reset() throws IOException { synchronized (lock) { ensureOpen(); if (markedChar public void close() throws IOException{...} 关闭流，需要关闭其封装的流，并将其中一些引用置为null。定义如下： public void close() throws IOException { synchronized (lock) { if (in == null) return; try { in.close(); } finally { in = null; cb = null; } } } 参考 BufferedReader 源码分析 JAVA IO 之BufferedReader源码分析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:20:26 "},"源码解读/java.io/InputStreamReader.html":{"url":"源码解读/java.io/InputStreamReader.html","title":"InputStreamReader","keywords":"","body":"InputStreamReader 一个很好的辨认字符流和字节流的方法是：名字中带有stream的是字节流，带有reader或者writer的是字符流。那InputStreamReader是个什么？ 这是一个转换流，即从从字节流转为为字符流的桥梁：它读取字节并将其转码为特定的字符集（这个要参考java.nio.charset.Charset）。这个字符集可以是系统默认的也可以指定的。 每一次触发该类的read方法，都会触发底层的字节流读取一个或多个字节。所以一般为了更好的效率，都会配合缓冲流一起使用。例如： BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); InputStreamReader的结构如下： public class InputStreamReader extends Reader 类声明，该类继承自Reader。 构造方法 重载了6种构造方法。 public InputStreamReader(InputStream in){...} 接受一个字节流作为输入流，使用默认的字符格式。 public InputStreamReader(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object } catch (UnsupportedEncodingException e) { // The default encoding should always be available throw new Error(e); } } 其中sd的声明为private final StreamDecoder sd;，这是一个字节流的转换器。由于没有指定字符集，所以会使用系统默认的字符集UTF-8。 这个类的核心就是这个字节流的转换器。 关于字符集的更多内容可以看另一篇博客。 public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingEx{...} 多了一个字符串的参数，这个参数指定了字符集的名字。如果没有这个字符串对应的字符集的名字，就会抛出UnsupportedEncodingException异常。定义如下： public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException { super(in); if (charsetName == null) throw new NullPointerException(\"charsetName\"); sd = StreamDecoder.forInputStreamReader(in, this, charsetName); } public InputStreamReader(InputStream in, Charset cs){...} 与上一个构造方法相比，第二个参数是字符集的对象，这样就保证了一定存在这个字符集，不会抛出异常了。 public InputStreamReader(InputStream in, Charset cs) { super(in); if (cs == null) throw new NullPointerException(\"charset\"); sd = StreamDecoder.forInputStreamReader(in, this, cs); } public InputStreamReader(InputStream in, CharsetDecoder dec){...} 直接指定了字符转换器。 public InputStreamReader(InputStream in, CharsetDecoder dec) { super(in); if (dec == null) throw new NullPointerException(\"charset decoder\"); sd = StreamDecoder.forInputStreamReader(in, this, dec); } public String getEncoding(); 返回这个流使用的字符集。如果流已经关闭就会返回null。定义如下： public String getEncoding() { return sd.getEncoding(); } 下面是一个测试程序： public static void main(String[] args) { InputStreamReader reader = new InputStreamReader(System.in); String encodeingName = reader.getEncoding(); System.out.println(encodeingName); //UTF8 try { reader.close(); encodeingName = reader.getEncoding(); System.out.println(encodeingName); //null }catch (IOException e){ e.getStackTrace(); } } 这里验证了系统默认的字符集是UTF-8，并且在流关闭的情况下，返回null。 read方法 重载了两个方法，其实都借助于字节流转换器的read方法。 public int read() throws IOException{...} 读取单个字符。 public int read() throws IOException { return sd.read(); } public int read(char cbuf[], int offset, int length) throws IOException{...} 将字节流中的字节转换为字符，并存储在cbuf中，存储位置偏移是offset，要读取的字符长度是length。 public boolean ready() throws IOException {...} 判断下一个字符是不是可读的。同样调用的是字节流转换器的ready方法。 public boolean ready() throws IOException { return sd.ready(); } public void close() throws IOException{...} 关闭流。 public void close() throws IOException { sd.close(); } 参考 Java字节流和字符流的转换器：StreamDecoder Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-26 11:03:41 "},"源码解读/java.io/StringReader.html":{"url":"源码解读/java.io/StringReader.html","title":"StringReader","keywords":"","body":"StringReader 针对源是字符串的字符输入流。是Reader的直接子类。 public StringReader(String s){...} 构造函数，定义如下： public StringReader(String s) { this.str = s; this.length = s.length(); } 其中str和length是该类的两个私有属性，str就是要读取的字符串，length表示字符串的长度。 private void ensureOpen() throws IOException{...} 保证流未关闭。 private void ensureOpen() throws IOException { if (str == null) throw new IOException(\"Stream closed\"); } 这里流没有关闭的意思是str不为null。 public int read() throws IOException{..} 读取单个字符。本质就是取出字符串中特定位置上的字符。 public int read() throws IOException { synchronized (lock) { ensureOpen(); if (next >= length) return -1; return str.charAt(next++); } } 其中，next是下一次要读字符的位置，初始化为0： private int next = 0;。 public int read(char cbuf[], int off, int len) throws IOException{...} 重写的抽象函数。把字符写入到字符数组中的特定位置。 public int read(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off cbuf.length) || (len cbuf.length) || ((off + len) = length) return -1; int n = Math.min(length - next, len); str.getChars(next, next + n, cbuf, off); next += n; return n; } } 在各种越界检查之后，将能够取得的字符赋值到cbuf数组。 public long skip(long ns) throws IOException{...} 跳过若干个字符。特别注意的是，这个参数ns可能是负数。 public long skip(long ns) throws IOException { synchronized (lock) { ensureOpen(); if (next >= length) return 0; // Bound skip by beginning and end of the source long n = Math.min(length - next, ns); n = Math.max(-next, n); next += n; return n; } } 方法中考虑到负数的处理，取得n值的过程很玄妙，学着点。 public boolean ready() throws IOException{...} 流是否已经准备好。定义如下: public boolean ready() throws IOException { synchronized (lock) { ensureOpen(); return true; } } public boolean markSupported(){...} 判断流是否可以标记，对于该类来说，总是返回true。 public void mark(int readAheadLimit) throws IOException{...} public void mark(int readAheadLimit) throws IOException { if (readAheadLimit 把当前next的值设置为mark的值。 public void reset() throws IOException{...} 回退流，这个简单，把当前next的位置设置为mark的当前即可。 public void close(){...} 关闭流，把源str设置为null即可。 学到这个类的时候才对流有了一点认识。流是一个抽象的概念，其实并没有那么高深。对于StringReader，实际上就是读一个长的字符串，在上面套接一个BufferedReader，就能一段一段地读，就是这么个道理。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-26 15:52:39 "},"源码解读/java.io/FileReader.html":{"url":"源码解读/java.io/FileReader.html","title":"FileReader","keywords":"","body":"FileReader 之前学到InputStreamReader，大部分情况下不会直接用InputStreamReader而是用它的子类FileReader。这是一个读取字符文件的方便类。这个类的构造函数默认字符编码和字节缓冲区大小都是适当的。如果想要自己制定这些，那就不要用这个类，而是在FileInputStream上构造一个InputStreamReader。FileReader要用于读取字符流。如果要读取原始字节流，请考虑使用FileInputStream。 结构如下： 只有三个构造方法而已。 public class FileReader extends InputStreamReader 类声明。该类继承自InputStreamReader。 构造方法 三个构造方法，其实本质都是使用了文件字节输入流FileInputStream. public FileReader(String fileName) throws FileNotFoundException{...} 指定文件名字来构造文件读取。所以要承担文件不存在的后果。定义如下： public FileReader(String fileName) throws FileNotFoundException { super(new FileInputStream(fileName)); } public FileReader(File file) throws FileNotFoundException{...} 参数是File对象。定义如下 public FileReader(File file) throws FileNotFoundException { super(new FileInputStream(file)); } 这个构造函数是最常用的，配合BufferedReader，最常见的写法是： BufferedReader in = new BufferedReader(new FileReader('foo.txt')); public FileReader(FileDescriptor fd){...} 参数是FileDescriptor对象，FileDescriptor是一个辅助类，很少用到，所以暂时先不深究了。 public FileReader(FileDescriptor fd) { super(new FileInputStream(fd)); } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 14:25:13 "},"源码解读/java.io/PipedReader.html":{"url":"源码解读/java.io/PipedReader.html","title":"PipedReader","keywords":"","body":"PipedReader & PipedWriter 管道流是使用与在多个线程之间进行信息传递的Java流，被号称是最难使用的流，被使用的频率也非常低。但是管道流是非常有用的，它提供了多线程间信息传输的一种有效手段。 首先需要明白一个概念：什么是管道？ 在一个比较复杂的大型系统中，假如存在某个对象或者数据流需要被进行繁杂的逻辑处理的话，我们可以选择在一个大的组件中进行处理，这种方式简单粗暴，可能会带来某些麻烦，例如要改动、增加或减少一些处理逻辑，可能需要对整个组件进行改动，整个系统看起来没有任何可扩展性和可重用性。 是否有一种模式可以将整个处理流程进行详细划分，划分出的每个小模块互相独立且各自负责一段逻辑处理。这些逻辑处理小模块根据顺序连接起来，前一个模块的输出作为后一个模块的输入，最后一个模块的输出作为最终的处理结果。如果用来，修改逻辑只针对某个模块进行修改，增添或者删除逻辑也可细化到摸个模块颗粒度，并且每个模块都可以课重用，可重用性大大增强？ 有，这就是管道模式。 顾名思义，管道模式就像一条管道把多个对象连接起来，整体看起来就像若干个阀门嵌套在管道中，而处理逻辑就放在阀门上，如下图，需要处理的对象进入管道后，分别经过阀门一、阀门二、阀门三、阀门四，每个阀门都会对进入的对象进行一些逻辑处理，经过一层层的处理后从管道尾处理，此时的对象就是已完成处理的目标对象。下面这幅图形象地说明了这种模式。 管道是Linux中很重要的一种通信方式，就是把程序的输出直接到另一个程序的输入。Java提供了管道流用于线程的通信。管道流一共有四个PipedReader、PipedWriter、PipedInputStream、PipedOutputStream。前两个是字符流，后面是两个字节流。 管道的实现必须是输入流和输出流共同作用的结果。先学习字符管道流。PipedReader的结构如下： 管道字符输入流、用于读取对应绑定的管道字符输出流写入其内置字符缓存数组buffer中的字符、借此来实现线程之间的通信、pr中专门有两个方法供pw调用receive(char c)、receive(char[] b, int off, intlen)、使得pw可以将字符或者字符数组写入pr的buffer中。 关键字 PipedReader中有几个关键字需要弄明白， boolean closedByWriter = false; //标记PipedWriter是否关闭 boolean closedByReader = false; //标记PipedReader是否关闭 boolean connected = false; // 标记PipedWriter与标记PipedReader是否关闭的连接是否关闭 Thread readSide; //拥有PipedReader的线程 Thread writeSide; //拥有PipedWriter的线程 private static final int DEFAULT_PIPE_SIZE = 1024; //用于循环存放PipedWriter写入的字符数组的默认大小 char buffer[]; //用于循环存放PipedWriter写入的字符数组， 这个数组是一个循环buf。 int in = -1; //buf中下一个存放PipedWriter调用此PipedReader的`receive(int c)`时、c在buf中存放的位置的下标。此为初始状态、即buf中没有字符 int out = 0; //buf中下一个被读取的字符的下标 构造函数 重载了4个构造函数。 public PipedReader(PipedWriter src) throws IOException {...} 该方法接受一个PipedWriter的对象作为参数？诶，不是构造的是PipedReader，传Writer的对象做什么。上面管道的图我们可以看到，管道有两端，入端和初端，入端需要有一个输入流，而出端需要一个输出流。这个构造方法的定义如下： public PipedReader(PipedWriter src) throws IOException { this(src, DEFAULT_PIPE_SIZE); } 指定了输出流以及管道的默认大小，即1024。该方法调用下面这个构造方法。 public PipedReader(PipedWriter src, int pipeSize) throws IOException{...} public PipedReader(PipedWriter src, int pipeSize) throws IOException { initPipe(pipeSize); connect(src); } 首先根据指定的管道大小进行初始化，调用的initPipe方法定义如下： private void initPipe(int pipeSize) { if (pipeSize 其中buffer是一个字符数组，用来保存管道数据，所以虽然管道的概念很难理解，但是底层实现很简单。 接着连接输出流，connect方法定义如下： public void connect(PipedWriter src) throws IOException { src.connect(this); } 可见PipedReader中的connect方法调用的是PipedWriter中的connect方法。这样的话，输入和输出流相互就建立了连接。 public PipedReader(){...} 无参数的构造方法，定义如下： public PipedReader() { initPipe(DEFAULT_PIPE_SIZE); } 只是按照默认大小初始化了字符数组，但是没有指定与之相连接的PipedWriter，所以按照这个构造函数实例化得到的对象，在使用之前必须由PipedWriter的一个实例来建立连接。 PipedReader的connect方法和PipedWriter的connect方法实现的是同一个效果，只用其中一方调用就可以建立双向的连接。 public PipedReader(int pipeSize){...} 指定了管道的大小，同样没有建立连接，需要由PipedWriter来建立连接，定义如下: public PipedReader(int pipeSize) { initPipe(pipeSize); } receive方法 PipedWriter对象调用此方法，向PipedReader中的字符数组中字符，线程安全。重载了2个方法。 synchronized void receive(int c) throws IOException{...} 这个方法每次都是写入一个字符。定义如下： synchronized void receive(int c) throws IOException { if (!connected) { throw new IOException(\"Pipe not connected\"); } else if (closedByWriter || closedByReader) { throw new IOException(\"Pipe closed\"); } else if (readSide != null && !readSide.isAlive()) { throw new IOException(\"Read end dead\"); } writeSide = Thread.currentThread(); while (in == out) { if ((readSide != null) && !readSide.isAlive()) { throw new IOException(\"Pipe broken\"); } /* full: kick any waiting readers */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } if (in = buffer.length) { in = 0; } } 当in == out的时候，表示buf中写入的数据已经被读取完了，此时唤醒所有在此对象监控的线程的其他方法，如果一秒钟之后还是满值，则再次唤醒其他方法，直到buf中被读取。当in ，表示buf中存放第一个字符，此时将buf中存放位置的下标in初始化为0，读取下标也初始化为0，准备接受写入的洗衣歌字符。如果buf中放满了，则再从头开始。 synchronized void receive(char c[], int off, int len) throws IOException{...} 这个方法向buf中写入字符数组c中的一部分值。定义如下： synchronized void receive(char c[], int off, int len) throws IOException { while (--len >= 0) { receive(c[off++]); } } 每次写入一个值，循环调用。 synchronized void receivedLast(){...} 提醒所有等待的线程、已经接收到了最后一个字符、PipedWriter已关闭。用于PipedWriter的close()方法。定义如下： synchronized void receivedLast() { closedByWriter = true; notifyAll(); } read方法 顾名思义，就是从buf中读取数据， 以整数的形式返回。重载了两个方法。 public synchronized int read() throws IOException {...} public synchronized int read() throws IOException { if (!connected) { throw new IOException(\"Pipe not connected\"); } else if (closedByReader) { throw new IOException(\"Pipe closed\"); } else if (writeSide != null && !writeSide.isAlive() && !closedByWriter && (in = buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } return ret; } 如果这个管道还没有数据写入过，在存在写入线程的情况下，等待两轮，如果还没有写入就抛出异常。在等待的过程中唤醒在此对象上监控的线程的其他方法，然后自己等待1秒再次尝试读。否则就读取值然后将in推进一个。如果buf已经满了，就把out值重置。如果buf是空的，就把in值置为-1。当写入流关闭的情况下返回-1。 public synchronized int read(char cbuf[], int off, int len) throws IOException{...} 将buf中的值读取到字符数组cbuf中，返回的是实际读取的字符长度。 public synchronized int read(char cbuf[], int off, int len) throws IOException { if (!connected) { throw new IOException(\"Pipe not connected\"); } else if (closedByReader) { throw new IOException(\"Pipe closed\"); } else if (writeSide != null && !writeSide.isAlive() && !closedByWriter && (in cbuf.length) || (len cbuf.length) || ((off + len) = 0) && (--len > 0)) { cbuf[off + rlen] = buffer[out++]; rlen++; if (out >= buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } } return rlen; } 在读取第一个字符的时候可能存在等待状态，第一个读取成功后，后面的就顺利了，为什么？因为重入锁。 public synchronized boolean ready() throws IOException{...} 查看此流是否可读、看各个线程是否关闭、以及buffer中是否有可供读取的字符。 public synchronized boolean ready() throws IOException { if (!connected) { throw new IOException(\"Pipe not connected\"); } else if (closedByReader) { throw new IOException(\"Pipe closed\"); } else if (writeSide != null && !writeSide.isAlive() && !closedByWriter && (in public void close() throws IOException{...} 释放资源。 public void close() throws IOException { in = -1; closedByReader = true; } 测试程序 PipedReader和PipedWriter两者必须配合使用，下面是一个简单的测试程序； //用于接受字符的线程 @SuppressWarnings(\"all\") public class CharReceiveThread implements Runnable{ private PipedReader pr = new PipedReader(); @Override public void run() { //receiveOnChar(); //receiveShortMessage(); receiveLongMessage(); } public PipedReader getPr() { return pr; } private void receiveOnChar(){ try { int n = pr.read(); System.out.println(n); pr.close(); }catch (IOException e){ e.getStackTrace(); } } private void receiveShortMessage(){ try { char [] b = new char[1024]; int n = pr.read(b); System.out.println(new String(b, 0, n)); pr.close(); }catch (IOException e){ e.getStackTrace(); } } private void receiveLongMessage(){ try { char [] b = new char[2048]; int count = 0; while (true){ count = pr.read(b); for (int i = 0; i //发送字符的线程 @SuppressWarnings(\"all\") public class CharSenderThread implements Runnable{ @Override public void run() { //sendOneChart(); //sendShortMessage(); sendLongMessage(); } private PipedWriter pw = new PipedWriter(); public PipedWriter getPw() { return pw; } private void sendOneChart(){ try { pw.write('a'); pw.flush(); pw.close(); }catch (IOException e){ e.getStackTrace(); } } private void sendShortMessage(){ try { pw.write(\"this is a short message from CharSenderThread !\".toCharArray()); pw.flush(); pw.close(); }catch (IOException e){ e.getStackTrace(); } } private void sendLongMessage(){ char [] b = new char[1028]; //生成一个长度为1028的字符数组，前1020个是a， 后8个是b for (int i = 0; i 测试程序： public class PipedReaderAndPipedReaderTest { public static void main(String[] args) throws IOException{ CharReceiveThread cst = new CharReceiveThread(); CharSenderThread crt = new CharSenderThread(); PipedReader pr = cst.getPr(); PipedWriter pw = crt.getPw(); pw.connect(pr); new Thread(cst).start(); new Thread(crt).start(); } } 总结 PipedReader、PipedWriter两者的结合如鸳鸯一般、离开哪一方都不能继续存在，同时又如连理枝一般。PipedWriter先通过connect(PipedReader sink)来确定关系、并初始化PipedReader状态、告诉PipedReader只能属于这个PipedWriter、connect =true、当想赠与PipedReader字符时、就直接调用receive(char c) 、receive(char[] b, int off, int len)来将字符或者字符数组放入pr的存折buffer中。站在PipedReader角度上、看上哪个PipedWriter时就暗示pw、将主动权交给pw、调用pw的connect将自己给他去登记。当想要花（将字符读取到程序中）字符了就从buffer中拿、但是自己又没有本事挣字符、所以当buffer中没有字符时、自己就等着、并且跟pw讲没有字符了、pw就会向存折（buffer）中存字符、当然、pw不会一直不断往里存、当存折是空的时候也不会主动存、怕花冒、就等着pr要、要才存。过到最后两个只通过buffer来知道对方的存在与否、每次从buffer中存或者取字符时都会看看对方是否安康、若安好则继续生活、若一方不在、则另一方也不愿独存！ 参考 管道模式——pipeline与valve Java流编程实例之四--管道流 Java_io体系之PipedWriter、PipedReader简介、走进源码及示例 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 12:45:24 "},"源码解读/java.io/CharArrayReader.html":{"url":"源码解读/java.io/CharArrayReader.html","title":"CharArrayReader","keywords":"","body":"CharArrayReader 这个流针对的媒介是字符数组。结构如下： 构造方法 重载了两个构造方法。 public CharArrayReader(char buf[]){...} 参数buf就是指定的源。定义如下 public CharArrayReader(char buf[]) { this.buf = buf; this.pos = 0; this.count = buf.length; } buf、pos和count是类的受保护的属性，分别是字符缓冲区、当前字符缓冲区的位置和字符缓冲区中最后一个字符所在的索引（注意，这个标识的是下标而不是个数）。 public CharArrayReader(char buf[], int offset, int length){...} 参数buf指定了源，但是与上一个构造方法不同的是，虽然最终在字符缓冲区中的字符是一样的，但是pos和count最终会导致这个流真正使用的字符区域不同。定义如下： public CharArrayReader(char buf[], int offset, int length) { if ((offset buf.length) || (length private void ensureOpen() throws IOException{..} 保证流打开状态，只要保证源存在即可，定义如下： private void ensureOpen() throws IOException { if (buf == null) throw new IOException(\"Stream closed\"); } read方法 重载了两种read方法。分别用来读取单个字符和多个字符。线程安全。 public int read() throws IOException{...} 用来读取单个字符。 public int read() throws IOException { synchronized (lock) { ensureOpen(); if (pos >= count) return -1; else return buf[pos++]; } } public int read(char b[], int off, int len) throws IOException{...} 取得源中的一部分字符到字符数组b中的特定区域。定义如下： public int read(char b[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off b.length) || (len b.length) || ((off + len) = count) { return -1; } if (pos + len > count) { len = count - pos; } if (len 实现过程很简单。 public long skip(long n) throws IOException{...} 跳过若干个字符。返回实际跳过的字符个数。 public long skip(long n) throws IOException { synchronized (lock) { ensureOpen(); if (pos + n > count) { n = count - pos; } if (n public boolean ready() throws IOException{...} 流是否可读。定义如下： public boolean ready() throws IOException { synchronized (lock) { ensureOpen(); return (count - pos) > 0; } } 首先保证了流的源未关闭，然后需要还有内容可读。 public boolean markSupported(){...} 是否支持可标记，永远返回true。 public void mark(int readAheadLimit) throws IOException{...} 标记，这个方法重写了父类的方法 public void mark(int readAheadLimit) throws IOException { synchronized (lock) { ensureOpen(); markedPos = pos; } } 并没有用到参数readAheadLimit，标记的过程就是将当前读的位置记录下来。 public void reset() throws IOException{...} 重置流，很简单，有之前标记过的值，把pos值重新设置成被标记的值即可。 public void reset() throws IOException { synchronized (lock) { ensureOpen(); pos = markedPos; } } public void close(){...} 关闭流，就是将源设置为null即可。 public void close() { buf = null; } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 14:20:20 "},"源码解读/java.io/FilterReader.html":{"url":"源码解读/java.io/FilterReader.html","title":"FilterReader","keywords":"","body":"FilterReader 这是一个抽象类，除了构造方法其他方法都重写了来自父抽象类Reader的方法。子类必须重写这些方法并且有自己的特色。结构如下： protected FilterReader(Reader in){...} 构造方法，接受一个Reader实例作为源，可见FilterReader是一个处理类而不是一个节点流。定义如下： protected FilterReader(Reader in) { super(in); this.in = in; } 之后的所有方法都是借助这个源本身的同名方法进行的。FilterReader的子类必须重写其中的抽象方法，还得有自己特色的方法。JDK提供了这样一个FilterReader的子类PushbackReader。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:25:46 "},"源码解读/java.io/PushbackReader.html":{"url":"源码解读/java.io/PushbackReader.html","title":"PushbackReader","keywords":"","body":"PushbackReader \"push back\"是回退的意思，所以PushbackReader就是回退流。这是一个将字符退回到输入流中的字符输入流。什么叫做退回？ 在JAVA IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在JAVA中提供了一种回退输入流，可以把读取进来的某些数据重新回退到输入流的缓冲区之中。下面这幅图解释了回退流的工作原理 回退流和一般流中reset方法有区别？ 结构如下： 参考 跟我学IO（PushbackReader类） Java IO操作——回退流PushbackInputStream Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:38:29 "},"源码解读/java.io/Writer.html":{"url":"源码解读/java.io/Writer.html","title":"Writer","keywords":"","body":"Writer Writer是字符输出流的基础。结构如下： 可以看到方法和Reader基本上是对应的。同样是一个抽象类，子类只用实现write(char[], int, int)和flush()和close()方法即可。但是一般子类为了有更好的实现，会重新覆盖其他方法，并加入自己的实现。 public abstract class Writer implements Appendable, Closeable, Flushable 类声明，抽象类，实现了Appendable、Closeable和Flushable接口。 构造方法 与Writer一样重载了两个构造方法，无参方法将自身作为同步对象，有参构造方法指定同步对象。 write方法 重载了5个write方法。 abstract public void write(char cbuf[], int off, int len) throws IOException; 将字符输出中的内容从off位置开始的，len长度的字符输出到输出流中。 public void write(String str, int off, int len) throws IOException{...} 将字符串中的字符输出到输出流中，定义如下： public void write(String str, int off, int len) throws IOException { synchronized (lock) { char cbuf[]; if (len 可以看到该方法线程安全，其中WRITE_BUFFER_SIZE是Java规定的缓冲区的最大尺寸，默认1024。其中writeBuffer是缓冲区。在这个方法里， 对cbuf做了处理，如果要写的字符长度小于1024，就之间将writeBuffer的地址赋值给cbuf而不是重新申请内容空间，如果大于1024，则重新空间。可以回想下Reader中skipBuffer申请空间的时机。skipBuffer只有每次不够用的时候才会重新申请内存。 public void write(int c) throws IOException {...} 写入单个字符。 public void write(int c) throws IOException { synchronized (lock) { if (writeBuffer == null){ writeBuffer = new char[WRITE_BUFFER_SIZE]; } writeBuffer[0] = (char) c; write(writeBuffer, 0, 1); } } public void write(char cbuf[]) throws IOException{...} 将整个字符串数组写入输出流。 public void write(char cbuf[]) throws IOException { write(cbuf, 0, cbuf.length); } public void write(String str) throws IOException{...} 将整个字符串写入输出流。 public void write(String str) throws IOException { write(str, 0, str.length()); } append方法 这是在实现Appendable接口，重载了3个方法。需要注意的是这个方法的返回值是this，所以这个方法可以用链式的写法。 public Writer append(CharSequence csq) throws IOException {...} 将CharSequence类对象的值写入输出流。在空指针判断之后调用以string对象为参数的write方法。定义如下： public Writer append(CharSequence csq) throws IOException { if (csq == null) write(\"null\"); else write(csq.toString()); return this; } public Writer append(CharSequence csq, int start, int end) throws IOException{...} 与上面的append很不同的一点是，当csq是空指针的时，方法仍然能够继续，因为此时会给scq赋值为“null”？？？为什么要这样? public Writer append(CharSequence csq, int start, int end) throws IOException { CharSequence cs = (csq == null ? \"null\" : csq); write(cs.subSequence(start, end).toString()); return this; } public Writer append(char c) throws IOException{...} 参数是单个字符。定义如下： public Writer append(char c) throws IOException { write(c); return this; } abstract public void flush() throws IOException; 刷新流。 如果流已经从缓冲区中的各种write（）方法保存了任何字符，请将它们立即写入到其预期目的地。 然后，如果该目标是另一个字符或字节流，请将其清空。 因此，一个flush（）调用将刷新Writers和OutputStreams链中的所有缓冲区。 如果该流的预期目的地是由底层操作系统（例如文件）提供的抽象，那么刷新流仅保证先前写入流的字节被传递到操作系统进行写入; 它并不保证它们实际上被写入物理设备，如磁盘驱动器。 abstract public void close() throws IOException; 关闭流。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-25 18:25:34 "},"源码解读/java.io/PipedWriter.html":{"url":"源码解读/java.io/PipedWriter.html","title":"PipedWriter","keywords":"","body":"PipedWriter 管道字符输出流、用于将当前线程的指定字符写入到与此线程对应的管道字符输入流中去、所以PipedReader（pr）、PipedWriter（pw）必须配套使用、缺一不可。 管道字符输出流的本质就是调用pr中的方法将字符或者字符数组写入到pr中、这一点是与众不同的地方。所以pw中的方法很少也很简单、主要就是负责将传入的pr与本身绑定、配对使用、然后就是调用绑定的pr的写入方法、将字符或者字符数组写入到pr的缓存字符数组中。PipedWriter的结构如下： 可以看到，PipedWriter的结构明显比PipedReader，两者的方法并不是对称的，那是因为每次PipedWriter写数据的都是调用与之连接的PipedReader的receive方法，并且写入的地方是PipedReader中定义的字符数组。所以在下面的很多方法中可以看到，PipedWriter的实现大部分都是在调用PipedReader中的方法。 public synchronized void connect(PipedReader snk) throws IOException{...} 该方法用来连接一个字符输入流。这个输入流必须是未连接的，否则的话会抛出IOException异常，如果当前输出流已经由输入流关闭，那么不能建立连接。 public synchronized void connect(PipedReader snk) throws IOException { if (snk == null) { throw new NullPointerException(); } else if (sink != null || snk.connected) { throw new IOException(\"Already connected\"); } else if (snk.closedByReader || closed) { throw new IOException(\"Pipe closed\"); } sink = snk; snk.in = -1; snk.out = 0; snk.connected = true; } 保障了建立连接的前提之后，需要设置几个量。注意到PipedReader的属性in表示下一次要写入的位置，out表示下一次要读的位置。 可以将管道看成这样的一个形式，一个“管道”实际上是一个特定长度的字符数组，而这个数组实际上从属于PipedReader。数组从0到n，PipedWriter从-1端开始写，PipedReader从0开始开始读。咦，这不就是队列吗？ write方法 虽然“写”这个操作是PipedWriter主导的，但是实际上真正操作的一方是PipedReader。重载了2个方法。至于，由于receive方法是线程安全的，所以write方法也是线程安全的。 public void write(int c) throws IOException{...} 向PipedReader中的buf写入一个字符。 public void write(int c) throws IOException { if (sink == null) { throw new IOException(\"Pipe not connected\"); } sink.receive(c); } public void write(char cbuf[], int off, int len) throws IOException {...} 向PipedReader中的buf写入cbuf数组中的一部分数据 public void write(char cbuf[], int off, int len) throws IOException { if (sink == null) { throw new IOException(\"Pipe not connected\"); } else if ((off | len | (off + len) | (cbuf.length - (off + len))) public synchronized void flush() throws IOException{...} 刷新此流并强制写入任何缓冲输出的字符。并且会唤醒在PipedReader对象上等待的所有线程。 public synchronized void flush() throws IOException { if (sink != null) { if (sink.closedByReader || closed) { throw new IOException(\"Pipe closed\"); } synchronized (sink) { sink.notifyAll(); } } } public void close() throws IOException{...} 关闭此流。 public void close() throws IOException { closed = true; if (sink != null) { sink.receivedLast(); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 12:14:15 "},"源码解读/java.io/CharArrayWriter.html":{"url":"源码解读/java.io/CharArrayWriter.html","title":"CharArrayWriter","keywords":"","body":"CharArrayWriter 与CharArrayReader相对应，要把字符存入字符数组中。这个字符数组的大小会随着数据写入自动增长，最后可以使用toChartArray()或toString()方法来转化为字符串。 构造函数 重载了两个构造函数。区别在于是否指定初始化字符数组的大小。 public CharArrayWriter(){...} 无参数构造方法，默认缓冲区的初始化大小是32。 public CharArrayWriter() { this(32); } public CharArrayWriter(int initialSize){...} 指定了缓冲区的空间大小。 public CharArrayWriter(int initialSize) { if (initialSize write方法 用来将一个或多个字符写入字符数组。重载三个方法。线程安全。 public void write(int c){...} public void write(int c) { synchronized (lock) { int newcount = count + 1; if (newcount > buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length 之前提到过，字符数组的大小会随着字符的写入自动增长，怎么实现的呢？从这个方法就可以找到答案了。当空间不足时候，会重新申请一个更大的空间作为缓冲区，那么这个新的空间到底应该多大呢？这里的策略是取当前空间大小的2倍和（当前空间大小 + 1）中取最大值。所以可以得出结论，如果当初未指定初始化的大小，即初始化大小是默认的32，之后每次都写入1个字符，那么空间的大小变化是32，64，128....，2倍2倍增长。 还有一点需要注意，这里的count和CharArrayReader中的count表示的含义不同。在CharArrayReader中，count表示的是流能读取的字符区域的末端索引，是下标值，而CharArrayWriter中的count表示已经写入的字符的个数，也是下一次要写入字符的位置。 public void write(char c[], int off, int len){...} 将字符数组c的一部分区域数据写入缓冲区，定义如下： public void write(char c[], int off, int len) { if ((off c.length) || (len c.length) || ((off + len) buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length 同样的空间增长策略。 源码已经读了很多了，发现在有些类的实现中会采取缓冲区的方式，实际上就是一个内部的私有数组，在这个缓冲区的初始化和空间的使用、增长策略上都不太一样，听哟䬥的，在阅读集合类的时候可以整理一个专题。 public void write(String str, int off, int len){...} 同样的道理，只是第一个参数是String类型，其实String的内部实现也是一个字符数组啊。定义如下： public void write(String str, int off, int len) { synchronized (lock) { int newcount = count + len; if (newcount > buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length public void writeTo(Writer out) throws IOException{...} 把缓冲区的中的内容写到另一个Writer实例的缓冲区中。定义如下： public void writeTo(Writer out) throws IOException { synchronized (lock) { out.write(buf, 0, count); } } append方法 追加数据，对于缓冲区来说是效果是一样的，都是往后写，不同的是接受的参数已经返回值，返回本身，所以append方法可以采取链式写法。重载了3个方法。 public CharArrayWriter append(CharSequence csq){...} 将整个CharSequence对象添加到缓冲区。 public CharArrayWriter append(CharSequence csq) { String s = (csq == null ? \"null\" : csq.toString()); write(s, 0, s.length()); return this; } 很有趣的一点是，如果参数为null，那字符串\"null\"将被追加到缓冲区，这个情况以前在StringBuffer（不知道有没有记错）中也出现过，不知道这样的设计意图是什么？ public CharArrayWriter append(CharSequence csq, int start, int end){...} 将CharSequence对象的一部分添加到缓冲区 public CharArrayWriter append(CharSequence csq, int start, int end) { String s = (csq == null ? \"null\" : csq).subSequence(start, end).toString(); write(s, 0, s.length()); return this; } public CharArrayWriter append(char c){...} 向缓冲区中写入单个字符。定义如下： public CharArrayWriter append(char c) { write(c); return this; } public void reset(){...} 重置流。定义如下： public void reset() { count = 0; } 很简单，将count置为0，虽然缓冲区中仍然有数据未清除，但是下一次再往缓冲区中写入数据的时候会覆盖这部分的内容。 public char toCharArray()[]{...} public char toCharArray()[] { synchronized (lock) { return Arrays.copyOf(buf, count); } } 复制一份缓冲区的副本返回。道理我都懂，但是这个方法签名写法有点怪啊，刚开始我咋一看还以为找到了一个编译器都没有检查出来的JDK源码的BUG（事实证明这是不可能的 :) ），一般来说，写成public char[] toCharArray(){..}这种比较好理解吧。 public int size(){return count;} 返回缓冲区的大小，说的就是count的值。 public String toString(){...} 取得缓冲区的String值，实现超简单： public String toString() { synchronized (lock) { return new String(buf, 0, count); } } public void flush() { } 刷新流。注意这个方法没有方法体！ public void close() { } 关闭流。！！！ 没有方法体，也就是说调用这个方法后其实没有什么用，源还是存在的，仍旧可以被使用。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:08:44 "},"源码解读/java.io/FilterWriter.html":{"url":"源码解读/java.io/FilterWriter.html","title":"FilterWriter","keywords":"","body":"FilterWriter 抽象类，除了构造函数都重写了自父类Write中的方法。结构如下： protected FilterWriter(Writer out) {...} 构造方法。接受一个 Writer实例作为源，所以它是一个处理流而不是一个节点流。 protected FilterWriter(Writer out) { super(out); this.out = out; } 实际上，该类后面所有的方法实现都是将问题重新抛给了这个源自己去解决的。子类继承FilterWriter的话，必须重写其中的抽象方法，还要有自己的特色，但是目前为止，JDK中并没有一个提供一个FilterWriter的子类。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:22:43 "},"源码解读/java.nio/java-nio.html":{"url":"源码解读/java.nio/java-nio.html","title":"java.nio","keywords":"","body":"java.nio NIO是“同步非阻塞”，1.7才开始支持异步非阻塞的，即AIO。 具体的BIO、NIO和AIO相关概念可以参考整理的NIO博文。 下面是网络上对于NIO的一个形象的解释。 其中Channel对应以前的流，Buffer不是什么新东西，Selector是因为nio可以使用异步的非堵塞模式才加入的东西。 以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。 nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。 当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。(?这里还想不对吧，“节水工人会通知他们”，这种说法说的好像是异步，但是NIO是同步的) 这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。 Buffer NIO中的Buffer和旧IO包中的BufferedInputStream、BufferedReader、BufferedOutputStream、BufferedWriter有什么区别？ 在Java NIO中，缓冲区的作用也是用来临时存储数据，可以理解为是I/O操作中数据的中转站。缓冲区直接为通道(Channel)服务，写入数据到通道或从通道读取数据，这样的操利用缓冲区数据来传递就可以达到对数据高效处理的目的。在NIO中主要有八种缓冲区类(其中MappedByteBuffer是专门用于内存映射的一种ByteBuffer)： Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-24 21:22:29 "},"源码解读/java.nio/java.nio.Charset/java-Charset.html":{"url":"源码解读/java.nio/java.nio.Charset/java-Charset.html","title":"java.Charset","keywords":"","body":"java.Charset Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/java.nio.Charset/Charset.html":{"url":"源码解读/java.nio/java.nio.Charset/Charset.html","title":"Charset","keywords":"","body":"Charset Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/java.nio.Channels/java.nio.Channels.html":{"url":"源码解读/java.nio/java.nio.Channels/java.nio.Channels.html","title":"java.nio.Channels","keywords":"","body":"java.nio.Channels ch Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-24 19:00:19 "},"源码解读/java.nio/java.nio.Channels/Channel.html":{"url":"源码解读/java.nio/java.nio.Channels/Channel.html","title":"Channel","keywords":"","body":"Channel Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:19:17 "},"源码解读/java.nio/java.nio.Channels/FileChannel.html":{"url":"源码解读/java.nio/java.nio.Channels/FileChannel.html","title":"FileChannel","keywords":"","body":"FileChannel public abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel,GatheringByteChannel, ScatteringByteChannel 类定义。继承了AbstractInterruptibleChannel，实现了很多接口。注意到这个类是一个抽象类，不能实例化。 构造方法 FileChannel有一个构造方法，但是是受保护的，所以外部不能实例化，当然不能实例化，因为本身就是一个抽象类。 protected FileChannel() { } 那么我们如何取得实例呢，那只能靠这个抽象类的实现类了。比如FileSystemImpl，我们可以利用RandomAccessFile或者FileInputStream的getChannel()方法来取得一个该抽象类的实例。 open方法 重载了两个open方法。 public static FileChannel open(Path path, Set options, FileAttribute... attrs) throws IOException { FileSystemProvider provider = path.getFileSystem().provider(); return provider.newFileChannel(path, options, attrs); } public static FileChannel open(Path path, OpenOption... options) throws IOException { Set set = new HashSet(options.length); Collections.addAll(set, options); return open(path, set, NO_ATTRIBUTES); } Emmmm 具体不知道干什么用，先放着。 read方法 重载了三个read的抽象方法，具体的实现参见子类。这个类的作用就是将数据从channel中读到ByteBuffer中，注意这个方法的参数中的ByteBuffer类实例。 public abstract int read(ByteBuffer dst) throws IOException; public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException; public final long read(ByteBuffer[] dsts) throws IOException { return read(dsts, 0, dsts.length); } write方法 Channel具有双向读和写的功能，这一点和BIO中的各种stream是不一样，的stream只有一个方法的功能，要么读，要么写。 同样重载了三个方法，都是抽象方法，需要子类重写。 public abstract int write(ByteBuffer src) throws IOException; public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException; public final long write(ByteBuffer[] srcs) throws IOException { return write(srcs, 0, srcs.length); } 剩下的方法用的场景很少，所以暂且先不看了。 NIO中FileChannel和BIO中FileInputStream对比 我们通过一个例子来了解一下BIO中FileInputStream和NIO中FileChannel的使用对比。例子的功能是——从文件中读取内容并显示： 使用FileInputStream的例子： public static void readFileWithBIO(){ BufferedInputStream in = null; try{ in = new BufferedInputStrean(new FileInputStream(\"../BIO.txt\")); byte[] buf = new byte[1024]; int readLength = in.read(buf); while(readLength != -1){ for (int i = 0; i 使用FileChannel的例子： public static void method2(){ RandomAccessFile aFile = null; try{ aFile = new RandomAccessFile(\"../NIO.txt\"); FileChannel filechannel = aFile.getChannel(); ByteBuffer buf = ByteBuffer.allocation(1024); int byteRead = filechannel.read(buf); while(byteRead != -1){ buf.flip(); while(buf.hasReamining()){ System.out.print((char)buf.get() + \" \"); buf.compact(); byteRead = filechannel.read(buf); } } }catch (IOException e){ e.printStackTrace(); }finally{ try{ if (aFile != null) { aFile.close(); } }catch (IOException e){ e.printStackTrace(); } } } 再来看一个复制文件的例子: public class CopyFileTest { /** * 使用BIO中的FileInputStream和FileOutInput来复制文件 * @param fromPath 源文件地址 * @param toPath 目标文件地址 */ public static void fileCopyWithBIO(String fromPath, String toPath) throws IOException{ File formFile = new File(fromPath); if (!formFile.exist()) throw new IOException(\"origin file is not exist\"); File toFile = new File(toPath); if (!toFile.exists()){ toFile.createNewFile(); } try (InputStream in = new BufferedInputStream(new FileInputStream(fromPath)); OutputStream out = new BufferedOutputStream(new FileOutputStream(toFile))){ byte[] buf = new byte[1024]; int byteRead; while ((byteRead = in.read(buf)) != -1){ out.write(buf, 0, byteRead); } }catch (IOException e){ e.printStackTrace(); } } /** * 利用NIO中的FileChannle来复制文件 * @param fromPath * @param toPath */ public static void fileCopyWithFileChannel(String fromPath, String toPath) throws IOException{ File fromFile = new File(fromPath); if (fromFile == null) throw new IOException(\"origin file is not exist\"); File toFile = new File(toPath); if (!toFile.exists()){ toFile.createNewFile(); } try (FileInputStream in = new FileInputStream(fromFile); FileOutputStream out = new FileOutputStream(toFile); FileChannel fileChannelInput = in.getChannel(); FileChannel fileChannelOutput = out.getChannel()){ // 两个channel之间通信 fileChannelInput.transferTo(0, fileChannelInput.size(), fileChannelOutput); }catch (IOException e){ e.printStackTrace(); } } } 分别使用了BIO和NIO中来实现文件的拷贝。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 19:13:30 "},"源码解读/java.nio/java.nio.Channels/DatagramChannel.html":{"url":"源码解读/java.nio/java.nio.Channels/DatagramChannel.html","title":"DatagramChannel","keywords":"","body":"DatagramChannel DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。 这里又一次说到了TCP和UDP。我们回顾一下两者的区别。 TCP是面向连接的可靠传输层协议，适用于一些对传输准确性高或者本身有连接概念，但是对实时性要求不高的场景，在复杂较差的网络中也能保证准确性。 UDP是无连接不可靠的传输层协议，适用于对传输实时性要求高，但对传输准确性要求比较低的场景，如果网络比较差，那么准确性就真的不能保证了。 基于两者的特点，TCP可以用于网络数据库，分布式高精度计算系统的数据传输；UDP可以用于服务系统内部之间的数据传输，因为数据可能比较多，内部系统局域网内的丢包错包率又很低，即便丢包，顶多是操作无效，这种情况下，UDP经常被使用。 该类结果如下： public abstract class DatagramChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel 类声明，抽象类，不可实例化，我们已经可以预见，这个类会提供静态方法（open）取得实例。 该类的实现类如下: 注意这两个实现类在sun包下。 open 打开通道的方法： public static DatagramChannel open() throws IOException { return SelectorProvider.provider().openDatagramChannel(); } public static DatagramChannel open(ProtocolFamily family) throws IOException { return SelectorProvider.provider().openDatagramChannel(family); } 实际上，这个方法就是所谓的创建对象的方法，总之我们现在已经得到了一个DatagramChannel的实例。 socket方法 在DatagramChannel中，这是一个抽象方法，由子类去实现： public abstract DatagramSocket socket(); 取得一个DatagramSocket的实例。如果我们要接受来自一个UDP端口的数据，需要使用这个实例的bind方法将其绑定到一个端口上，一个完整的程序如下： DatagramChannel channel = DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(9999); 这样channel就能接受来自端口9999的数据了。注意这时候是作为服务端。 connect方法 这是作为客户端，连接到网络中特定的地址： public abstract DatagramChannel connect(SocketAddress remote) throws IOException; 注意，由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。例如： channel.connect(new InetSocketAddress(\"jenkov.com\", 80)); 例子 打开 DatagramChannel DatagramChannel channel = DatagramChannel.open(); channel.socket().bind(new InetSocketAddress(9999)); 接受数据： ByteBuffer buf = ByteBuffer.allocate(48); buf.clear(); channel.receive(buf); receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。 发送数据： String newData = \"New String to write to file...\" + System.currentTimeMillis(); ByteBuffer buf = ByteBuffer.allocate(48); buf.clear(); but.put(newData.getBytes()); buf.flip(); int bytesSent = channel.send(buf, new InetSocketAddress(\"jenkov.com\", 80)); 这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。 连接到特定的地址： 可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。例如： channel.connect(new InetSocketAddress(\"jenkov.com\", 80)); 当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子： int bytesRead = channel.read(buf); int bytesWritten = channel.write(but); 以下是一个服务器端和客户端发送UDP消息的例子： // UDP协议服务器端 public class DatagramChannelServerDemo { private int port = 9975; DatagramChannel channel; private Charset charset = Charset.forName(\"UTF-8\"); private Selector selector = null; public DatagramChannelServerDemo() throws IOException { try { selector = Selector.open(); channel = DatagramChannel.open(); } catch (Exception e) { selector = null; channel = null; System.out.println(\"超时\"); } System.out.println(\"服务器启动\"); } /* 编码过程 */ public ByteBuffer encode(String str) { return charset.encode(str); } /* 解码过程 */ public String decode(ByteBuffer bb) { return charset.decode(bb).toString(); } /* 服务器服务方法 */ public void service() throws IOException { if(channel==null || selector==null) return; //设置为非阻塞模式 DatagramChannel类的configureBlocking(blooean block)block为true则通道处于阻塞模式，block为false则通道处于非阻塞模式 channel.configureBlocking(false); //绑定到特定的端口上 channel.socket().bind(new InetSocketAddress(port)); // channel.write(ByteBuffer.wrap(new String(\"aaaa\").getBytes())); channel.register(selector, SelectionKey.OP_READ); /** 外循环，已经发生了SelectionKey数目 */ while (selector.select() > 0) { System.out.println(\"有新channel加入\"); /* 得到已经被捕获了的SelectionKey的集合 */ Iterator iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) { SelectionKey key = null; try { key = (SelectionKey) iterator.next(); iterator.remove(); if (key.isReadable()) { reveice(key); } if (key.isWritable()) { // send(key); } } catch (IOException e) { e.printStackTrace(); try { if (key != null) { key.cancel(); key.channel().close(); } } catch (ClosedChannelException cex) { e.printStackTrace(); } } } /* 内循环完 */ } /* 外循环完 */ } /* * 接收 用receive()读IO * 作为服务端一般不需要调用connect()，如果未调用connect()时调用read()\\write()读写，会报java.nio.channels * .NotYetConnectedException 只有调用connect()之后,才能使用read和write. */ synchronized public void reveice(SelectionKey key) throws IOException { if (key == null) return; // ***用channel.receive()获取客户端消息***// // ：接收时需要考虑字节长度 DatagramChannel sc = (DatagramChannel) key.channel(); String content = \"\"; // create buffer with capacity of 48 bytes ByteBuffer buf = ByteBuffer.allocate(1024);// java里一个(utf-8)中文3字节,gbk中文占2个字节 buf.clear(); SocketAddress address = sc.receive(buf); // read into buffer. 返回客户端的地址信息 String clientAddress = address.toString().replace(\"/\", \"\").split(\":\")[0]; String clientPost = address.toString().replace(\"/\", \"\").split(\":\")[1]; buf.flip(); // make buffer ready for read while (buf.hasRemaining()) { buf.get(new byte[buf.limit()]);// read 1 byte at a time content += new String(buf.array()); } buf.clear(); // make buffer ready for writing System.out.println(\"接收：\" + content.trim()); // 第一次发；udp采用数据报模式，发送多少次，接收多少次 ByteBuffer buf2 = ByteBuffer.allocate(65507); buf2.clear(); buf2 .put(\"消息推送内容 abc..UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端@Q\" .getBytes()); buf2.flip(); channel.send(buf2, new InetSocketAddress(clientAddress,Integer.parseInt(clientPost))); // 将消息回送给客户端 // 第二次发 ByteBuffer buf3 = ByteBuffer.allocate(65507); buf3.clear(); buf3.put(\"任务完成\".getBytes()); buf3.flip(); channel.send(buf3, new InetSocketAddress(clientAddress, Integer.parseInt(clientPost))); // 将消息回送给客户端 } int y = 0; public void send(SelectionKey key) { if (key == null) return; // ByteBuffer buff = (ByteBuffer) key.attachment(); DatagramChannel sc = (DatagramChannel) key.channel(); try { sc.write(ByteBuffer.wrap(new String(\"aaaa\").getBytes())); } catch (IOException e1) { e1.printStackTrace(); } System.out.println(\"send2() \" + (++y)); } /* 发送文件 */ public void sendFile(SelectionKey key) { if (key == null) return; ByteBuffer buff = (ByteBuffer) key.attachment(); SocketChannel sc = (SocketChannel) key.channel(); String data = decode(buff); if (data.indexOf(\"get\") == -1) return; String subStr = data.substring(data.indexOf(\" \"), data.length()); System.out.println(\"截取之后的字符串是 \" + subStr); FileInputStream fileInput = null; try { fileInput = new FileInputStream(subStr); FileChannel fileChannel = fileInput.getChannel(); fileChannel.transferTo(0, fileChannel.size(), sc); fileChannel.close(); } catch (IOException e) { e.printStackTrace(); } finally { try { fileInput.close(); } catch (IOException ex) { ex.printStackTrace(); } } } public static void main(String[] args) throws IOException { new DatagramChannelServerDemo().service(); } } // UDP协议客户端 public class DatagramChannelClientDemo { // UDP协议客户端 private String serverIp = \"127.0.0.1\"; private int port = 9975; // private ServerSocketChannel serverSocketChannel; DatagramChannel channel; private Charset charset = Charset.forName(\"UTF-8\"); private Selector selector = null; public DatagramChannelClientDemo() throws IOException { try { selector = Selector.open(); channel = DatagramChannel.open(); } catch (Exception e) { selector = null; channel = null; System.out.println(\"超时\"); } System.out.println(\"客户器启动\"); } /* 编码过程 */ public ByteBuffer encode(String str) { return charset.encode(str); } /* 解码过程 */ public String decode(ByteBuffer bb) { return charset.decode(bb).toString(); } /* 服务器服务方法 */ public void service() throws IOException { if(channel==null || selector==null) return; channel.configureBlocking(false); channel.connect(new InetSocketAddress(serverIp, port));// 连接服务端 channel.write(ByteBuffer.wrap(new String(\"客户端请求获取消息\").getBytes())); channel.register(selector, SelectionKey.OP_READ); /** 外循环，已经发生了SelectionKey数目 */ while (selector.select() > 0) { /* 得到已经被捕获了的SelectionKey的集合 */ Iterator iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) { SelectionKey key = null; try { key = (SelectionKey) iterator.next(); iterator.remove(); if (key.isReadable()) { reveice(key); } if (key.isWritable()) { // send(key); } } catch (IOException e) { e.printStackTrace(); try { if (key != null) { key.cancel(); key.channel().close(); } } catch (ClosedChannelException cex) { e.printStackTrace(); } } } /* 内循环完 */ } /* 外循环完 */ } /* 接收 */ synchronized public void reveice(SelectionKey key) throws IOException { String threadName = Thread.currentThread().getName(); if (key == null) return; try { // ***用channel.receive()获取消息***// // ：接收时需要考虑字节长度 DatagramChannel sc = (DatagramChannel) key.channel(); String content = \"\"; //第一次接；udp采用数据报模式，发送多少次，接收多少次 ByteBuffer buf = ByteBuffer.allocate(65507);// java里一个(utf-8)中文3字节,gbk中文占2个字节 buf.clear(); SocketAddress address = sc.receive(buf); // read into buffer. String clientAddress = address.toString().replace(\"/\", \"\").split(\":\")[0]; String clientPost = address.toString().replace(\"/\", \"\").split(\":\")[1]; System.out.println(threadName + \"\\t\" + address.toString()); buf.flip(); // make buffer ready for read while (buf.hasRemaining()) { buf.get(new byte[buf.limit()]);// read 1 byte at a time byte[] tmp = buf.array(); content += new String(tmp); } buf.clear(); // make buffer ready for writing次 System.out.println(threadName + \"接收：\" + content.trim()); //第二次接 content = \"\"; ByteBuffer buf2 = ByteBuffer.allocate(65507);// java里一个(utf-8)中文3字节,gbk中文占2个字节 buf2.clear(); SocketAddress address2 = sc.receive(buf2); // read into buffer. buf2.flip(); // make buffer ready for read while (buf2.hasRemaining()) { buf2.get(new byte[buf2.limit()]);// read 1 byte at a time byte[] tmp = buf2.array(); content += new String(tmp); } buf2.clear(); // make buffer ready for writing次 System.out.println(threadName + \"接收2：\" + content.trim()); } catch (PortUnreachableException ex) { System.out.println(threadName + \"服务端端口未找到!\"); } send(2); } boolean flag = false; public void send(int i) { if (flag) return; try { // channel.write(ByteBuffer.wrap(new String(\"客户端请求获取消息(第\"+i+\"次)\").getBytes())); // channel.register(selector, SelectionKey.OP_READ ); ByteBuffer buf2 = ByteBuffer.allocate(48); buf2.clear(); buf2.put((\"客户端请求获取消息(第\" + i + \"次)\").getBytes()); buf2.flip(); channel.write(buf2); channel.register(selector, SelectionKey.OP_READ ); // int bytesSent = channel.send(buf2, new InetSocketAddress(serverIp,port)); // 将消息回送给服务端 } catch (IOException e) { e.printStackTrace(); } flag = true; } int y = 0; public void send(SelectionKey key) { if (key == null) return; // ByteBuffer buff = (ByteBuffer) key.attachment(); DatagramChannel sc = (DatagramChannel) key.channel(); try { sc.write(ByteBuffer.wrap(new String(\"aaaa\").getBytes())); } catch (IOException e1) { e1.printStackTrace(); } System.out.println(\"send2() \" + (++y)); } /* 发送文件 */ public void sendFile(SelectionKey key) { if (key == null) return; ByteBuffer buff = (ByteBuffer) key.attachment(); SocketChannel sc = (SocketChannel) key.channel(); String data = decode(buff); if (data.indexOf(\"get\") == -1) return; String subStr = data.substring(data.indexOf(\" \"), data.length()); System.out.println(\"截取之后的字符串是 \" + subStr); FileInputStream fileInput = null; try { fileInput = new FileInputStream(subStr); FileChannel fileChannel = fileInput.getChannel(); fileChannel.transferTo(0, fileChannel.size(), sc); fileChannel.close(); } catch (IOException e) { e.printStackTrace(); } finally { try { fileInput.close(); } catch (IOException ex) { ex.printStackTrace(); } } } public static void main(String[] args) throws IOException { new Thread(new Runnable() { public void run() { try { new DatagramChannelClientDemo().service(); } catch (IOException e) { e.printStackTrace(); } } }).start(); } } 参考 Java NIO系列教程（十） Java NIO DatagramChannel Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 16:10:03 "},"源码解读/java.nio/java.nio.Channels/SocketChannel.html":{"url":"源码解读/java.nio/java.nio.Channels/SocketChannel.html","title":"SocketChannel","keywords":"","body":"SocketChannel SocketChannel是nio中连接到TCP网络套接字的一个通道。学习这个类可以类比于DatagramChannel这个类。 可以使用两种方式创建SocketChannel： 打开一个SocketChannel并连接到互联网上的某台服务器。 一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。 下面是一些SocketChannel的常用操作： 打开SocketChannel SocketChannel sockChannel = SocketChannel.open(); sockChannel.connect(new InetSocketAddress(\"http://www.baidu.com\", 80)); 关闭SocketChannel 当用完关闭 socketChannel.close(); 读取数据 ByteBuffer buf = ByteBuffer.allocation(48); int byteRead = sockChannel.read(buf); 首选分配一个Buffer，从socketChanel中读取的数据将会放到buf中，然后调用SocketChannel.read()将数据从SocketChannel中读取到buffer中。read方法返回了读入的数据的长度。如果是-1，表明已经读到了流的末尾。 写入SocketChannel 写数据到SocketChannle用的是write方法。如下： String newData = \"This is String to write\"; ByteBuffer buf = ByteBuffer.allocate(48); buf.clear(); buf.put(newData.getBytes()); buf.flip(); while(buf.hasRemaining()){ channel.write(buf); } 注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。 非阻塞模式 可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。 connect() 如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样： socketChannel.configureBlocking(false); socketChannel.connect(new InetSocketAddress(\"http://jenkov.com\", 80)); while(! socketChannel.finishConnect() ){ //wait, or do something else... } write() 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。 read() 非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。 非阻塞模式与选择器 非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。 参考 Java NIO系列教程（八） SocketChannel Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 16:29:27 "},"源码解读/java.nio/java.nio.Channels/ServerSocketChannel.html":{"url":"源码解读/java.nio/java.nio.Channels/ServerSocketChannel.html","title":"ServerSocketChannel","keywords":"","body":"ServerSocketChannel ServerSocketChannel是一个可以监听性一个先进来的TCP连接的通道，就像标准IO中的ServerSocket一样。 例如： ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); while(true){ SocketChannel socketChannel = serverSocketChannel.accept(); //do something with socketChannel... } 参考 NIO编程之ServerSocketChannel用法详解 我们还是从一些使用示例说起： 打开ServerSocketChannel 通过调用ServerSocketChannel.open方法来打开： ServerSocketChannel serverSocketChannel = ServerSocket.open(); 关闭ServerSocketChannel 调用ServerSocketChannel.close方法来关闭： serverSocketChannel.close(); 监听新进来的链接 通过ServerSocketChannel.accept()方法监听新进来的链接。当accept()方法返回的时候，它返回一个包含新进来的连接的SocketChannel，因此，accept方法会一直阻塞到有新连接到达。 通常不会仅仅只监听一个连接，所以需要在while循环中调用accept方法，如下： while(true){ SocketChannel sockChannel = serverSocketChannel.accept(); //do something with socketChanel; } 当然中途也可以break。 非阻塞模式 ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如： ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); serverSocketChannel.configureBlocking(false); while(true){ SocketChannel socketChanel = serverSocketChannel.accpet(); if(sockChannel != null){ //do something with sockChannel } } 参考 Java NIO系列教程（九） ServerSocketChannel NIO编程之ServerSocketChannel用法详解 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 16:42:38 "},"源码解读/java.nio/java.nio.Channels/Selector.html":{"url":"源码解读/java.nio/java.nio.Channels/Selector.html","title":"Selector","keywords":"","body":"Selector Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。 为什么要用Selector Selector提供了询问通道是否已经准备好执行每个I/O操作的能力。Selector 允许单线程处理多个Channel。仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道，这样会大量的减少线程之间上下文切换的开销。 其中有三个重要的概念： 选择器（Selector） Selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。 可选择通道（SelectableChannel） SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel，因此是不是可选通道，而所有socket通道都是可选择的，包括从管道(Pipe)对象的中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。 选择键（SelectionKey） 选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register() 返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。 下面是使用Selector管理多个channel的示意图： 下面我们仍然从使用的角度看看Seletor的用法。 创建Selector Selector这个类是抽象类，不能实例化，我们使用静态工厂方法来创建实例。 public static Selector open() throws IOException { return SelectorProvider.provider().openSelector(); } 将Channel注册到Selector 为了能让Channel被Selector管理，Channel应该被注册到Selector上。 channel.configureBlocking(false); SelectionKey key= channel.register(selector,SelectionKey,OP_READ); 通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，Channel必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。 register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。 这个\"interest集合\"有四种取值： Connect 连接 —— SelectionKey.OP_CONNECT Accept 接受——SelectionKey.OP_ACCEPT Read 读——SelectionKey.OP_RED Write 写——SelectionKey.OP_WRITE 需要注意并非所有的操作在所有的可选择通道上都能被支持，比如ServerSocketChannel支持Accept，而SocketChannel中不支持。我们可以通过通道上的validOps()方法来获取特定通道下所有支持的操作集合。 如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE; 当通道触发了某个操作之后，表示该通道的某个操作已经就绪，可以被操作。因此，某个SocketChannel成功连接到另一个服务器称为“连接就绪”(OP_CONNECT)。一个ServerSocketChannel准备好接收新进入的连接称为“接收就绪”（OP_ACCEPT）。一个有数据可读的通道可以说是“读就绪”(OP_READ)。等待写数据的通道可以说是“写就绪”(OP_WRITE)。 我们注意到register()方法会返回一个SelectionKey对象，我们称之为键对象。该对象包含了以下四种属性： interest集合 read集合 Channel Selector interest集合是Selector感兴趣的集合，用于指示选择器对通道关心的操作，可通过SelectionKey对象的interestOps()获取。最初，该兴趣集合是通道被注册到Selector时传进来的值。该集合不会被选择器改变，但是可通过interestOps()改变。我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣： int interestSet=selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； read集合是通道已经就绪的操作的集合，表示一个通道准备好要执行的操作了,可通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。（比如选择器对通道的read,write操作感兴趣，而某时刻通道的read操作已经准备就绪可以被选择器获知了，前一种就是interest集合，后一种则是read集合。）。JAVA中定义以下几个方法用来检查这些操作是否就绪： //int readSet=selectionKey.readOps(); selectionKey.isAcceptable();//等价于selectionKey.readyOps()&SelectionKey.OP_ACCEPT selectionKey.isConnectable(); selectionKey.isReadable(); selectionKey.isWritable(); 需要注意的是，通过相关的选择键的readyOps()方法返回的就绪状态指示只是一个提示，底层的通道在任何时候都会不断改变，而其他线程也可能在通道上执行操作并影响到它的就绪状态。另外，我们不能直接修改read集合。 取出SelectionKey所关联的Selector和Channel 通过SelectionKey访问对应的Selector和Channel： Channel channel =selectionKey.channel(); Selector selector=selectionKey.selector(); 关于取消SelectionKey对象的那点事 我们可以通过SelectionKey对象的cancel()方法来取消特定的注册关系。该方法调用之后，该SelectionKey对象将会被”拷贝”至已取消键的集合中，该键此时已经失效，但是该注册关系并不会立刻终结。在下一次select()时，已取消键的集合中的元素会被清除，相应的注册关系也真正终结。 Seletor完整的代码 // 服务端 public class ServerSocketChannelTest { private int size = 1024; private ServerSocketChannel socketChannel; private ByteBuffer byteBuffer; private Selector selector; private final int port = 8998; private int remoteClientNum=0; public ServerSocketChannelTest() { try { initChannel(); } catch (Exception e) { e.printStackTrace(); System.exit(-1); } } public void initChannel() throws Exception { socketChannel = ServerSocketChannel.open(); socketChannel.configureBlocking(false); socketChannel.bind(new InetSocketAddress(port)); System.out.println(\"listener on port:\" + port); selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_ACCEPT); byteBuffer = ByteBuffer.allocateDirect(size); byteBuffer.order(ByteOrder.BIG_ENDIAN); } private void listener() throws Exception { while (true) { //阻塞到至少有一个通道在你注册的事件上就绪了 int n = selector.select(); if (n == 0) { continue; } //访问已选择键集合 Iterator ite = selector.selectedKeys().iterator(); while (ite.hasNext()) { SelectionKey key = ite.next(); //a connection was accepted by a ServerSocketChannel. if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel channel = server.accept(); registerChannel(selector, channel, SelectionKey.OP_READ); remoteClientNum++; System.out.println(\"online client num=\"+remoteClientNum); replyClient(channel); } //a channel is ready for reading if (key.isReadable()) { readDataFromSocket(key); } ite.remove();//must } } } protected void readDataFromSocket(SelectionKey key) throws Exception { SocketChannel socketChannel = (SocketChannel) key.channel(); int count; byteBuffer.clear(); while ((count = socketChannel.read(byteBuffer)) > 0) { byteBuffer.flip(); // Make buffer readable // Send the data; don't assume it goes all at once while (byteBuffer.hasRemaining()) { socketChannel.write(byteBuffer); } byteBuffer.clear(); // Empty buffer } if (count //客户端 public class SocketChannelTest { private int size = 1024; private ByteBuffer byteBuffer; private SocketChannel socketChannel; public void connectServer() throws IOException { socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(\"127.0.0.1\", 8998)); byteBuffer = ByteBuffer.allocate(size); byteBuffer.order(ByteOrder.BIG_ENDIAN); receive(); } private void receive() throws IOException { while (true) { int count; byteBuffer.clear(); while ((count = socketChannel.read(byteBuffer)) > 0) { byteBuffer.flip(); while (byteBuffer.hasRemaining()) { System.out.print((char) byteBuffer.get()); } //send(\"send data to server\\r\\n\".getBytes()); byteBuffer.clear(); } } } private void send(byte[] data) throws IOException { byteBuffer.clear(); byteBuffer.put(data); byteBuffer.flip(); socketChannel.write(byteBuffer); } public static void main(String[] args) throws IOException { new SocketChannelTest().connectServer(); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 19:46:52 "},"源码解读/java.nio/ByteBuffer.html":{"url":"源码解读/java.nio/ByteBuffer.html","title":"ByteBuffer","keywords":"","body":"ByteBuffer NIO中重要的组成部分缓冲区，主要以字符的形式读取内容。类的结构如下： public abstract class ByteBuffer extends Buffer implements Comparable 类声明。继承自Buffer抽象类。这是一个抽象类，它的一些具体的实现类如下： 在ByteBuffer中提供了四个静态工厂类来创建不同的ByteBuffer实例： 方法名 描述 allocate(int capacity) 从堆空间中分配一个容量大小为capacity的byte数组作为缓冲区的byte数据存储器， 分配的ByteBuffer的类型是HeapByteBuffer allocateDirect(int capacity) 是不使用JVM堆栈而是通过操作系统来创建内存块用作缓冲区，它与当前操作系统能够更好的耦合，因此能进一步提高I/O操作速度。但是分配直接缓冲区的系统开销很大，因此只有在缓冲区较大并长期存在，或者需要经常重用时，才使用这种缓冲区, 分配的类型是DirectByteBuffer wrap(byte[] array) 这个缓冲区的数据会存放在byte数组中，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。其实ByteBuffer底层本来就有一个bytes数组负责来保存buffer缓冲区中的数据，通过allocate方法系统会帮你构造一个byte数组 wrap(byte[] array, int offset, int length) 在上一个方法的基础上可以指定偏移量和长度，这个offset也就是包装后byteBuffer的position，而length呢就是limit-position的大小，从而我们可以得到limit的位置为length+position(offset) 构造函数 定义了两个构造函数， // Creates a new buffer with the given mark, position, limit, capacity, // backing array, and array offset // ByteBuffer(int mark, int pos, int lim, int cap, // package-private byte[] hb, int offset) { super(mark, pos, lim, cap); this.hb = hb; this.offset = offset; } // Creates a new buffer with the given mark, position, limit, and capacity // ByteBuffer(int mark, int pos, int lim, int cap) { // package-private this(mark, pos, lim, cap, null, 0); } 特别注意到这里的参数变量，其中mark、pos、lim和cap是每个容器共有的属性，它们都定义在父类Buffer中： // Invariants: mark 注意到这几个变量之间的大小关系mark 四个静态工厂方法 之前提到，ByteBuffer是抽象类，不能实例化，提供了静态工厂方法，用来创建不同类型的ByteBuffer，具体解释参考上面的表格 //直接内存存取快， 不在堆栈区分配空间 public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } //分配堆区的空间 public static ByteBuffer allocate(int capacity) { if (capacity 对于这四个不同类型的ByteBuffer，下面有一个测试程序帮助理解： public static void main(String[] args) { System.out.println(\"----------Test allocate--------\"); System.out.println(\"before alocate:\" + Runtime.getRuntime().freeMemory()); // 如果分配的内存过小，调用Runtime.getRuntime().freeMemory()大小不会变化？ // 要超过多少内存大小JVM才能感觉到？ ByteBuffer buffer = ByteBuffer.allocate(102400); System.out.println(\"buffer = \" + buffer); System.out.println(\"after alocate:\" + Runtime.getRuntime().freeMemory()); // 这部分直接用的系统内存，所以对JVM的内存没有影响 ByteBuffer directBuffer = ByteBuffer.allocateDirect(102400); System.out.println(\"directBuffer = \" + directBuffer); System.out.println(\"after direct alocate:\" + Runtime.getRuntime().freeMemory()); System.out.println(\"----------Test wrap--------\"); byte[] bytes = new byte[32]; buffer = ByteBuffer.wrap(bytes); System.out.println(buffer); buffer = ByteBuffer.wrap(bytes, 10, 10); System.out.println(buffer); } 程序的输出结果是： ----------Test allocate-------- before alocate:126930104 buffer = java.nio.HeapByteBuffer[pos=0 lim=102400 cap=102400] after alocate:126930104 directBuffer = java.nio.DirectByteBuffer[pos=0 lim=102400 cap=102400] after direct alocate:126930104 ----------Test wrap-------- java.nio.HeapByteBuffer[pos=0 lim=32 cap=32] java.nio.HeapByteBuffer[pos=10 lim=20 cap=32] 常用方法 limit方法 继承自父类Buffer，有点类似于jquery的val方法，有参数的时候是set方法，无参的时候是get方法。注意set的时候，可能会导致positon和limit值的改变： public final int limit() { return limit; } public final Buffer limit(int newLimit) { if ((newLimit > capacity) || (newLimit limit) position = limit; if (mark > limit) mark = -1; return this; } mark方法 将mark位置设置成当前position。 public final Buffer mark() { mark = position; return this; } reset方法 把position设置成mark的值，相当于之前做过一个标记，现在要退回到之前标记的地方 public final Buffer reset() { int m = mark; if (m flip()方法 limit = position;position = 0;mark = -1; 翻转，也就是让flip之后的position到limit这块区域变成之前的0到position这块，翻转就是将一个处于存数据状态的缓冲区变为一个处于准备取数据的状态。 public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } rewind()方法 把position设为0，mark设为-1，不改变limit的值， public final Buffer rewind() { position = 0; mark = -1; return this; } remaining() 返回limit和position之间相对位置差。这表示的是剩余的容量。 public final int remaining() { return limit - position; } hasRemaining()方法 也表示是否已经写满，返回的是布尔值。 public final boolean hasRemaining() { return position compact()方法 把从position到limit中的内容移到0到limit-position的区域内，position和limit的取值也分别变成limit-position、capacity。如果先将positon设置到limit，再compact，那么相当于clear()。 与compact不同的是，它会将剩余的元素搬运到写区域。但是clear就不会。 get方法 重载了多个get方法。 get()： 相对读，从position位置读取一个byte，并将position+1，为下次读写作准备，具体的实现在具体的实现类中。 get(int index)：绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position。 get(byte[] dst, int offset, int length)：从position位置开始相对读，读length个byte，并写入dst下标从offset到offset+length的区域。 put方法 put(byte b)：相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备。 put(int index, byte b)： 绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变position put(ByteBuffer src)：用相对写，把src中可读的部分（也就是position到limit）写入此byteBuffer put(byte[] src, int offset, int length)：从src数组中的offset到offset+length区域读取数据并使用相对写写入此byteBuffer 下面是这些常用方法的测试程序: ByteBuffer buffer = ByteBuffer.allocate(102400); System.out.println(\"--------Test reset----------\"); buffer.clear(); buffer.position(5); buffer.mark(); buffer.position(10); System.out.println(\"before reset:\" + buffer); buffer.reset(); System.out.println(\"after reset:\" + buffer); System.out.println(\"--------Test rewind--------\"); buffer.clear(); buffer.position(10); buffer.limit(15); System.out.println(\"before rewind:\" + buffer); buffer.rewind(); System.out.println(\"before rewind:\" + buffer); System.out.println(\"--------Test compact--------\"); buffer.clear(); buffer.put(\"abcd\".getBytes()); System.out.println(\"before compact:\" + buffer); System.out.println(new String(buffer.array())); buffer.flip(); System.out.println(\"after flip:\" + buffer); System.out.println((char) buffer.get()); System.out.println((char) buffer.get()); System.out.println((char) buffer.get()); System.out.println(\"after three gets:\" + buffer); System.out.println(\"\\t\" + new String(buffer.array())); buffer.compact(); System.out.println(\"after compact:\" + buffer); System.out.println(\"\\t\" + new String(buffer.array())); System.out.println(\"------Test get-------------\"); buffer = ByteBuffer.allocate(32); buffer.put((byte) 'a').put((byte) 'b').put((byte) 'c').put((byte) 'd') .put((byte) 'e').put((byte) 'f'); System.out.println(\"before flip()\" + buffer); // 转换为读取模式 buffer.flip(); System.out.println(\"before get():\" + buffer); System.out.println((char) buffer.get()); System.out.println(\"after get():\" + buffer); // get(index)不影响position的值 System.out.println((char) buffer.get(2)); System.out.println(\"after get(index):\" + buffer); byte[] dst = new byte[10]; buffer.get(dst, 0, 2); System.out.println(\"after get(dst, 0, 2):\" + buffer); System.out.println(\"\\t dst:\" + new String(dst)); System.out.println(\"buffer now is:\" + buffer); System.out.println(\"\\t\" + new String(buffer.array())); System.out.println(\"--------Test put-------\"); ByteBuffer bb = ByteBuffer.allocate(32); System.out.println(\"before put(byte):\" + bb); System.out.println(\"after put(byte):\" + bb.put((byte) 'z')); System.out.println(\"\\t\" + bb.put(2, (byte) 'c')); // put(2,(byte) 'c')不改变position的位置 System.out.println(\"after put(2,(byte) 'c'):\" + bb); System.out.println(\"\\t\" + new String(bb.array())); // 这里的buffer是 abcdef[pos=3 lim=6 cap=32] bb.put(buffer); System.out.println(\"after put(buffer):\" + bb); System.out.println(\"\\t\" + new String(bb.array())); 参考 ByteBuffer常用方法详解 ByteBuffer类的常用方法 !!! 攻破JAVA NIO技术壁垒 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-26 15:13:06 "},"源码解读/java.nio/ShortBuffer.html":{"url":"源码解读/java.nio/ShortBuffer.html","title":"ShortBuffer","keywords":"","body":"ShortBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/IntBuffer.html":{"url":"源码解读/java.nio/IntBuffer.html","title":"IntBuffer","keywords":"","body":"IntBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/LongBuffer.html":{"url":"源码解读/java.nio/LongBuffer.html","title":"LongBuffer","keywords":"","body":"LongBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/FloatBuffer.html":{"url":"源码解读/java.nio/FloatBuffer.html","title":"FloatBuffer","keywords":"","body":"FloatBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/DoubleBuffer.html":{"url":"源码解读/java.nio/DoubleBuffer.html","title":"DoubleBuffer","keywords":"","body":"DoubleBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"源码解读/java.nio/CharBuffer.html":{"url":"源码解读/java.nio/CharBuffer.html","title":"CharBuffer","keywords":"","body":"CharBuffer Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-11 16:13:25 "},"设计模式/六大原则/六大原则.html":{"url":"设计模式/六大原则/六大原则.html","title":"六大原则","keywords":"","body":"六大原则 单一原则（Single Responsibility Principle）：一个类只负责一项功能 开闭原则（Open Closed Principle）： 对修改关闭，对扩展开发 里氏替换原则（Liskov Substitution Principle）：子类可以扩展父类功能，但是不要改变原有的功能 迪米特原则（Law of Demeter）： 降低耦合 接口隔离原则（Interface Segregation Principle）： 接口最小 依赖倒置原则（Dependence Inversion Principle）： 面向接口的编程 把这6个原则的首字母（里氏替换原则原地和迪米特法则的首字母重复，只取一个）联合起来就是SOLID(solid, 稳定的)。 参考 白话设计模式六大原则 设计模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 20:43:20 "},"设计模式/六大原则/单一原则.html":{"url":"设计模式/六大原则/单一原则.html","title":"单一原则","keywords":"","body":"单一原则 含义 单一原则： 不要存在多个导致类变更的原因 更加通俗地说，就是一个类负责一项职责。 参考 设计模式六大原则（1）：单一职责原则 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 22:49:25 "},"设计模式/六大原则/里氏替换原则.html":{"url":"设计模式/六大原则/里氏替换原则.html","title":"里氏替换原则","keywords":"","body":"里氏替换原则 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 通俗来讲，里氏替换原则是指“子类可以扩展父类的功能，但不能改变父类原有的功能”，它包含以下四种含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 参考 设计模式六大原则（2）：里氏替换原则 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 22:59:02 "},"设计模式/六大原则/依赖倒置原则.html":{"url":"设计模式/六大原则/依赖倒置原则.html","title":"依赖倒置原则","keywords":"","body":"依赖倒置原则 含义 依赖倒置原则： 1.High level modules should not depend upon low level modules. Both should depend upon abstractions. 高层模块不应该依赖于底层模块，二者都应该依赖于抽象 2.Abstractions should not depend upon details. Details should depend upon abstractions 抽象不应该依赖于细节，细节应该依赖于抽象 说法还挺复杂，我们来逐词整理一下这里的说法。 首先，“高层模块”和\"底层模块\"很好理解。每一个逻辑的实现都是有原子逻辑组成的，不可分割的逻辑就是低层逻辑，底层逻辑的组成了高层逻辑。比如A依赖于B，那么A是高层逻辑，B是低层逻辑。 再者，什么是“抽象”。在Java中，抽象是指接口或抽象类，两者都不能被实例化。 最后，什么是“细节”。细节是相对抽象而言的，在Java中就是指接口或者抽象类的具体实现，他们是能够被实例化的。 所以总结下来，在Java中，依赖倒置原则就是： 模块之间的依赖是通过接口或抽象发生的，实现类之间不能发生直接的依赖关系。 接口或抽象不依赖于实现类。 实现类依赖于接口或抽象类。 更加精简的说法是——“面向接口编程”。实例可参考文末链接中的文章，讲的很通俗易懂了。这里需要注意的是，一个正确的做法是：高层类和低层类都需要抽象出各自的接口，让接口之间相互交互。 依赖倒置实现业务解耦，先有接口，后有实现，所以两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）,就可以实现并行开发，而项目之间的单元测试也可以独立进行。 TDD(Test-Driven Development, 测试驱动开发)开发模式是依赖开发模式的最高级应用。 “倒置”这个词是相对于“正置”这个词而言的。依赖正置是指类间的依赖是实实在在的 依赖的三种写法 对象的依赖传递有三种方式：构造方法传递、setter方法传递和接口传递 例如，我们定义两个接口:IDriven和ICar，前者表示“会开车”这种技能，后者表示“（车）能跑”这种技能。定义如下： public interface IDriven{ //驾驶汽车 public void drive(); } public interface ICar{ //跑 public void run(); } 两者各自有实现类Driver和Car，前者需要驾驶汽车，即我们需要传递一个ICar的对象给Driver，让其进行构造。有三种方式进行参数传递。 构造方法传递依赖对象 在高层的实现类的构造函数中设置依赖关系 public class Driver implements IDriven{ private ICar car; //构造函数注入 public Driver(ICar icar){ this.car = icar; } public void drive(){ this.car.run(); } } setter方法传递依赖对象 在高层的抽象中设置setter声明依赖关系。比如上例中IDriven的接口应该改写成： public interface IDriven{ public void setCar(ICar icar); public void drive(); } ICar接口写法不变。而Driver实现类改写成这样： public class Driver implements IDriven{ private ICar car; public void setCar(ICar icar){ this.car = icar; } public void drive(){ this.car.run(); } } 接口声明中传递依赖对象 在高层类的接口声明中设置参数声明依赖关系。比如上例中IDriven接口应该改写成： public interface IDriven{ public void drive(Icar car); } Icar的接口声明不变。而Driver实现类的定义如下： public Driver implements IDriven{ public void drive(Icar car){ car.run(); } } 侵入性太强了。不建议使用 最佳实践 每个类都有接口或抽象类，或者兼有之。 变量的显示类型尽量是接口抽象类。（并不是绝对的，比如一些工具类，不需要有抽象实现） 任何类都不应该从具体类中派生。 尽量不要复写基类的方法 结合里式替换原则。 参考 设计模式六大原则（3）：依赖倒置原则 JAVA设计模式之依赖倒转原则 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 16:26:38 "},"设计模式/六大原则/接口隔离原则.html":{"url":"设计模式/六大原则/接口隔离原则.html","title":"接口隔离原则","keywords":"","body":"接口隔离原则 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。 解决办法：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 23:13:08 "},"设计模式/六大原则/迪米特法则.html":{"url":"设计模式/六大原则/迪米特法则.html","title":"迪米特法则","keywords":"","body":"迪米特法则 一个对象应该对其他对象保持最少的了解。 软件编程的总的原则：低耦合，高内聚。 “只与直接的朋友通信” 参考 设计模式六大原则（5）：迪米特法则 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 23:19:40 "},"设计模式/六大原则/开闭原则.html":{"url":"设计模式/六大原则/开闭原则.html","title":"开闭原则","keywords":"","body":"开闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 开闭原则非常抽象。总的来说，开闭原则是对前5种原则的总纲领： 单一职责原则告诉我们实现类要职责单一； 里氏替换原则告诉我们不要破坏继承体系； 依赖倒置原则告诉我们要面向接口编程； 接口隔离原则告诉我们在设计接口的时候要精简单一； 迪米特法则告诉我们要降低耦合。 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。用一句话总结就是：用抽象构建框架，用实现扩展细节： 参考 设计模式六大原则（6）：开闭原则 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-04 23:20:15 "},"设计模式/设计模式/设计模式.html":{"url":"设计模式/设计模式/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 java设计模式demo —— java-design-patterns 《设计模式之禅》 常见的23种设计模式，如果进行组织呢？ 一种常见的组织方式是按照“目的”来划分，即模式是用来完成什么工作的，这种分类标准下，一共分为3大类。 创建型 与对象的创建有关。有五种： 工厂方法模式(Factory Method) 抽象工厂模式(Abstract Factory) 创建者模式(Builder) 单例模式(Singleton) 原型模式(Prototype) 结构型 处理类或对象的组合。有七种： 适配器模式（Adapter） 桥接模式(Bridge) 组合模式(Composite) 装饰器模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 行为型 对类或对象怎样交互和怎样分配职责进行描述。共十一种： 责任链模式(Chain of Responsibility) 解释器模式(Interpreter) 模板方法模式(Template Method) 命令模式(Command) 迭代子模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 访问者模式(Visitor) 其实还有两类：并发模式和线程池模式 还有一种分类标准是“范围”，即模式主要作用于类还是对象。 类模式处理类和子类之间的关系，这是通过继承关系完成的，在编译时刻便确定下来，是静态的。 对象处理模式处理对象间的关系，这些关系在运行时是可以变化的，具有动态性。大部分的设计模式是对象模式。 根据以上两个标准得到的设计模式的空间可以用下面这张表来表示： 设计模式之间的关系可以用下面这张图来表示 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-21 16:34:47 "},"设计模式/设计模式/创建型模式/创建型模式.html":{"url":"设计模式/设计模式/创建型模式/创建型模式.html","title":"创建型模式","keywords":"","body":"创建型模式 抽象工厂模式(Abstract Factory)：提供了一系列相关或相互依赖对象的接口，无需指定它们具体的实现类 • java.util.Calendar#getInstance() • java.util.Arrays#asList() • java.util.ResourceBundle#getBundle() • java.net.URL#openConnection() • java.sql.DriverManager#getConnection() • java.sql.Connection#createStatement() • java.sql.Statement#executeQuery() • java.text.NumberFormat#getInstance() • java.lang.management.ManagementFactory (所有getXXX()方法) • java.nio.charset.Charset#forName() • javax.xml.parsers.DocumentBuilderFactory#newInstance() • javax.xml.transform.TransformerFactory#newInstance() • javax.xml.xpath.XPathFactory#newInstance() 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类 • java.lang.Object#toString() (在其子类中可以覆盖该方法) • java.lang.Class#newInstance() • java.lang.Integer#valueOf(String) (Boolean, Byte, Character,Short, Long, Float 和 Double与之类似) • java.lang.Class#forName() • java.lang.reflect.Array#newInstance() • java.lang.reflect.Constructor#newInstance() 创建者模式(Builder)：将一个复杂对象的创建和表示相分离，使得同样的创建过程可以创建不同的表示 • java.lang.StringBuilder#append() • java.lang.StringBuffer#append() • java.nio.ByteBuffer#put() (CharBuffer, ShortBuffer, IntBuffer,LongBuffer, FloatBuffer 和DoubleBuffer与之类似) • javax.swing.GroupLayout.Group#addComponent() • java.sql.PreparedStatement • java.lang.Appendable的所有实现类 单例模式(Singleton)：保证一个类只要一个实例 • java.lang.Runtime#getRuntime() • java.awt.Desktop#getDesktop() 原型模式(Prototype) • java.lang.Object#clone() (支持浅克隆的类必须实现java.lang.Cloneable接口) 工厂模式按照抽象程度不同可以分为三种：简单工厂（也叫静态工厂模式）、抽象工厂、工厂方法。其中简单工厂并不是23种设计模式之一。 http://ichennan.com/2016/08/09/DesignPattern.html 简单工厂很粗暴，用参数控制创建的东西是什么：传入1造火箭、传入2煮面条、传入3种土豆，简直无所不能，所以简单工厂还有一个一个别名：上帝类。简单粗暴也算是优点吧。 缺点也很明显，太简单粗暴了。任何东西都能被得到，负担太中，当需要的产品很多的时候，工厂方法的代码量可能会很庞大。另外，在遵循开闭原则的条件下，简单工厂对于增加新产品无能为力。因为增加新产品只能靠修改工厂方法来实现。 而工厂方法能解决这个问题，它提供了一个能生产产品的接口，至于生产的产品具体是什么，需要子类自己实现。工厂方法很好解决了上面的问题，但是缺点也很明显，就是功能太单一了，如果需要n种产品，那么就需要n个工厂的实现类。 而抽象工厂是针对“产品簇”提出的。工厂方法是一种极端的抽象工厂（只生产一种产品的抽象工厂模式）。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 16:32:39 "},"设计模式/设计模式/创建型模式/Abstract Factory.html":{"url":"设计模式/设计模式/创建型模式/Abstract Factory.html","title":"Abstract Factory","keywords":"","body":"Abstract Factory 什么是抽象工厂 抽象工厂模式，提供了一系列相关或相互依赖对象的接口，无需指定它们具体的实现类。是一种类创建模式。 抽象工厂的结构如下： 这里面有这样几种角色： 抽象工厂（AbstractFactory）：声明一个接口，这个接口中包含创建抽象产品对象的方法 具体工厂（ConcreteFactory）：实现创建具体产品对象的方法。 抽象产品（AbstractProduct）：声明一个接口，这个接口中包含产品对象类型。 具体产品（ConcreteProduct）：定义一个产品对象，这个产品对象是由相关的具体工厂创建的。 以一个电子工厂、苹果厂商、三星厂商、手机、电脑为例子。 有一类工厂生产电子产品，名字叫ElectronicFactory，这种工厂生产两种商品：手机（Telephone）和电脑（Computer）。有两个具体的工厂，苹果工厂（AppleFactory）和三星工厂（SamsungFactory）分别生产自己的手机和电脑，那么以上关系就可以用抽象工厂模式来完成。 ElectronicFactory.java public interface ElectronicFactory { public Telephone productTelephone(); public Computer productComputer(); } Telephone.java public interface Telephone { public String getProductInfo(); } \b Computer.java public interface Computer { public String getProductInfo(); } AppleFactory.java public class AppleFactory implements ElectronicFactory { @Override public Telephone productTelephone() { return new AppleTelephone(); } @Override public Computer productComputer() { return new AppleComputer(); } } AppleTelephone.java public class AppleTelephone implements Telephone { @Override public String getProductInfo() { return \"苹果手机，采用iso系统\"; } } AppleComputer.java public class AppleComputer implements Computer { @Override public String getProductInfo() { return \"苹果电脑，使用mac系统\"; } } SamsungFactory.java public class SamsungFactotry implements ElectronicFactory { @Override public Telephone productTelephone() { return new SamsungTelephone(); } @Override public Computer productComputer() { return new SamungComputer(); } } SamsungTelephone.java public class SamsungTelephone implements Telephone { @Override public String getProductInfo() { return \"三星手机，使用android系统\"; } } SamungComputer.java public class SamungComputer implements Computer { @Override public String getProductInfo() { return \"三星电脑，使用windows系统\"; } } 测试代码为： public static void main(String[] args) { ElectronicFactory factory = new AppleFactory(); Telephone telephone = factory.productTelephone(); Computer computer = factory.productComputer(); System.out.println(telephone.getProductInfo()); System.out.println(computer.getProductInfo()); ElectronicFactory factory1 = new SamsungFactotry(); Telephone telephone1 = factory1.productTelephone(); Computer computer1 = factory1.productComputer(); System.out.println(telephone1.getProductInfo()); System.out.println(computer1.getProductInfo()); } 上面的测试代码创建了两个工厂创建得到的四种产品。当然你也可以用new AppleComputer或者new AppleTelephone的方法创建某种具体的产品，\b这样做的不好的地方是，你每次都需要手动去创建具体的类，而且，不能保证一个程序中都使用了一个工厂创建出来的一套产品（比如，自己new的话可能创建了一个苹果手机和一个三星电脑）。使用抽象工厂的模式创建类就避免了以上缺点： 抽象工厂隔绝了具体类的生成。用户并不需要知道什么时候被创建。由于这种隔离，更换一个具体的工厂就变的容易。所有的具体的工厂都实现了抽象工厂中的方法，因此，只要改变工厂的具体实现，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一个工厂时，它能保证客户端始终只是用同一个产品族中的对象。就像上面的例子，如果ElectronicFactory的实现类是AppleFactory，那么之后由Factory创建出来的产品就是“苹果”的产品族。 增加新的具体工厂和产品族很方便，不需要修改已经建成的“工厂”和“产品”，符合开闭原则。 但是也有缺点！ 在添加一个新的产品时候，难以扩展抽象工厂生产出来新种类的产品。这是因为在抽象工厂角色中规定了所有可能被创建的产品集合。要支持新产品，意味着要对该抽象工厂进行扩展。一旦扩展，那么实现该抽象接口的所有具体工厂类都要实现该抽象方法，非常不方便。就像上面的例子，如果ElectronicFactory可以生产\"相机\"，那么AppleFactory和SamsungFactotry都需要实现“生产相机”的方法。如果有成千上百个工厂呢？修改的成本就非常高了。 抽象工厂的使用场景 一个对象族（或一组没有任何关系的对象）都有相同的约束，就可以使用抽象工厂。 一个普通的工厂通常是一个单例(Singleton) 参考 [设计模式]抽象工厂模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 17:00:29 "},"设计模式/设计模式/创建型模式/Factory Method.html":{"url":"设计模式/设计模式/创建型模式/Factory Method.html","title":"Factory Method","keywords":"","body":"Factory Method 学习抽象工厂的时候知道，抽象工厂的缺点是一旦有新的需求，工厂需要是生产新的产品，那么我们就需要修改抽象工厂的接口，这就意味着，实现这个接口的所有实现工程都需要修改，这不符合“开闭原则”。 工厂方法的概念 工程方法克服了这个缺点，它将类的实例化（具体产品的创建）延迟到了工厂类的子类（具体工厂）中完成，即由具体的工厂来决定应该创建哪一个产品。 假设这样的情况：工厂A生产产品a，按照抽象工厂的方法，它应该写成这样： // 抽象工厂接口 interface Factory{ Product productA(); } // 抽象产品接口 interface Product{ void printInfo(); } //具体工厂 public Class FactoryA implements Factory{ @Override public Product productA{ return new ProductA(); } } 那么如果现在新的需求来了，工厂还需要生产产品B，那要怎么办？如果抽象方法，那么只能在接口Factory中增加创建B产品的方法，造成的后果是工厂的实现类也跟着需要改变： // 抽象工厂接口 interface Factory{ Product productA(); Product productB(); } // 抽象产品接口 interface Product{ void printInfo(); } public class ProductA implements Product{ @Override public void printInfo(){ System.out.print(\"a\"); } } public class productB implements Product{ @Override public void printInfo(){ System.out.print(\"b\"); } } //具体工厂 public Class FactoryA implements Factory{ @Override public Product productA{ return new ProductA(); } @Override public Product productB{ return new productB(); } } public class AbstactFactoryTest(){ public static void main(String[] args){ Factory factory = new FactoryA(); ProductA productA = factory.productA(); productA.printInfo(); ProductB productB = factory.productB(); productB.printInfo(); } } 总是，抽象工厂方法是创建了一个接口，艺高人胆大，定义了工厂能具有的所有功能。能造什么不能造什么全部都约定清楚了。 但是工厂方法不一样，它很宽容，只是限定了工厂它能造东西，至于造什么东西，你们自便。仍然是上面这个例子，如果按照工厂方法的模式来写，应该是这样： //抽象接口 interfact Factory{ Product product(); } // 抽象产品接口 interface Product{ void printInfo(); } // 具体产品ProductA类 public class ProductA implements Product{ @Override public void printInfo(){ System.out.print(\"a\"); } } //能创建A产品的工厂 public class FactoryA implements Factory{ @Override public Product product(){ return new ProductA(); } } 以上就是一个能造A产品的工厂A，如果现在来了新需求，需要造B怎么办？不能改变A，那么再创建一个工厂B // 抽象工厂接口 interface Factory{ Product productA(); Product productB(); } // 抽象产品接口 interface Product{ void printInfo(); } public class ProductA implements Product{ @Override public void printInfo(){ System.out.print(\"a\"); } } public class productB implements Product{ @Override public void printInfo(){ System.out.print(\"b\"); } } //能创建A产品的工厂 public class FactoryA implements Factory{ @Override public Product product(){ return new ProductA(); } } // 能创建B产品的工厂 public class FactoryB implements Factory{ @Override public Product product(){ return new ProductB; } } // 测试方法 public class FactoryMethodTest{ public static void main(String[] args){ //获取客户需要的A产品 Factory factoryA = new FactoryA(); Product productA = factoryA.product(); productA.printInfo(); //a //获取客户需要的B产品 Factory factoryB = new FactoryB(); Product productB = factoryB.product(); productB.printInfo(); //b } } 以上这种方法叫做多工厂方法类，即每个产品单独对应了一个工厂实例。在复杂的应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各个子工厂交流。协调类的目的是封装子工厂类，对高层模块提供统一的访问接口。 所以，面对不同的需求，以后只需要新增不同的工厂就可以了，可就是说可能需要工厂有n种功能，那么我们就需要创建n个工厂。这样每个工厂就各司其职，符合单一原则，有改动时候不需要改动原来的类，符合开闭原则。能够拥抱变化 当然这些有点换个角度想想也是缺点。 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类； 一个具体工厂只能创建一种具体产品 工厂方法实践 代替单例模式 通过犯罪社可以创建单例。 publci class SingletonFactory{ private static Singleton singleton; static { try{ Class cl = Class.forName(Singleton.class.getName()); Constructor concurrent = cl.getDeclaredConstructor(); constructor.setAccessible(true); singleton =(Singleton)constructor.newInstance(); }catch(Exception e){ // 异常处理 } } public static Singleton getSingleton(){ return singleton; } } 延迟初始化 什么是延迟初始化？一个对象被消费完毕之后，并不立即释放，工厂类保持起初始状态，等待再次被使用。 public class ProductFactory{ private static final Map prMap = new HashMap(); public static synchroniezed Product createProduct(String type) throws Exception { Product product = null; if (prMap.containsKey(type)) { product = prMap.get(type); }else{ if(type.equals(\"Product1\")){ product = new ConcreteProduct1(); }else { product = new ConcreteProduct2(); } // 同时放到缓存中 prMap.put(type, product); } return product; } } 代码非常简单，利用map来做缓存，注意这个使用synchronized保证线程安全，一个性能改进的办法是使用ConcurrentHashMap的putIfAbsent方法。 延迟框架是可以扩展的，例如限制某一个产品类的最大实例化话数量，可以通过判断Map中已有的对象数量来实现。例如JDBC连接数据库，都会要设置一个MaxConnections最大连接树龄，该数量就是内存中最大实例化的数量。 参考 [设计模式]工厂方法模式 工厂方法模式（Factory Method）-最易懂的设计模式解析 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 16:55:44 "},"设计模式/设计模式/创建型模式/Singleton.html":{"url":"设计模式/设计模式/创建型模式/Singleton.html","title":"Singleton","keywords":"","body":"Singleton 什么是单例？ 单例模式是最常用的设计模式，也是最简单的设计模式。它保证一个类只要一个实例，并且提供一个全局的访问点。 单例模式的实现 首先，如何保证只有一个？不能被随意创建吧，所以至少构造方法是私有的。OK，私有是可以接受的，但是你得提供访问方法啊？这里需要解决两个问题。一是对象只有一个，只能被创建一遍，如何保存这个实例呢，很简单，将其作为一个私有变量就行，注意是私有的。二是如何提供方法点呢，提供一个公有的方法，这个方法将这个私有变量返回出来就行。由于这个类不能被初始化（因为没有公有的构造函数），所以只能通过静态方法访问了，所以这个“全局访问点”应该是一个public static修饰的方法，根据“静态方法不能访问实例变量”这个特性，保存实例的那个私有变量应该也被\"static\"修饰。 为什么不能是公有的instance?比如写成这样： public Singleton{ public static final Singleton = new Singleton() private Singleton(){} } 所以，总结下来，Singleton实现有三个要点： 需要有一个私有静态变量保存这个实例，使得这个类的所有对象都公用这个实例。 类中还得有一个私有的构造函数，来主动创建这个私有静态变量 类得提供一个公有静态方法来让别人获得这个实例。 单例模式有很多实现方式。下面就是几种常见的实现： 懒汉模式 为什么起这个名儿呢？因为这个方法很懒，懒到什么程度？只有在被调用的时候才会实例化这唯一的一个实例，如果一直不被调用，那么一直不实例化。实现过程如下： public class LazySingleton { private static LazySingleton instance; private LazySingleton(){ } public static LazySingleton getInstance(){ if (instance == null){ instance = new LazySingleton(); } return instance; } } 这种写法是线程非安全的。因为如果有两个线程调用getInstance方法，它们同时执行到instance == null，此时都会判断为true，所以都会分别创建一个实例，违背了单例模式的初衷。 饿汉模式 所谓的饿汉，就是等不及别人来调用，自己就先实例化自己，生怕自己饿着了。所以叫饿汉。实现如下： public class HugerSingleton { private static final HugerSingleton instance = new HugerSingleton(); private HugerSingleton(){ } public static HugerSingleton getInstance(){ return instance; } } 这种写法一定是线程安全的，因为instance是类变量，在类载入的时候就初始化好了。所以不管多少个线程调用，得到的都是同一个实例。 这个方法的缺点在不必要获取实例的时，已经产生了开销。 双重锁模式 又想要不过早产生开销，又想要线程安全，所以对“懒汉模式”做出改变。实现如下： public class SyncSingleton { private static SyncSingleton instance; private SyncSingleton(){} public static SyncSingleton getInstance(){ if (instance == null){ // 这个条件的存在是为了提交性能，不让这个方法每调用一次就同步一次 synchronized (SyncSingleton.class){ // 这是为了保证线程安全 if (instance === null) { // 这是为了保证单例 instance = new SyncSingleton(); } } } return instance; } } 双重锁写法是对懒汉模式的改进，采用类锁的方式。假如有两个线程同时调用getInstance方法，由于synchronized类锁的存在，只有一个线程能执行，另一个必须等待，等到第一个执行完了，第二个线程判断的时候已经没有instance == null的条件，所以两个线程返回的是同一个实例。为什么叫“双重锁”呢？哪双重？第一重是synchronized这个条件，第二个是instance === null这个条件，这两个锁保证了不过早产生开销，又保证了线程同步。 为什么DoubleCheck需要两次判断和一次同步呢？试想有两个线程A和B，同时请求单例，显然他们都可以通过第一层的instance == null的判断，然后相互竞争，假设A获得了类锁，然后进入了临界区进行初始化，最后退出，这时候开始新一轮的锁的竞争，假设B得到的锁，进入临界区，如果此时没有第二重锁instance == null，那么B线程仍旧还会调用instance == new Singleton()方法，也就没有达到单例的效果了。 也有人说可以将synchronized加到getInstance方法上，让它成为一个线程同步方法，这种做法同样可以实现功能，但是同步方法被频繁调用，内存占用大，效率低。而采用同步块的方法，由于第一重锁的存在，同步块实际上只被执行了一次，效率高。所以双重锁模式是单例的最佳实现。 线程安全的双重锁模式 关于指令重排的内容参见\"JVM-内存模型\"的相关内容。这里解释一下为什么下原来双重锁的单例可能存在线程安全问题： instance = new SyncSingleton()不是一个原子操作，它可以分解成以下三个原子操作： // 伪代码 memory = allocate(); // 1. 分配对象内存空间 instance (memory); // 2. 初始化对象 instance = memory; // 3. 设置instance指向刚才分配的内存地址, 此时 instance != null 由于存在指令重排，所以重排之后的指令可能是这样的： // 伪代码 memory = allocate(); // 1. 分配对象内存空间 instance = memory; // 3. 设置instance指向刚才分配的内存地址, 此时 instance != null instance (memory); // 2. 初始化对象 这就有问题了！ 试想，一开始有ABC三个线程，一同去请求这个单例，他们首先到达第一层的判空，发现对象为空，此时开始锁竞争，最终胜出，而BC在同步块外面等着。此线程进入了同步块，判空发现还是null。那么进行instance = new DoubleCheckLock()，就是上述三个子过程，如果发生了指令重排，当进行到instance = memory之后，此时instance != null已经是true了。此时线程D也来请求这个单例，它停在第一个判空操作那里，发现instance != null为true，所以就直接返回这个单例，但是！这个A线程还没有来得及初始化呢！所以D线程用着这个单例一定会出错！这就是为什么需要volatile来禁止指令重排的原因了。 所以线程安全又高效的单例应该这么写： public class SyncSingleton { private volatile SyncSingleton instance; private SyncSingleton(){} public static SyncSingleton getInstance(){ if (instance == null){ synchronized (SyncSingleton.class){ instance = new SyncSingleton(); } } return instance; } } 占位方式 public class LazyInitHolderSingleton { private LazyInitHolderSingleton() {} private static class SingletonHolder { private static final LazyInitHolderSingleton INSTANCE = new LazyInitHolderSingleton(); } public static LazyInitHolderSingleton getInstance() { return SingletonHolder.INSTANCE; } } 这里使用了内部类来保存一个单例，只有第一次使用的时候才初始化内部类SingletonHolder类，所以既解决了性能也处理了并发的问题。 枚举型 public enum SingletonClass{ INSTANCE; } 单例模式的使用场景 单例模式的使用场景当然是那些要求一个类有且仅有一个对象的场景，比如： 要求生成唯一序列号的环境 把整个项目中需要一个共享访问点或共享数据，例如一个web页面上的计数器，可以不用每次把刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的。 如果创建一个对象需要消耗的资源过多，比如要访问IO和数据库等资源，此时就可以考虑使用单例。 需要定义大量的静态常量和静态方法（比如工具类）的华宁，可以采用单例（当然也可以直接声明为static） 扩展——有上限的多例模式 单例是只允许出现一个实例的类，那么只允许出现n个实例的类应该怎么写？ 很简单，在单例中保存n个实例，然后随机返回就行了。 public clss Nton (){ // 定义最多能产生的实例个数 private static int maxNumber = 2; // 保存实例 private static ArrayList list = new ArrayList(); //当前实例的序号 private static countNum = 0; private Nton(){} static { for (int i = 0; i 实际上可以看出，上面这种写法用的就是类似于单例中的“占位”方法。 实践 JDK中的单例模式：java.lang.Runtime#getRuntime() Spring 中每个默认单例的bean，这些bean是可以被Spring容器管理的，如果采用非单例模式（prototype类型）,则bean初始化之后的管理就交由J2EE容器，Spring 容器不再跟踪管理Bean的生命周期。交由Spring容器管理的好处就是不用担心JVM的垃圾回收机制。 参考 [设计模式]单例模式 设计模式：单例模式（Singleton） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 15:46:17 "},"设计模式/设计模式/创建型模式/Builder.html":{"url":"设计模式/设计模式/创建型模式/Builder.html","title":"Builder","keywords":"","body":"Builder 创建者模式将一个复杂对象的创建和表示相分离，使得同样的创建过程可以创建不同的表示。是一种对象创建型模式。 构造者模式的含义 使用创建者模式，用户只需要指定需要创建的的类型，具体的创建过程不需要知道。 创建者模式中涉及到这几种角色： 产品（Product）：这就是最终被需要的产品，产品由多个部件构成 抽象创建者（AbstractBuilder）：抽象创建者，是一个接口，它确定产品由哪些部分构成，并提供一个得到产品建造后果的方法 具体创建者（ConcreteBuilder）：实现抽象创建者中的具体方法。 指挥类（Director）：指挥建造product的过程。 客户端（Client）：用户不需要知道创建过程，而是指定一个指挥类，并给它配置一个创建者既可以了。 举一个例子：客户想到建造一个房子，房子由很多个部分构成，比如地基、屋顶、墙等。客户只需要指定一个设计师并给他配置一个建筑师，把建造房子的任务交给他们即可，自己不需要知道房子建造的过程。这个过程就是下面这样的： public class Test { public static void main(String[] args) { Builder builder = new Worker(); Director director = new Director(); director.conduct(builder);//设计师指导建筑师怎么建造房子 House house = builder.getHouse(); house.show(); } } 从上面代码可以看到，客户端没有参与到房子的建造中，他所做的工作就是指派一个设计师和一个建筑师，然后让设计师指导建筑师建造房子，最后由建筑师交付房子即可。 上面最关键的一个步骤就是设计师指导建筑师建造房子的过程： public class Director { public void conduct(Builder builder) { builder.buildFoundation(); builder.buildWall(); builder.buildRoof(); builder.buildDoor(); builder.buildWindow(); } } 而设计师不关心具体的操作的“人”是谁，他只关心来的人是一个建筑师，即Builder的实例，那么他就有建造房子的能力，那么他需要要求建筑师按照自己的“设计”来建造房子，这里的“设计”的意思比较简单，就是建造的顺序。 而Builder是建筑师这一个类别的抽象，它表明了建筑师应该会的几种技能： public interface Builder { void buildFoundation(); void buildWall(); void buildRoof(); void buildWindow(); void buildDoor(); House getHouse(); } 而要建成的House是什么样的情况呢？ public class House { List parts = new ArrayList<>(); public void addPart(String part){ parts.add(part); } public void show(){ for (String part : parts){ System.out.println(part + \" \"); } } } 一个house需要由很多个部分组成，所以其中定义了一个保存“部分”的线性表。 那么在真正实施的时候，真正的Builder需要将各个部分都创建好，并且将创建好的产品Houser返回。 public class Worker implements Builder{ private House house = new House(); @Override public void buildFoundation() { house.addPart(\"foundation\"); } @Override public void buildWall() { house.addPart(\"wall\"); } @Override public void buildRoof() { house.addPart(\"roof\"); } @Override public void buildWindow() { house.addPart(\"window\"); } @Override public void buildDoor() { house.addPart(\"door\"); } @Override public House getHouse() { return house; } } 建造者模式的优点 封装性： 使得客户端不必知道产品内部组成的逻辑。 建造者独立，容易扩展 便于控制细节风险 建造者模式的使用场景 相同的方法，不同的执行顺序，产生不同的时间处理结果，可以采用建造者模式 多个部件或零件，都可以装配到一个对象中，但是产生的结果运行又不相同时候，可以使用该模式。 产品类非常复杂， 或者产品类中调用顺序不同产生了不同的效能，可以使用这种方法。 在对象创建过程中会使用到系统中一些其他对象，这些对象在产品对象的创建过程中不容易得到，也可以建造者模式封装该对象的创建过程。这种场景只能是一个补偿方法。 注意和其他创建型设计模式的区别。建造者模式关注的是零件类型和装配工艺（顺序）。 参考 [设计模式]建造者模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-29 23:39:49 "},"设计模式/设计模式/创建型模式/Prototype.html":{"url":"设计模式/设计模式/创建型模式/Prototype.html","title":"Prototype","keywords":"","body":"Prototype 原型模式： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 原型模式 举个例子。批量发送账单： // 广告信模板类 public class AdvTemplate{ // 广告信名称 private String advSubject = \"xxx银行国庆信用卡抽奖活动\"; // 广告信内容 private String advContext = \"国庆抽奖活动通知，只要刷卡就送你一百万！....\"; // setter & getter } // 邮件类 public class Mail{ // 收件人 private String receiver; // 邮件名称 private String subject; // 称谓 private String appellation; // 邮件内容 private String context; // 邮件的尾部，一般都是加上\"xxx版权所有\"等信息 private String tail; // 构造函数 public Mail(AdvTemplate advTemplate){ this.context = advTemplate.getAdvContext(); this.subject = advTemplate.getAdvSubject(); } // getter & setter } 场景类： public class Client { // 发送账单的数量，这个值是从数据中获取的 private static int MAX_COUNT = 6; public static void main(String[] args){ // 模拟发送邮件 int i = 0; // 把模板定义出来，这个是从数据库中取得的 Mail mail = new Mail(new AdvTemplate()); mail.setTail(\"XXX银行所有\")； while (i 这个方法的问题在于： ①如果是单线程。大量邮件需要发送耗费很长时间。 ②如果是多线程，会有线程安全问题。即产生第一封邮件对象，放到线程1中运行，还没有发送出去，线程2也启动了，直接把邮件对象mail的收件人改掉了，线程不安全了。 其实第二点有点不太明白，为什么线程2会把邮件的收件人改掉？这个线程只包含mail过程么？如果是这样，为什么不能从一开始就将所有的处理（包括定义mail）就包含在不同的线程中呢？ 通过对象的赋值功能能解决这个问题。 // 邮件类 public class Mail implements Cloneabel{ // 收件人 private String receiver; // 邮件名称 private String subject; // 称谓 private String appellation; // 邮件内容 private String context; // 邮件的尾部，一般都是加上\"xxx版权所有\"等信息 private String tail; // 构造函数 public Mail(AdvTemplate advTemplate){ this.context = advTemplate.getAdvContext(); this.subject = advTemplate.getAdvSubject(); } // getter & setter @Override public Mail clone(){ Mail mail = null; try{ mail = (Mail) super.clone(); }catch (CloneNotSupportException e){ // todo e.printStackTrace(); } return mail; } } 然后发送邮件的客户端改成这样： public class Client { // 发送账单的数量，这个值是从数据中获取的 private static int MAX_COUNT = 6; public static void main(String[] args){ // 模拟发送邮件 int i = 0; // 把模板定义出来，这个是从数据库中取得的 Mail mail = new Mail(new AdvTemplate()); mail.setTail(\"XXX银行所有\")； while (i 以上就是原型模式的使用方法：原型实例实现Cloneabel接口，然后重写clone方法。调用该方法就能快速复制拷贝出新对象。 在重写clone方法的时候，要特别注意深拷贝和浅拷贝。 super.clone()是Object中的方法，它只能将“值”拷贝下来，这对于一些基本类型（这里包括String类型，它没有clone方法，通过线程池在需要的时候才在内存中创建新字符串）是适用的，但是对于引用类型，这个“值”指的是对象的地址。只是增加了一个指向该对象的指针，这叫做浅拷贝。深拷贝需要自己写。怎么写呢？自己new呗。被拷贝的对象中有一个属性是ArrayList，那么在clone的时候，除了调用super.clone()，还需要自己new一个ArrayList出来。 另外还要注意，如果被拷贝的对象中有final属性，clone就会出错。所以在应用原型模式的时候，不能出现final字段。clone和final是冲突的。 原型模型的优点 性能优良：原型模式是在内存二进制流的拷贝，比直接new一个对象性能要好的多，特别是在一个循环体内产生大量的对象时，非常适合用原型模型。 逃避构造函数的约束：既是优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。 参考 [设计模式]原型模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-29 23:39:51 "},"设计模式/设计模式/结构型模式/结构型模式.html":{"url":"设计模式/设计模式/结构型模式/结构型模式.html","title":"结构型模式","keywords":"","body":"结构型模式 适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口。 •java.util.Arrays#asList() •javax.swing.JTable(TableModel) •java.io.InputStreamReader(InputStream) •java.io.OutputStreamWriter(OutputStream) •javax.xml.bind.annotation.adapters.XmlAdapter#marshal() •javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal() 桥接模式(Bridge)：将抽象部分与实现部分分离，使它们都可以独立的变化。 • AWT (提供了抽象层映射于实际的操作系统) •JDBC 组合模式(Composite) •javax.swing.JComponent#add(Component) •java.awt.Container#add(Component) •java.util.Map#putAll(Map) •java.util.List#addAll(Collection) •java.util.Set#addAll(Collection) 装饰器模式(Decorator)：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 •java.io.BufferedInputStream(InputStream) •java.io.DataInputStream(InputStream) •java.io.BufferedOutputStream(OutputStream) •java.util.zip.ZipOutputStream(OutputStream) •java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap 外观模式(Facade) •java.lang.Class •javax.faces.webapp.FacesServlet 享元模式(Flyweight) •java.lang.Integer#valueOf(int) •java.lang.Boolean#valueOf(boolean) • java.lang.Byte#valueOf(byte) •java.lang.Character#valueOf(char) 代理模式(Proxy) • java.lang.reflect.Proxy •java.rmi.* Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 16:34:12 "},"设计模式/设计模式/结构型模式/Adapter.html":{"url":"设计模式/设计模式/结构型模式/Adapter.html","title":"Adapter","keywords":"","body":"Adapter 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Executors中定义的RunableAddapter就是适配器模式的实践者。 适配器模式又叫做“变压器模式”，也叫“包装器模式”（Wrapper）。但是包装。但是包装器可不止这一个，它还包括装饰器模式。 适配器模型 Target : 定义用户实际需要的接口。abstract class Target { public abstract void Request(); } Adaptee : 定义一个需要适配的接口。class Adaptee { public void SpecificRequest() { System.out.println(\"特殊请求\"); } } Adapter : 通过在内部包装一个 Adaptee 对象，把源接口转换成目标接口。 class Adapter extends Target { private Adaptee adaptee = new Adaptee(); @Override public void Request() { adaptee.SpecificRequest(); } } 测试代码 public class AdapterPattern { public static void main(String[] args) { Target target = new Adapter(); target.Request(); //特殊请求 } } 以上这种通过继承进行的适配，叫做“类适配器”。还有一种是对对象的合成，叫做“对象适配器”。 使用场景 想要使用一个已经存在的类，但如果它的方法不满足需求时； 两个类的职责相同或相似，但是具有不同的接口时要使用它； 应该在双方都不太容易修改的时候再使用适配器模式适配，而不是一有不同时就使用它。 适配器模型是一种补充模型。 参考 JAVA 设计模式 适配器模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 20:19:55 "},"设计模式/设计模式/结构型模式/Bridge.html":{"url":"设计模式/设计模式/结构型模式/Bridge.html","title":"Bridge","keywords":"","body":"Bridge 将抽象部分与实现部分分离，使它们都可以独立的变化。 重点在于解耦。 桥接模式 Implementor : 定义实现接口 interface Implementor { // 实现抽象部分需要的某些具体功能 public void operationImpl(); } Abstraction : 定义抽象接口 abstract class Abstraction { // 持有一个 Implementor 对象，形成聚合关系 protected Implementor implementor; public Abstraction(Implementor implementor) { this.implementor = implementor; } // 可能需要转调实现部分的具体实现 public void operation() { implementor.operationImpl(); } } ConcreteImplementor: 实现 Implementor 中定义的接口 class ConcreteImplementorA implements Implementor { @Override public void operationImpl() { // 真正的实现 System.out.println(\"具体实现A\"); } } class ConcreteImplementorB implements Implementor { @Override public void operationImpl() { // 真正的实现 System.out.println(\"具体实现B\"); } } RefinedAbstraction: 扩展 Abstraction 类 class RefinedAbstraction extends Abstraction { public RefinedAbstraction(Implementor implementor) { super(implementor); } public void otherOperation() { // 实现一定的功能，可能会使用具体实现部分的实现方法, // 但是本方法更大的可能是使用 Abstraction 中定义的方法， // 通过组合使用 Abstraction 中定义的方法来完成更多的功能。 } } 测试代码： public class BridgePattern { public static void main(String[] args) { Implementor implementor = new ConcreteImplementorA(); RefinedAbstraction abstraction = new RefinedAbstraction(implementor); abstraction.operation(); // 具体实现A abstraction.otherOperation(); // 其他操作 } } 桥接模式的优点 抽象和实现的分离：这是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式，在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。 优秀的扩充能力： 实现细节对客户透明：客户不用关系细节的实现，它已经由抽象层通过聚合关系完成了封装。 桥接模式的应用场景 不希望或不适合使用继承的场景 接口或抽象类不稳定的场景 重用性要求比较高的场景：设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受到父类的限制，不可能出现太细的颗粒度。 参考 JAVA 设计模式 桥接模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-22 20:57:10 "},"设计模式/设计模式/结构型模式/Composite.html":{"url":"设计模式/设计模式/结构型模式/Composite.html","title":"Composite","keywords":"","body":"Composite 将对象组合成树形结构以表示“部分-整体”的层次结构。 组合模式使得用户对单个对象和组合对象的使用具有唯一性 什么意思呢？比如，我们创建两个对象，他们的性质实际上是不同的，他们之间具有“整体-部分”的关系，但是我们可以用同样的方法来操纵他们。 最典型的例子就是文件系统，\"文件夹\"和“文件”是文件系统的组成，如果文件系统是一棵树，那么“文件夹”是一个非叶子节点，“文件”是一个叶子节点，它们之间是树形关系。两者也有一些共性，比如都可以进行复制、剪切、粘贴、重命名等，但是又有一些细微的差别，比如文件夹的删除操作，我们需要删除它以下的所有子文件夹和文件，而对于一个文件，只用删除文件本身就行。 那么定义当中的一致性就体现在，客户端不用管当前操作的是文件还是文件夹，只需要使用同样语义的方法进行操作就行，不用特别去处理。 所以，根据组合模式，我们首先给出一个接口，这个接口就是所谓的“component”，它定义了文件和文件夹的公共行为。 package com.composite; //文件系统中的节点接口 public interface IFile { void delete(); String getName(); void createNewFile(String name); void deleteFile(String name); IFile getIFile(int index); } 类图中的operation方法是一个宏观定义，它代表的意思是叶子节点和非叶子节点的公共行为，并不是说只有一个operation方法，本次LZ给出两个共有行为作为代表，即删除操作和获取文件名称的操作。 下面来看看非叶子节点的操作，即文件夹的操作： package com.composite; import java.util.ArrayList; import java.util.List; //文件夹 public class Folder implements IFile{ private String name; private IFile folder; private List files; public Folder(String name) { this(name, null); } public Folder(String name,IFile folder) { super(); this.name = name; this.folder = folder; files = new ArrayList(); } public String getName() { return name; } //与File的删除方法不同，先删除下面的文件以及文件夹后再删除自己 public void delete() { List copy = new ArrayList(files); System.out.println(\"------------删除子文件-------------\"); for (IFile file : copy) { file.delete(); } System.out.println(\"----------删除子文件结束-------------\"); if (folder != null) { folder.deleteFile(name); } System.out.println(\"---删除[\" + name + \"]---\"); } public void createNewFile(String name) { if (name.contains(\".\")) { files.add(new File(name,this)); }else { files.add(new Folder(name,this)); } } public void deleteFile(String name) { for (IFile file : files) { if (file.getName().equals(name)) { files.remove(file); break; } } } public IFile getIFile(int index) { return files.get(index); } } 我们看到这里面最主要的地方在于它有一个List属性，这个属性是树结构的关键点，当我们删除一个文件夹时，即delete方法，我们会首先删除该文件夹下面的所有文件以及文件夹，这与我们平时使用的windows操作系统的文件操作是一致的。 叶子节点即文件的实现如下： package com.composite; //文件 public class File implements IFile{ private String name; private IFile folder; public File(String name,IFile folder) { super(); this.name = name; this.folder = folder; } public String getName() { return name; } public void delete() { folder.deleteFile(name); System.out.println(\"---删除[\" + name + \"]---\"); } //文件不支持创建新文件 public void createNewFile(String name) { throw new UnsupportedOperationException(); } //文件不支持删除文件 public void deleteFile(String name) { throw new UnsupportedOperationException(); } //文件不支持获取下面的文件列表 public IFile getIFile(int index) { throw new UnsupportedOperationException(); } } 文件类中的delete方法与文件夹中的不同，一个文件的删除操作，只需要删除它自己即可。我们还会注意到，下面的三个方法，LZ全部抛出了不支持的操作的异常，这也是与我们传统意义上的文件操作是一致的，一个文件当然不能在该文件下进行创新新文件、删除文件以及获取某个文件的操作。当然，你也可以直接将三个方法放空，或者返回null值。但是这样不推荐，因为不利于调试。 现在看一个文件系统的操作 package com.composite; public class Main { public static void main(String[] args) { IFile root = new Folder(\"我的电脑\"); root.createNewFile(\"C盘\"); root.createNewFile(\"D盘\"); root.createNewFile(\"E盘\"); IFile D = root.getIFile(1); D.createNewFile(\"project\"); D.createNewFile(\"电影\"); IFile project = D.getIFile(0); project.createNewFile(\"test1.java\"); project.createNewFile(\"test2.java\"); project.createNewFile(\"test3.java\"); IFile movie = D.getIFile(1); movie.createNewFile(\"致青春.avi\"); movie.createNewFile(\"速度与激情6.avi\"); /* 以上为当前文件系统的情况，下面我们尝试删除文件和文件夹 */ display(null, root); System.out.println(); project.delete(); movie.getIFile(1).delete(); System.out.println(); display(null, root); } //打印文件系统 public static void display(String prefix,IFile iFile){ if (prefix == null) { prefix = \"\"; } System.out.println(prefix + iFile.getName()); if(iFile instanceof Folder){ for (int i = 0; ; i++) { try { if (iFile.getIFile(i) != null) { display(prefix + \"--\", iFile.getIFile(i)); } } catch (Exception e) { break; } } } } } 在我们操作的过程中，我们并不知道当前的操作是文件还是文件夹，我们都以同样的方法去操作，不同的节点对应了不同的操作实现。 上面是一个标准的组合模式的使用方法，但是其中有不妥之处，比如对于文件来说，有三个方法是不支持的，之所以出现这种情况是，是因为IFile中提供的是宽接口，这样做的目的是为了保持对客户端的透明性，然而相应却带来不安全性。 一个解决方法是，为了安全性牺牲透明性，即把IFile中叶子节点不支持的三个行为全部删掉，由此可见，组合模式中，安全性和透明性是互相矛盾的，这是由于叶子节点和非叶子节点行为的不一致及需要提供一个统一行为的接口造成的，是不可调和的矛盾。 一个解决办法是，在使用这些有安全性问题的方法之前先判断其类型，比如： IFile movie = D.getIFile(1); if (movie instanceof Folder) { Folder folder = (Folder) movie; //下面使用folder进行文件夹独有的操作 } 但是这样好像又不符合组合模式\"用户对单个对象和组合对象的使用具有唯一性\"的特点。 参考 设计模式之组合模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 19:33:53 "},"设计模式/设计模式/结构型模式/Decorator.html":{"url":"设计模式/设计模式/结构型模式/Decorator.html","title":"Decorator","keywords":"","body":"Decorator 动态 地给对象添加一些额外的 职责。就增加功能来说，Decorator模式相比生成子类更加灵活 允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，以达到特定的目的。 装饰器有两个角色：组件（被装饰者）和装饰者。 抽象组件（Component）：需要装饰的抽象对象。 具体组件（ConcreteComponent）：是我们需要装饰的对象 抽象装饰类（Decorator）：内含指向抽象组件的引用及装饰者共有的方法。 具体装饰类（ConcreteDecorator）：被装饰的对象。 举个例子：我们要了一杯咖啡，需要往里面加奶和糖等。这里，咖啡就是我们的组件，奶和糖就是我们的装饰者。现在我们来计算调制这样一杯咖啡需要花费多少。 首先定义抽象组件，咖啡是一种饮料，饮料有的属性比如都需要花钱、都有一个描述，所以： package DesignPattern.Strategy.Decorator; public interface Drink { public float cost(); public String getDescription(); } 之后就创建组件咖啡 package DesignPattern.Strategy.Decorator; public class Coffee implements Drink { final private String description = \"coffee\"; //每杯 coffee 售价 10 元 public float cost() { return 10; } public String getDescription() { return description; } } 接着创建我们的装饰者的抽象类，把它叫做“调味抽象类”，就是奶、糖这种装饰者的抽象类： package DesignPattern.Strategy.Decorator; public abstract class CondimentDecorator implements Drink { protected Drink decoratorDrink; public CondimentDecorator(Drink decoratorDrink) { this.decoratorDrink = decoratorDrink; } public float cost() { return decoratorDrink.cost(); } public String getDescription() { return decoratorDrink.getDescription(); } } 可以看到，这个接口接受了一个Drink的对象，表示这个装饰着来装饰“什么东西”。 然后我们创建真正的装饰者： //Suger 糖装饰者 package DesignPattern.Strategy.Decorator; public class Sugar extends CondimentDecorator { public Sugar(Drink decoratorDrink) { super(decoratorDrink); } @Override public float cost() { return super.cost() + 1; } @Override public String getDescription() { return super.getDescription() + \" sugar\"; } } //Milk牛奶装饰者 package DesignPattern.Strategy.Decorator; public class Milk extends CondimentDecorator { public Milk(Drink decoratorDrink) { super(decoratorDrink); } @Override public float cost() { return super.cost() + 2; } @Override public String getDescription() { return super.getDescription() + \" milk\"; } } 怎么调制呢? package DesignPattern.Strategy.Decorator; public class CoffeeShop { public static void main(String[] args) { //点一杯coffee Drink drink = new Coffee(); System.out.println(drink.getDescription() + \":\" + drink.cost()); //加一份奶 drink = new Milk(drink); System.out.println(drink.getDescription() + \":\" + drink.cost()); //加一份糖 drink = new Sugar(drink); System.out.println(drink.getDescription() + \":\" + drink.cost()); //再加一份糖 drink = new Sugar(drink); System.out.println(drink.getDescription() + \":\" + drink.cost()); } } 这个变化过程是一步步的，咖啡-》加了奶的咖啡-》加了糖的咖啡，但是它的本质是不变的，都是Drink，实际上，如果将sugar和Milk改成CoffeeWithSuger和CoffeeWithMilk更容易理解一些。 在Java I/O库中有两个对称性，他们分别是： 输入-输出对称：比如InputStream 和OutputStream 各自占据Byte流的输入和输出的两个平行的等级结构的根部；而Reader和Writer各自占据Char流的输入和输出的两个平行的等级结构的根部。 byte-char对称：InputStream和Reader的子类分别负责byte和Char流的输入；OutputStream和Writer的子类分别负责byte和Char流的输出 这些作为根类，如果我们想通过缓冲，字节，或者是管道，这个时候我们就需要使用装饰器来进行装饰，然后通过装饰器来实现相应的操作，根类具有read方法，对于装饰类，通过构造函数将基类的一个实例注入进去，然后通过委托模式，首先通过基类的read方法获取字节流，然后根据相应的操作，实现字节读取等。 InputStreamReader input = new InputStreamReader(System.in); BufferedReader reader = new BufferedReader(input); String line = reader.readLine(); 参考 设计模式（5）装饰器模式（讲解+应用） 设计模式 —— 装饰器模式（Decorator Pattern） JAVA 设计模式 装饰者模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-29 23:55:46 "},"设计模式/设计模式/结构型模式/Facade.html":{"url":"设计模式/设计模式/结构型模式/Facade.html","title":"Facade","keywords":"","body":"Facade 门面模式 门面模式也叫做外观模式，是一种比较常见的封装模式。要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。是一个高层次的接口，使得子系统更易于使用。 这里需要明确一下门面模式的角色 Facade门面角色 ： 客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。会将所有从客户端发来的请求委派到相应的子系统去，也就是说该角色没有实际的业务逻辑，只是一个委托类。 subsystem子系统角色： 可以同时有一个或者多个子系统，每个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 子系统 public class ClassA{ public void doSomethingA{ // 业务逻辑 } } public class ClassB{ public void doSomethingB(){ // 业务逻辑 } } public class ClassC{ public void doSomethingC{ // 业务逻辑 } } 门面对象 public class Facade { // 被委托的对象 private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); // 提供给外部访问的方法 public void methodA(){ this.a.doSomethingA() } public void methodB(){ this.b.doSomethingB(); } public void methodC(){ this.c.doSomethingC(); } } 门面模式的优缺点 优点 减少系统间的依赖 提高灵活性：不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。 提高安全性 缺点 不符合开闭原则。一旦投产以后，如果发现错误，没有办法解决，继承、覆写都不管用，唯一能做的是修改门面角色的代码。 门面模式的使用场景 为复杂的模块或子系统提供一个供应外界访问的接口 子系统相对独立——外界对子系统的访问只需要黑箱操作即可 预防低水平人员带来的风险扩散 参考 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-29 23:55:51 "},"设计模式/设计模式/结构型模式/Flyweight.html":{"url":"设计模式/设计模式/结构型模式/Flyweight.html","title":"Flyweight","keywords":"","body":"Flyweight Flyweight模式翻译过来是“享元模式”，名字有点怪，但是我们实际上一直在用这种模式，只是不知道这叫做享元模式。 Flyweight是拳击比赛中的特有名词，意思是“较轻量级”。 享元技模式是池技术的重要实现方式，其定义如下：使用共享对象可有效得支持大量细粒度的对象。 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 对象池（Object Pool）的实现有很多开源工具，比如Apache的common-pool就是一个不错的池工具。 public class ConnectionPool { private Vector pool; /*公有属性*/ private String url = \"jdbc:mysql://localhost:3306/test\"; private String username = \"root\"; private String password = \"root\"; private String driverClassName = \"com.mysql.jdbc.Driver\"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() { pool = new Vector(poolSize); for (int i = 0; i 0) { Connection conn = pool.get(0); pool.remove(conn); return conn; } else { return null; } } } Java API中的享元模式应用，比如String.intern()方法。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-29 23:59:58 "},"设计模式/设计模式/结构型模式/Proxy.html":{"url":"设计模式/设计模式/结构型模式/Proxy.html","title":"Proxy","keywords":"","body":"Proxy 代理模式也叫做为委托模式，为其他对象提供一种代理以控制对这个对象的访问。 静态代理模式 //Subject接口的实现 public interface Subject { void visit(); } 有两个实现了Subject的实现类： // RealSubject public class RealSubject implements Subject { private String name = \"byhieg\"; @Override public void visit() { System.out.println(name); } } // ProxySubject public class ProxySubject implements Subject{ private Subject subject; public ProxySubject(Subject subject) { this.subject = subject; } @Override public void visit() { subject.visit(); } } 具体的调用如下： public class Client { public static void main(String[] args) { ProxySubject subject = new ProxySubject(new RealSubject()); subject.visit(); } } 为什么和适配器那么像？但是有一点不一样，适配器是将一个接口A转化成另一个接口B，两者的身份并没有重叠。而代理模式中，代理对象和被代理对象都是同一个接口的实例，只是在代理者的handler中调用被的代理这的handler。 通过上面的代理代码，我们可以看出代理模式的特点，代理类接受一个Subject接口的对象，任何实现该接口的对象，都可以通过代理类进行代理，增加了通用性。但是也有缺点，每一个代理类都必须实现一遍委托类（也就是realsubject）的接口，如果接口增加方法，则代理类也必须跟着修改。其次，代理类每一个接口对象对应一个委托对象，如果委托对象非常多，则静态代理类就非常臃肿，难以胜任。 注意还可以定义强制代理。 动态代理 动态代理是结构型数据模式的核心，AOP就是采用了动态代理机制。 动态代理有别于静态代理，是根据代理的对象，动态创建代理类。这样，就可以避免静态代理中代理类接口过多的问题。动态代理是实现方式，是通过反射来实现的，借助Java自带的java.lang.reflect.Proxy，通过固定的规则生成。 其步骤如下： 编写一个委托类的接口，即静态代理的（Subject接口） 实现一个真正的委托类，即静态代理的（RealSubject类） 创建一个动态代理类，实现InvocationHandler接口，并重写该invoke方法 在测试类中，生成动态代理的对象。 第一二步骤，和静态代理一样，不过说了。 第三步，代码如下： public class DynamicProxy implements InvocationHandler { private Object object; public DynamicProxy(Object object) { this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = method.invoke(object, args); return result; } } 第四步，创建动态代理类： Subject realSubject = new RealSubject(); DynamicProxy proxy = new DynamicProxy(realSubject); ClassLoader classLoader = realSubject.getClass().getClassLoader(); Subject subject = (Subject) Proxy.newProxyInstance(classLoader, new Class[]{Subject.class}, proxy); subject.visit(); 创建动态代理的对象，需要借助Proxy.newProxyInstance。该方法的三个参数分别是： ClassLoader loader表示当前使用到的appClassloader。 Class[] interfaces表示目标对象实现的一组接口。 InvocationHandler h表示当前的InvocationHandler实现实例对象。 关于动态代理的使用，我们就介绍到这里。 参考 Java设计模式之代理模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 00:02:14 "},"设计模式/设计模式/行为型模式/行为型模式.html":{"url":"设计模式/设计模式/行为型模式/行为型模式.html","title":"行为型模式","keywords":"","body":"行为型模式 职责链模式(Chain of Responsibility) •java.util.logging.Logger#log() •javax.servlet.Filter#doFilter() 命令模式(Command) • java.lang.Runnable • javax.swing.Action 解释器模式(Interpreter) • java.util.Pattern • java.text.Normalizer • java.text.Format • javax.el.ELResolver 迭代器模式(Iterator) • java.util.Iterator • java.util.Enumeration 中介者模式(Mediator) • java.util.Timer (所有scheduleXXX()方法) • java.util.concurrent.Executor#execute() • java.util.concurrent.ExecutorService (invokeXXX()和submit()方法) • java.util.concurrent.ScheduledExecutorService (所有scheduleXXX()方法) •java.lang.reflect.Method#invoke() 备忘录模式(Memento) •java.util.Date •java.io.Serializable •javax.faces.component.StateHolder 观察者模式(Observer) •java.util.Observer/java.util.Observable •java.util.EventListener (所有子类) •javax.servlet.http.HttpSessionBindingListener •javax.servlet.http.HttpSessionAttributeListener •javax.faces.event.PhaseListener 状态模式(State) •java.util.Iterator •javax.faces.lifecycle.LifeCycle#execute() 策略模式(Strategy) • java.util.Comparator#compare() • javax.servlet.http.HttpServlet • javax.servlet.Filter#doFilter() 模板方法模式(Template Method) •java.io.InputStream, java.io.OutputStream, java.io.Reader和java.io.Writer的所有非抽象方法 •java.util.AbstractList, java.util.AbstractSet和java.util.AbstractMap的所有非抽象方法 •javax.servlet.http.HttpServlet#doXXX() 访问者模式(Visitor) •javax.lang.model.element.AnnotationValue和AnnotationValueVisitor •javax.lang.model.element.Element和ElementVisitor •javax.lang.model.type.TypeMirror和TypeVisitor Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 16:36:38 "},"设计模式/设计模式/行为型模式/Chain of Responsibility.html":{"url":"设计模式/设计模式/行为型模式/Chain of Responsibility.html","title":"Chain of Responsibility","keywords":"","body":"Chain of Responsibility 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 00:59:49 "},"设计模式/设计模式/行为型模式/Interpreter.html":{"url":"设计模式/设计模式/行为型模式/Interpreter.html","title":"Interpreter","keywords":"","body":"Interpreter 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 参考 JAVA 设计模式 解释器模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 01:13:21 "},"设计模式/设计模式/行为型模式/Template Method.html":{"url":"设计模式/设计模式/行为型模式/Template Method.html","title":"Template Method","keywords":"","body":"Template Method Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:19:52 "},"设计模式/设计模式/行为型模式/Command.html":{"url":"设计模式/设计模式/行为型模式/Command.html","title":"Command","keywords":"","body":"Command 命令模式 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化； 对请求排队或请求日志，以及支持可撤销的操作 不少Command模式的代码都是针对图形界面的，它实际就是菜单命令，我们在一个下拉菜单选择一个命令时，然后会执行一些动作。将这些命令封装成在一个类中，然后用户(调用者)再对这个类进行操作，这就是Command模式，换句话说，本来用户(调用者)是直接调用这些命令的，如菜单上打开文档(调用者)，就直接指向打开文档的代码，使用Command模式，就是在这两者之间增加一个中间者，将这种直接关系拗断，同时两者之间都隔离,基本没有关系了。 显然这样做的好处是符合封装的特性，降低耦合度，Command是将对行为进行封装的典型模式，Factory是将创建进行封装的模式。 参考 java设计模式之命令模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:41:12 "},"设计模式/设计模式/行为型模式/Iterator.html":{"url":"设计模式/设计模式/行为型模式/Iterator.html","title":"Iterator","keywords":"","body":"Iterator 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 01:15:15 "},"设计模式/设计模式/行为型模式/Mediator.html":{"url":"设计模式/设计模式/行为型模式/Mediator.html","title":"Mediator","keywords":"","body":"Mediator Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:19:52 "},"设计模式/设计模式/行为型模式/Memento.html":{"url":"设计模式/设计模式/行为型模式/Memento.html","title":"Memento","keywords":"","body":"Memento 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。一听到备忘录这个字的时候想起了小小时打的游戏，每次遇到大boss的时候都会保存一下进度，打过了就不需要恢复记录，打不过肯定就复原到刚刚保存的记录咯，重新打一遍BOSS，打死为止。哈哈，这就是备忘录模式，虽然很多模式都只是学到基础，但是发现越来越接近生活了。 参考 java设计模式之备忘录模式 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:54:05 "},"设计模式/设计模式/行为型模式/Observer.html":{"url":"设计模式/设计模式/行为型模式/Observer.html","title":"Observer","keywords":"","body":"Observer 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。 这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-30 01:16:45 "},"设计模式/设计模式/行为型模式/State.html":{"url":"设计模式/设计模式/行为型模式/State.html","title":"State","keywords":"","body":"State Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:19:52 "},"设计模式/设计模式/行为型模式/Strategy.html":{"url":"设计模式/设计模式/行为型模式/Strategy.html","title":"Strategy","keywords":"","body":"Strategy 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 参考 Java设计模式之策略模式（Strategy） Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:54:07 "},"设计模式/设计模式/行为型模式/Visitor.html":{"url":"设计模式/设计模式/行为型模式/Visitor.html","title":"Visitor","keywords":"","body":"Visitor Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-05 23:19:52 "},"Java 8新特性/Java 8新特性.html":{"url":"Java 8新特性/Java 8新特性.html","title":"Java 8 新特性","keywords":"","body":"Java 8 新特性 Java8重要的改进的目的都是一个：在多核计算机上支持并行计算。 流：更好利用多核CPU 行为参数化: lambda表达式 接口中默认方法：为了更好使用流，但是又不破坏接口继承规则 涉及源码包： java.util.Stream java.util.Function 流 参考： 《mordern java》 《Java 8 实战》 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-05-01 14:05:18 "},"Java 8新特性/基于-parameters编译器标志.html":{"url":"Java 8新特性/基于-parameters编译器标志.html","title":"基于-parameters编译器标志","keywords":"","body":"基于-parameters Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-22 14:36:36 "},"Java 8新特性/流.html":{"url":"Java 8新特性/流.html","title":"流","keywords":"","body":"流 Stream是Java8的新特性，是非常非常有用的特性。 什么是流 流允许以声明的方式处理数据集合，目前可以看做是集合的高级迭代器。集合操作是最常见的操作，在这之前由于Java罗里吧嗦的语言特性，集合处理非常复杂，引入流计算之后，集合处理就变得非常简单了。 流非常完美的利用了行为参数话以及计算机的多核架构（即不用为了数据处理的任务并行而去操心线程和锁了，Stream API已经承担了这部分的工作） 集合和流的差别是什么？两者的差别在于什么时候进行计算。集合是需要数据全部到位之后才能进行计算，而流则是边取数据边计算。所以，流可以看做是一个延迟创建的集合。而集合则是急切创建的。 流与迭代 流在某些方法和迭代器类似，只能被消费一次，消费一次完成之后将被自动关闭，如果再次消费，将会抛出IllegalStateException异常。 List title = Arrays.asList(\"Java8\", \"Python\", \"Node\"); Stream s = title.stream(); s.forEach(System.out::println); s.forEach(System.out::println); // throw IllegalStateException 流和迭代又有一些区别。通常使用集合的迭代器（无论是for-each的隐式迭代还是iterator的显式迭代），都叫做“外部迭代”。而流的迭代，叫做“隐式迭代”。Stream库已经帮助我们选择了更加符合硬件的数据表示和并行处理，这比我们使用“外部迭代”去处理数据具有更好的性能和可维护性。 流的操作 流的操作还分为中间操作和中断操作。 中间操作：筛选（filter） 、切片(map)、截断（limit）等 终端操作：collect、计数(count)等 流是惰性的，只有终端操作才能出发流处理，即 menu.stream() .filter(d -> d.getCalories() > 300) .map(Dish::getName) .limit(3) .collect(toList()); // 如果没有这句话，那么上面的filter 、map 和limit 也是不能成功的 流的基本操作定义在接口Stream中，我们可以利用filter、distinct、limit、skip对流进行筛选和切片；利用map和flatMap对流中的元素进行提取和转换；使用findFirst、findAny、anyMatch、anyMatch和noneMatch对流中的元素进行查找和匹配，这些方法都是短路运算；使用reduce进行元素的规约，可以用来求出元素的最值。 另外，有三种特化的流：IntStream、DoubleStream和LongStream，特化的目的是为了省去基本数据类型装箱的开销，并且提供数据处理的一些常用方法，例如求和sum，最值max和minx，均值avg，统计summaryStatistics，范围生成range和rangeClosed。三者之间还有asXXXStream进行流之间的相互转换。 使用流的第一步当然是创建流，流的创建有以下几种方法： 从集合创建流。集合的顶层接口Collection提供了stream方法，用来创建流。所以Collection的实例，常用的有List、Set和Queue的实例，都能通过.stream\b来创建流。 Map是不支持流操作，但是java 8 同样对做了一些改变，具体参见相应源码解读。 从数组创建流。Arrays.stream能够创建对象流和基本数据流。 从文件创建流。NIO中Files提供lines方法，能够从文件中直接创建流。 创建无限流，Stream.iterator和Stream.generate提供了创建无限流的方法，前者会依次生成流元素，而后者只能随机生成流元素。 生成空流。Stream.empty生成空流。 其实不管哪种方式，底层调用的都是StreamSupport中流创建方法stream。 收集器 高级规约。多级分组，指令和函数式就会有很大的区别。 Collectors.counting() Collectors.maxBy() Collectors.minBy() Collectors.summingInt() Collectors.summingDouble() COllectors.summingLong() Collectors.averagingInt() Collectors.summarizingInt()：得到最大最小值，并且封装到IntSummaryStatistics对象中 Collectors.joining()：将流中每一个对应应用toString得到的字符串连接起来，可定义分隔符 Collectors.reducing()： COllectors.groupingBy()： 用来获取分组，返回Map，其中key是groupingBy的参数类型，value是List Collectors.collectingAndThen()：将收集器收集到的结果转化为另外的另外的类型 Collectors.mappting(): Collections.partitioningBy() Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-13 22:46:12 "},"Java 8新特性/行为参数化——lambda表达式.html":{"url":"Java 8新特性/行为参数化——lambda表达式.html","title":"行为参数化——lambda表达式","keywords":"","body":"lambda表达式 什么是lambda表达式 lambda就是将一块代码赋值给一个“值”。 Java8之前，将下面的代码赋值个一个变量“aBlockOfCode”是不可能的事情： public void doSomething(String s){ System.out.println(s); } 而在Java8中可以做到： aBlockOfCode = (s) - > System.out.println(s); 这就是lambda表达式。 会有这样一个问题，变量aBlockOfCode的类型是什么？ Lambda的类型都是一个接口，而lambda表达式本身，就是那段代码，需要是这个接口实现的。 什么意思呢？就是说我们可以给aBlockOfCode加上这个这样一个类型： @FactionalInterface interface MyLambdaInterface{ void doSomething(String s); } 然后aBlockOfCode的正确写法应该是： MyLambdaInterface aBlockOfCode = (s) - > System.out.println(s); 其中MyLambdaInterface只有一个接口，叫做函数式接口。 lambda表达式有什么作用呢？ 最直观的感受是直观简洁。因为上一段代码如果在Java7中，那么它将写成这样 另外，Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！ 假设Person的定义和List的值都给定。 定义\"> 现在需要你打印出guiltyPersons List里面所有LastName以\"Z\"开头的人的FirstName。 用原生的lambda表达式可能需要定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。 还可以更加简单，因为java.util.function这个包中已经定义了大量可能用到的函数式接口，他们这一对的接口定义是这样的： 所以我们根本不需要自己定义两个函数式接口。做以下步骤的简化： 利用函数式接口简化包： public static void CheckAndExecute(List personList, Predicate perdicate, Consumer consumer){ for(Person p : personList){ if(predicate.test(p)) { consumer.accept(p); } } } 然后我们调用的时候这样： CheckAndExecute(guiltyPersons, p -> p.getLastName().startWith(\"Z\"), P -> System.out.println(p.getFirstName())); 下一个步骤是在CheckAndExecute中，有点繁琐，我们可以用forEach循环代替for循环，因为forEach循环可以接受一个Consumer类型的变量： public static void CheckAndExecute(List personList, Predicate perdicate, Consumer consumer){ personList.forEach(p -> { if(predicate.test(p)) consumer.accept(p); }) } //引用 CheckAndExecute(guiltyPersons, p -> p.getLastName().startWith(\"Z\"), P -> System.out.println(p.getFirstName())); 下一步，由于静态函数其实设置对list进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都接受Predicate、Consumer等参数（参考java.util.Stream）包： personList.stream() .filter(p -> p.getLastName().startWith(\"z\")) .foreach(p->System.out.println(p.getFirstName())); 至此已经非常简练了，但是我们改变一下需求，这里要求打印全部信息，那么可以用Method reference来简化。Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression，格式如下： 所以上面的代码可以变成这样： personList.stream() .filter(p -> p.getLastName().startWith(\"Z\")) .forEach(System.out::println) 这基本上就是能写的最简洁的版本了。 另外，lambda还可以配合Optional可以使Java对于null的处理变的异常优雅. 这里假设我们有一个person object，以及一个person object的Optional wrapper: Person person = foAndGetAFunckingPerson(); Optional personOpt = Optional.ofNull(person); 如果不是用Optional，将写成下面这种也别繁琐的写法 \"> lambda + Optional的其他对于null值的检查如下： Lambda的基本语法 Lambda的基本语法如下： (params) -> expression 或 (params) -> { statements; } 注意“表达式(expression)”和“语句(statements)”的区别 函数式接口：只定义一个抽象方法的接口，注意，这里是指只含有一个本身特有的抽象方法，不包含从父接口继承得到的。 方法引用 方法引用就是用已经实现的方法实现来创建lambda表达式，其本质上还是lambda表达式， 只是一种lambda的快捷写法。 注意，这里的方法是“引用”，而不是“调用”，所以只用说明而已。比如Apple::getWeight就是在“引用”Apple中的getWeight方法，但并不是在调用，所以不用加括号。它实际是(Apple a) -> a.getWeight()的简略写法。 有三种方法可以作为方法引用： 指向静态方法的方法引用。如Integer的parseInt可以写成Integer::parseInt 指向任意类型实例方法的方法引用。如String::length() 指向现有对象的实例方法。如有一个对象transaction，它是Transaction类型的对象，支持实例方法getValue，那么就可以写成transaction::getValue 特别的，对于构造函数，可以使用ClassName::new，假如一个构造函数没有参数，那么它适合做Supplier签名() -> Apple： Supplier c1 = Apple::new; // 相当于Supplier c1 = () -> new Apple() Apple a = c1.get(); 如果构造函数有参数，那么函数签名就适合于Function： Function c2 = Apple::new; // 相当于Function c2 = (weight) -> new Apple(weight) Apple a = c2.apply(100); 如果有两个参数，那么函数签名就适合于BiFunction： BiFunction c3 = Apple::new; Apple a3 = c3.apple(110, \"red\"); 注意到，不将构造函数实例化却能够引用它，这个特性我们可以引用于“工厂方法”模式中： public interface Builder { void add(WeaponType name, Supplier supplier); } public interface WeaponFactory { /** * Creates an instance of the given type. * @param name representing enum of an object type to be created. * @return new instance of a requested class implementing {@link Weapon} interface. */ Weapon create(WeaponType name); /** * Creates factory - placeholder for specified {@link Builder}s. * @param consumer for the new builder to the factory. * @return factory with specified {@link Builder}s */ static WeaponFactory factory(Consumer consumer) { Map> map = new HashMap<>(); consumer.accept(map::put); return name -> map.get(name).get(); } } public class App{ public static void main(String[] args) { WeaponFactory factory = WeaponFactory.factory(builder -> { builder.add(WeaponType.SWORD, Sword::new); builder.add(WeaponType.AXE, Axe::new); builder.add(WeaponType.SPEAR, Spear::new); builder.add(WeaponType.BOW, Bow::new); }); Weapon axe = factory.create(WeaponType.AXE); LOGGER.info(axe.toString()); } } 函数式接口 Java8中提供了很多内置的函数式接口，例如 断言型接口Predicate 函数型接口Function 消费型接口Consumer 供应型接口Supplier 比较型接口Comparator 流接口Stream： 其中包含了很多子函数是接口 参考 lambda表达式有何用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-09 15:21:48 "},"Java 8新特性/接口中可以定义非抽象方法了.html":{"url":"Java 8新特性/接口中可以定义非抽象方法了.html","title":"接口中可以定义非抽象方法了","keywords":"","body":"接口中可以定义非抽象方法了 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-22 14:36:36 "},"Java 8新特性/@FunctionalInterface注解.html":{"url":"Java 8新特性/@FunctionalInterface注解.html","title":"@FunctionalInterface注解","keywords":"","body":"@FunctionalInterface注解 标注为FunctionalInterface的接口被称为函数式接口，该接口中只能有一个自定义的方法。如果一个接口只有一个方法，则编译器会认为这是这是一个函数式接口。例如： public interface FunctionalInterface{ void f1(); } 上面这样写没有错，如果在接口上面加入@FunctionalInterface注解，那么该接口就会被强制要求符合函数式接口的规范，比如写成这样： @FunctionalInterface public interface FunctionalInterface{ void f1(); } 也可以添加Object类中的方法： @FunctionalInterface public interface FunctionInterface { void f1(); String toString(); } 这里有一点需要说明，之前在整理《类、抽象类、内部类、接口》一文的时候说道，接口并没有继承Object类，但是实现了和Object中一样的方法集合。所以这里的toString严格来说并不是继承自Object类，而是接口本身实现的一套机制。这并不属于“自定义”方法的范畴，所以可以被添加到上例中。但是如果是自定义的方法，就不可以了，比如： @FunctionInterface public interface FunctionInterface{ void f1(); void f1(); } 会产生Invalid '@FunctionalInterface' annotation; FunctionalInterfaceTest is not a functional interface错误。 在JDK 8中，可以看到有一些类已经应用了这个注解，比如Runnable： @FunctionalInterface public interface Runnable { /** * When an object implementing interface Runnable is used * to create a thread, starting the thread causes the object's * run method to be called in that separately executing * thread. * * The general contract of the method run is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 函数式接口是可以使用lambda表达式的，关于lambda表达式可以参见下一篇博文。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:39:28 "},"Java 8新特性/Effectively final.html":{"url":"Java 8新特性/Effectively final.html","title":"Effectively final","keywords":"","body":"Effectively final Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-24 09:29:52 "},"Java 8新特性/Predicate.html":{"url":"Java 8新特性/Predicate.html","title":"Predicate","keywords":"","body":"Predicate Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-14 20:54:05 "},"Java 8新特性/HashMap改进.html":{"url":"Java 8新特性/HashMap改进.html","title":"HashMap改进","keywords":"","body":"HashMap改进 HashMapJDK1.8的实现具体参考源码，相比于1.8之前的版本，有了以下方面的改进： 存储结构 HashMap在1.8中使用的是”数组+链表+红黑树“的存储结构，而1.8之前只是“数组+链表”。链表存在的目的是使用链地址法解决哈希冲突。而红给树的存在的目的是为了在发生严重哈希冲突（链表的长度大于8）的时候，将链表转为红黑树，利用红黑树的特性减少查找的难度。 扩容机制 扩容（resize）就是重新计算容量，向hashmap中不断添加元素，而当hashmap中无法装载更多到的元素的时，对象就需要扩大数组的长度，以便能装入更多的元素。Java是的数组是无法自动扩容的， 方法就是使用一个新的大数组替换已有容量小的数组。 在1.7中，resize()方法定义如下： void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } 其中transfer方法是将原来Entry数组中的元素重新拷贝到新的扩容后的数组中。 注意到，Entry next = e.next;这句话，newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的\b哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 以上是1.7下hashmap的扩容机制，1.8中对此方法做了改进。 首先观察一下hashmap的特点，hashmap中约定容量的大小是2的倍数，而扩容的策略是2倍，即也是2次幂的扩展。那么，元素的位置要么在原来的位置上，要么在原来的位置上再移动2次幂的位置，看下图的解释： 图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个算法非常巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置 1 final Node[] resize() { 2 Node[] oldTab = table; 3 int oldCap = (oldTab == null) ? 0 : oldTab.length; 4 int oldThr = threshold; 5 int newCap, newThr = 0; 6 if (oldCap > 0) { 7 // 超过最大值就不再扩充了，就只好随你碰撞去吧 8 if (oldCap >= MAXIMUM_CAPACITY) { 9 threshold = Integer.MAX_VALUE; 10 return oldTab; 11 } 12 // 没超过最大值，就扩充为原来的2倍 13 else if ((newCap = oldCap = DEFAULT_INITIAL_CAPACITY) 15 newThr = oldThr 0) // initial capacity was placed in threshold 18 newCap = oldThr; 19 else { // zero initial threshold signifies using defaults 20 newCap = DEFAULT_INITIAL_CAPACITY; 21 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); 22 } 23 // 计算新的resize上限 24 if (newThr == 0) { 25 26 float ft = (float)newCap * loadFactor; 27 newThr = (newCap [] newTab = (Node[])new Node[newCap]; 33 table = newTab; 34 if (oldTab != null) { 35 // 把每个bucket都移动到新的buckets中 36 for (int j = 0; j e; 38 if ((e = oldTab[j]) != null) { 39 oldTab[j] = null; 40 if (e.next == null) 41 newTab[e.hash & (newCap - 1)] = e; 42 else if (e instanceof TreeNode) 43 ((TreeNode)e).split(this, newTab, j, oldCap); 44 else { // 链表优化重hash的代码块 45 Node loHead = null, loTail = null; 46 Node hiHead = null, hiTail = null; 47 Node next; 48 do { 49 next = e.next; 50 // 原索引 51 if ((e.hash & oldCap) == 0) { 52 if (loTail == null) 53 loHead = e; 54 else 55 loTail.next = e; 56 loTail = e; 57 } 58 // 原索引+oldCap 59 else { 60 if (hiTail == null) 61 hiHead = e; 62 else 63 hiTail.next = e; 64 hiTail = e; 65 } 66 } while ((e = next) != null); 67 // 原索引放到bucket里 68 if (loTail != null) { 69 loTail.next = null; 70 newTab[j] = loHead; 71 } 72 // 原索引+oldCap放到bucket里 73 if (hiTail != null) { 74 hiTail.next = null; 75 newTab[j + oldCap] = hiHead; 76 } 77 } 78 } 79 } 80 } 81 return newTab; 82 } 小结 1.8和之前版本的HashMap性能比较具体可以参考http://www.importnew.com/20386.html ， 因为HashMap是我们经常用到的类，所以有一些小tips可以帮助我们提升代码的效率。 预估计HashMap的大小。因为扩容是一个非常耗费性能的操作，所以当我们使用HashMap的时候，需要预先估计map的大小，初始化的时候就给一个大致的数值，避免map进行频繁的库容。 HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 JDK1.8中引入了红黑树大程度优化了HashMap的性能。 参考 Java8系列之重新认识HashMap Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-10 10:34:04 "},"Java 8新特性/方法构造和函数引用.html":{"url":"Java 8新特性/方法构造和函数引用.html","title":"方法构造和函数引用","keywords":"","body":"方法构造和函数引用 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:28:44 "},"Java 8新特性/map操作.html":{"url":"Java 8新特性/map操作.html","title":"map操作","keywords":"","body":"map操作 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:28:44 "},"常用工具/FastJson.html":{"url":"常用工具/FastJson.html","title":"FastJson","keywords":"","body":"FastJson 概览 Java最快的JSON处理工具，工程首选。 Maven依赖： com.alibaba fastjson 1.2.12 工具入口为com.alibaba.fastjson.JSON。 常用的方法有： 常用方法 说明 public static final Object parse(String text); 把JSON文本parse为JSONObject或者JSONArray public static final JSONObject parseObject(String text); 把JSON文本parse成JSONObject public static final T parseObject(String text, Class clazz); 把JSON文本parse为JavaBean public static final JSONArray parseArray(String text); 把JSON文本parse成JSONArray public static final List parseArray(String text, Class clazz); 把JSON文本parse成JavaBean集合 public static final String toJSONString(Object object); 将JavaBean序列化为JSON文本 public static final String toJSONString(Object object, boolean prettyFormat); 将JavaBean序列化为带格式的JSON文本 public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray 在实际序列化和反序列化的时候，我们需要对字段进行各种个性化操作，下面是fastjson的个性化操作。 序列化：String jsonString = JSON.toJSONString(obj); 反序列化VO vo = JSON.parseObject(\"...\", VO.class); 泛型反序列化import com.alibaba.fastjson.TypeReference; List list = JSON.parseObject(\"...\", new TypeReference>() {}); 定制序列化 @JSONField定制序列化 注解源码如下： package com.alibaba.fastjson.annotation; public @interface JSONField { // 配置序列化和反序列化的顺序，1.1.12版本之后才支持。默认情况下，序列化的时候是根据fieldName字母顺序进行序列化的。通过ordinal可以指定序列化顺序 int ordinal() default 0; // 指定字段的名称, 配置在字段或setter/getter方法上，注意，如果字段是private，必须得有setter，否则无法反序列化 String name() default \"\"; // 指定字段的格式，对日期格式有用 String format() default \"\"; // 是否序列化 boolean serialize() default true; // 是否反序列化 boolean deserialize() default true; SerializerFeature[] serialzeFeatures() default {}; Feature[] parseFeatures() default {}; String label() default \"\"; //1.2.16版本之后，制定属性的序列化类，对单独的某个属性定制序列化数据 Class serializeUsing() default Void.class; //1.2.16版本之后，执行属性的反序列化， Class deserializeUsing() default Void.class; } 用法如下： 其中name、format、serialize、deserialize的用法比较简单，具体可以参考 这里 的例子。 serializeUsing可以用来针对某个属性来定制序列化的格式，例如： public class User implements { @JSONField(name = \"ID\", ordinal = 3) private long id; @JSONField(ordinal = 2) private String name; @JSONField(serializeUsing = ModelValueSerializer.class) private short age; @JSONField(format = \"yyyy-MM-dd\", ordinal = 1) private Date birthday; public User() { } public User(long id, String name, short age, Date birthday) { this.id = id; this.name = name; this.age = age; this.birthday = birthday; } // omit setter and getter } 其中ModelValueSerializer类定义为： public class ModelValueSerializer implements ObjectSerializer { @Override public void write(JSONSerializer jsonSerializer, Object o, Object o1, Type type, int i) throws IOException { short age = (short)o; String text = age + \"岁\"; jsonSerializer.write(text); } } 测试程序为： public class UserTest { @Test public void jsonFeathure(){ User user = new User(1, \"Austin\", (short) 18, new Date()); String userStr = JSON.toJSONString(user); Assert.assertEquals(\"{\\\"age\\\":\\\"18岁\\\",\\\"birthday\\\":\\\"2018-01-25\\\",\\\"name\\\":\\\"Austin\\\",\\\"ID\\\":1}\", userStr); } } 1.2.21版本之后，使用alternateNames支持反序列化时使用不同的字段名称。详见 https://www.w3cschool.cn/fastjson/fastjson-jsonfield.html 1.2.21版本之后，新增jsonDirect属性，但是这个属性的作用我没有看懂？？？ @JSONType配置 定义的位置在类上，源码如下： @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) public @interface JSONType { boolean asm() default true; String[] orders() default {}; String[] includes() default {}; String[] ignores() default {}; SerializerFeature[] serialzeFeatures() default {}; Feature[] parseFeatures() default {}; boolean alphabetic() default true; Class mappingTo() default Void.class; Class builder() default Void.class; String typeName() default \"\"; Class[] seeAlso() default {}; Class serializer() default Void.class; Class deserializer() default Void.class; } @JSONType的配置会覆盖@JSONField SerializeFilter定制序列化 有时候我们会在不同的情况下制定不同的序列化策略，这时候用@JSONType或@JSONField可能都不能满足我们的需求，这时候SerializeFilter是最好的选择。它使用扩展编程的方式实现定制序列化，fastjson提供了多种serializer： PropertyPreFilter 根据PropertyName判断是否序列化 我们一般使用SimplePropertyPreFilter类进行设置，例如： @Test public void serializeFilter(){ User2 user = new User2(\"Austin\", (short)18); SimplePropertyPreFilter filter1 = new SimplePropertyPreFilter(User.class, \"name\"); String res = JSON.toJSONString(user, filter1); Assert.assertEquals(\"{\\\"name\\\":\\\"Austin\\\"}\", res); SimplePropertyPreFilter filter2 = new SimplePropertyPreFilter(); filter1.getExcludes().add(\"age\"); res = JSON.toJSONString(user, filter1); Assert.assertEquals(\"{\\\"name\\\":\\\"Austin\\\"}\", res); } PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化 需要自己实现序列化策略，例如： @Test public void propertyFilterTest(){ User2 user = new User2(\"Austin\", (short)18); List list = new ArrayList<>(); for (int i = 1; i 程序执行结果跟我预料中的有点不同，我还以为它会过滤掉年龄不符合规范的整个对象，但是实际上，当年龄不符合的时，还是留下了该对象的其他字段。有什么办法可以实现我想要的效果？ 另外对于嵌套属性的过滤，可以参考http://blog.csdn.net/u010523770/article/details/51525001 这篇博文的内容。 NameFilter 修改Key，如果需要修改Key, process返回值则可， 内置了实现类PascalNameFilter，这个类的作用是将属性名首字母从小写转为大小，自己可以自定义。比如下面自定义的NameFilter实现属性名全部大写的效果：@Test public void nameFilterTest(){ User2 user = new User2(\"Austin\", (short)18); NameFilter filter = new NameFilter() { @Override public String process(Object source, String name, Object value) { if (name != null && name.length() != 0){ return name.toUpperCase(); } return name; } }; String res = JSON.toJSONString(user, filter); System.out.println(res); } ValueFilter 修改Value, 没有内置实现类，需要自己实现。如下面的程序会将name字段的值全部变成大写：@Test public void valueFilterTest(){ User2 user = new User2(\"Austin\", (short)18); ValueFilter filter = new ValueFilter() { @Override public Object process(Object o, String s, Object value) { if (s != null && s.length() != 0){ if (\"name\".equalsIgnoreCase(s) && value != null){ String v = (String)value; return v.toUpperCase(); }else { return value; } } return value; } }; String res = JSON.toJSONString(user, filter); System.out.println(res); } BeforeFilter 序列化时在最前添加内容public abstract class BeforeFilter implements SerializeFilter { protected final void writeKeyValue(String key, Object value) { ... } // 需要实现的抽象方法，在实现中调用writeKeyValue添加内容 public abstract void writeBefore(Object object); } AfterFilter 序列化时在最后添加内容public abstract class AfterFilter implements SerializeFilter { protected final void writeKeyValue(String key, Object value) { ... } // 需要实现的抽象方法，在实现中调用writeKeyValue添加内容 public abstract void writeAfter(Object object); } 定制反序列化 ParseProcess是编程扩展定制反序列化的接口，内置了两个接口——ExtraProcessor和ExtraTypeProvider，前者用来处理多余字段，后者用于处理多余字段时提供类型信息 ExtraProcessor 该接口用来处理多余字段，如下： @Getter @Setter public class VO implements Serializable{ private int id; private Map attributes = new HashMap(); public int getId() { return id; } public void setId(int id) { this.id = id;} public Map getAttributes() { return attributes;} } //测试程序 @Test public void extraProcessorTest(){ ExtraProcessor processor = new ExtraProcessor() { @Override public void processExtra(Object object, String key, Object value) { VO vo = (VO)object; vo.getAttributes().put(key, value); } }; VO vo = JSON.parseObject(\"{\\\"id\\\":123,\\\"name\\\":\\\"abc\\\"}\", VO.class, processor); Assert.assertEquals(123, vo.getId()); Assert.assertEquals(\"abc\", vo.getAttributes().get(\"name\")); } 上例中，id属性能在VO中找到对应的属性，但是name属性找不到，所以这里processor起了作用，它会将这个属性放到对象的attributes中。 ExtraTypeProvider 该接口用来处理多余字段的类型信息。这个接口实现需要配合ExtraProcessor。如下： //`ExtraProcessor`和`ExtraTypeProvider`配合使用 public class MyExtraProcessor implements ExtraProcessor, ExtraTypeProvider { @Override public void processExtra(Object object, String key, Object value) { VO vo = (VO) object; vo.getAttributes().put(key, value); } @Override public Type getExtraType(Object o, String key) { if (\"value\".equals(key)){ return int.class; } return null; } } //测试程序 @Test public void extraTypeProvider(){ ExtraProcessor processor = new MyExtraProcessor(); VO vo = JSON.parseObject(\"{\\\"id\\\":123,\\\"value\\\":\\\"123456\\\"}\", VO.class, processor); Assert.assertEquals(123, vo.getId()); Assert.assertEquals(123456, vo.getAttributes().get(\"value\")); // value本应该是字符串类型的，通过getExtraType的处理变成Integer类型了。 } 在实践过程中遇到这样一个问题：有一个布尔量，并未对其设置serialize=false属性，但是序列化的时候无法序列化该属性。后来经过JavaBean的boolean isXXX反序列化问题这篇文章的提醒，发现我的布尔量的命名是isXXX，无论是利用@Getter和@Setter注解省略getter和setter方法，还是idea生成getter和setter方法，其getter/setter为isXXX/setXXX，而Boolean的getter/setter为getXXX/setXXX。 对于boolean量，将其写成isXXX实际上是不规范的，此时IDE默认的getter/setter并不会被fastjson识别，反序列化过程错误。解决办法就是手动将isXXX/setXXX改成isIsXXX/setIsXXX. 参考 源码地址 学习教程 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-03-06 18:00:29 "},"错题集/错题集1.html":{"url":"错题集/错题集1.html","title":"错题集1","keywords":"","body":"错题集1 下面几个关于Java里queue的说法哪些是正确的？（） A. LinkedBlockingQueue开始一个可选有界队列，不允许null值。 B. PriorityQueue, LinkedBlockingQueue都是线程不安全的 C. PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是(log(n)) D. PriorityQueue，ConcurrentLinkedQueue都遵循FIFO原则。 答案：AB 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4016527 解析: 以下来自Java 8翻译： LinkedBlockingQueue：基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）。 队列的头部是队列中最长的元素。 队列的尾部是队列中最短时间的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中的可预测性能较低。 blocking queue：不接受null元素；可能是容量有限的；实现被设计为主要用于生产者 - 消费者队列；不支持任何类型的“关闭”或“关闭”操作，表示不再添加项目实现是线程安全的； PriorityQueue 2.1、基于优先级堆的无限优先级queue 。 优先级队列的元素根据它们的有序natural ordering ，或由一个Comparator在队列构造的时候提供，这取决于所使用的构造方法。 优先队列不允许null元素。 依靠自然排序的优先级队列也不允许插入不可比较的对象（这样做可能导致ClassCastException ）。 2.2、该队列的头部是相对于指定顺序的最小元素。 如果多个元素被绑定到最小值，那么头就是这些元素之一 - 关系被任意破坏。 队列检索操作poll ， remove ， peek和element访问在队列的头部的元件。 2.3、优先级队列是无限制的，但是具有管理用于在队列上存储元素的数组的大小的内部容量 。 它始终至少与队列大小一样大。 当元素被添加到优先级队列中时，其容量会自动增长。 没有规定增长政策的细节。 2.4、该类及其迭代器实现Collection和Iterator接口的所有可选方法。 方法iterator()中提供的迭代器不能保证以任何特定顺序遍历优先级队列的元素。 如果需要有序遍历，请考虑使用Arrays.sort(pq.toArray()) 。 2.5、请注意，此实现不同步。 如果任何线程修改队列，多线程不应同时访问PriorityQueue实例。 而是使用线程安全的PriorityBlockingQueue类。 实现注意事项：此实现提供了O（log（n））的时间入队和出队方法（ offer ， poll ， remove()和add ）; remove(Object)和contains(Object)方法的线性时间; 和恒定时间检索方法（ peek ， element和size ）。 ConcurrentLinkedQueue：基于链接节点的无界并发deque(deque是双端队列) 。 并发插入，删除和访问操作可以跨多个线程安全执行。 A ConcurrentLinkedDeque是许多线程将共享对公共集合的访问的适当选择。像大多数其他并发集合实现一样，此类不允许使用null元素。 设int x = 1; float y = 2;，则表达式x/y的值是：（） A. 0 B. 1 C. 2 D. 以上都不是 答案：D 题目来源：https://www.nowcoder.com/questionTerminal/0e96a198c7cc4d06a00ababae1bbbb0b 解析：根据基本类型的转换规则，当算术运算中，两个操作数中都不是double类型但是其中一个是float的时候，另一个操作数也会转为float类型，计算结果也是float类型。所以 x / y = (float)1.0 / (float) 2.0 = 0.5(float类型的)。 关于static说法不正确的是（） A. 可以直接用类名来访问类中的静态方法（public权限） B. 静态块仅在类加载时执行一次。 C. static方法就是没有this的方法 D. 不可以用对象名来访问类中的静态方法（public权限） 答案 : D 题目来源： https://www.nowcoder.com/profile/848042/myFollowings/detail/4016488 解析 ：栽在C项了，this就是当前调用对象，而静态是属于了类的，无法确定调用者，所以static里面就没有this的调用了。【看被人的回答有人得到C项的逆否命题：有this的就不是static方法，厉害了，666】。 D项实际上是可以用对象名来访问类中的静态方法的，只是那样就没有有意义而已，并且会抛出警告。 下列关于管道（Pipe）通信的叙述中，正确的是（） A. 进程对管道进行读操作和写操作都可能被组设 B. 一个管道只能有一个进行或一个写进程对其操作 C. 一个管道可实现双向数据传输 D. 管道的容量仅受磁盘容量大小限制 答案： A 题目来源: https://www.nowcoder.com/profile/848042/myFollowings/detail/4016483 题目解析 ： 还没有学到“管道通信”这个概念，这题目的解析先放下来吧。不懂得看链接。 Java8 中，忽略内部接口情况，不能用来修饰interface里的方法的有（） A. private B. public C. protected D. static 答案： AC 题目来源： https://www.nowcoder.com/profile/848042/myFollowings/detail/4016346 解析： Java8 的接口方法可以有如下定义： only public, abstract, default, static and strictfp are permitted。 注意Java8开始支持接口中定义静态方法了。 public interface InterfaceTest { public void fun1 (); abstract void fun2(); static void fun3(){ System.out.println(\"java 8 新特性\"); } default void fun4(){ System.out.println(\"java 8 新特性\"); } } 接口的默认修饰符是(default) static可以省略，还可以用public来修饰；接口中的数据域必须是常量，修饰符只能是public static final，可以省略。接口中的方法的修饰符默认是public abstract，可以省略，还可以用default、static 来修饰（JDK1.8特性）。 另外注意题目问的是修饰接口中方法的修饰符，不是问修饰接口。那么修饰接口的修饰符可以有哪些？ 只能是public、abstract和什么都不写。abstract是默认的。那么为什么protected不能修饰接口呢？根据作者的意思《Java编程思想》，interface是一种极度抽象的类，如果用protected去修饰它，其作用范围仅仅是当前包内，和继承该类的包外对象，仔细一想，这个public没有什么区别，所以没有必要用protected。 static关键词不能用来修饰接口和主类（外部类），但是可以修饰外部类。 整理下 修饰符、 接口 、 抽象类的有关知识吧 下面关于程序编译说法正确的是（） A. Java语言是编译型语言，会把Java程序翻译成二进制指令直接运行 B. Java编译出来的目标文件与具体操作系统有关 C. Java是解释型语言，在运行时才进行翻译指令 D. Java编译出来的目标文件，可以运行在任意JVM上。 答案 : D 题目来源: https://www.nowcoder.com/questionTerminal/dba570e6fed34c24a49fd827e9869e49 解析： 这道题的答案有问题吧。我觉得是C。Java是解释型语言这没错。D项是错的，高版本的JVM编译出来的目标文件无法在低版本的JVM上运行。 指出下列程序运行的结果： public class Example{ String str=new String(\"tarena\"); char[]ch={'a','b','c'}; public static void main(String args[]){ Example ex=new Example(); ex.change(ex.str,ex.ch); System.out.print(ex.str+\" and \"); System.out.print(ex.ch); } public void change(String str,char ch[]){ //引用类型变量，传递的是地址，属于引用传递。 str=\"test ok\"; ch[0]='g'; } } A. tarena and abc B. tarena and gbc C. test ok and abc D. test ok and gbc 答案 ： B 题目来源 ： https://www.nowcoder.com/profile/848042/myFollowings/detail/4016332 解析: 哎，为什么这种题目遇到好多次了还是转不过弯来。首先明确一个概念啊，Java中只有值传递，没有引用传递。String 和 char 数组都是引用类型，传递的是地址，这样会影响原来变量的值，这跟引用传递很像，但是像归像，值传递和引用传递不是一个概念。另外，String是一个特殊的引用，为什么，因为字符串不可改变。所以题目中函数中的str变量和原来的str已经不是同一个东西了，它是一个局部引用，随着函数结束就没有了。方法中ch虽然也是一个副本，但是方法利用它修改了它所指向的字符数组中的第一个元素。方法结束后，所有的副本弹出结束。但是我们的成员变量str和ch还存在，他们依然是之前的地址，所以str的内容不会变，而ch的第一个元素被改变。 一定要记住Java中只有值传递，所有的参数只是一个副本！副本！副本！ 常用的servlet包的名称是（） A. java.servlet B. javax.servlet C. servlet.http D. javax.servlet.http 答案： BD 题目来源： https://www.nowcoder.com/profile/848042/myFollowings/detail/4016277 解析 ： 使用 Java 技术开发 WEB 应用程序 , 深入了解 Servlet 的机制对应用的开发将有重要的推动作用 . 而想深入了解 Servlet 的机制就不得不了解 javax.servlet 包 。javax.servlet 包中包含了 7 个接口 ,3 个类和 2 个异常类 , 它们分别是 : 接口 :RequestDispatcher,Servlet,ServletConfig,ServletContext,ServletRequest,ServletResponse 和 SingleThreadModel 类 :GenericServlet,ServletInputStream 和 ServletOutputStream 异常类 :ServletException 和 UnavailableException。 暂时还没有学习到这个包，先记下来吧。 Java用（）机制实现了进程之间的同步执行 A. 监视器 B. 虚拟机 C. 多个CPU D. 异步调用 答案 : A 题目来源：https://www.nowcoder.com/questionTerminal/8312c75bc0b04f5a88511da1cc70972d 解析： 在一个程序当中代码段访问了同一个对象从单独的并发的线程当中，那么这个代码段叫”临界区” 怎么解决呢：使用同步的机制对临界区进行保护 同步的两种方式：同步块和同步方法 对于同步来说都是使用synchronized方法 每一个对象都有一个监视器，或者叫做锁。 如下代码，执行test()函数后，屏幕打印结果为（） public class Test2 { public void add(Byte b) { b = b++; } public void test() { Byte a = 127; Byte b = 127; add(++a); System.out.print(a + \" \"); add(b); System.out.print(b + \"\"); } } A. 127 127 B. 128 127 C. 129 128 D. 以上都不对 答案 ： D 题目来源 ：https://www.nowcoder.com/questionTerminal/1bab09264a1c4528aa60ee9bca5f0976?toCommentId=675739 解析 ： 首先要注意的是Java中值传递的参数传递方式，所以记住调用add方法的时候，形参是实参的一份拷贝而已。OK，首先a是一个Byte型对象的引用，而这个类型的范围是[-128,127]，根据包装类自动装箱的原理，a和b实际上是同一个对象的引用。可以在b的声明后面打印一下System.out.println(a == b)发现打印出true。那么add(++a)这句话执行经历了什么过程呢？ 首先看++a，首先会触发自动拆箱操作Byte.byteValue()方法，得到基本数值类型127，此时再进行+1的操作，根据基本数值类型间的转化规则我们知道，此时基本数据类型byte127会转为int型的127再进行+1操作，得到int型的128，然后再强制转换byte型，可是bye的范围是[-128,127]，所以强制转换的时候会有溢出，变成了byte型的-128，再触发自动装箱操作， 根据Byte自动装箱缓存的原理，此时Byte引用的是-128这个cache对象，不信的话在第一个System之前加入下面两句话： Byte c = -128; System.out.println(a == c); //true 上面的这一个过程在经过反编译之后的字节码中得到验证： 链接：https://www.nowcoder.com/questionTerminal/1bab09264a1c4528aa60ee9bca5f0976?toCommentId=675739 来源：牛客网 // 源代码 public static void main(String[] args) { Byte a = 127; ++a; } // 字节码 public static void main(java.lang.String[]); Code: 0: bipush 127 // 将一个byte型常量值推送至操作数栈栈顶 2: invokestatic #2 // 自动装箱：访问栈顶元素，作为函数实参传入静态方法Byte.valueOf(byte)， // 返回value值为127的Byte对象的地址，并压栈 5: astore_1 // 将栈顶数值赋值给局部变量表中下标为1的引用型局部变量a，栈顶数值出栈。此时a对应的byte值为127。 6: aload_1 // 局部变量表中下标为1的引用型局部变量a进栈 7: invokevirtual #3 // 自动拆箱，访问栈顶元素a，调用实例方法a.byteValue获取a所指Byte // 对象的value值，并压栈 10: iconst_1 // int型常量值1进栈 11: iadd // 依次弹出栈顶两int型数值1(0000 0001)、127(0111 1111) //（byte类型自动转型为int类型）相加，并将结果128(1000 0000)进栈 12: i2b // 栈顶int值128(1000 0000)出栈，强转成byte值-128(1000 0000)，并且结果进栈 13: invokestatic #2 // 自动装箱：访问栈顶元素，作为函数实参传入静态方法Byte.valueOf(byte)， // 返回value值为-128的Byte对象的地址，并压栈 16: astore_1 // 将栈顶数值赋值给局部变量表中下标为1的引用型局部变量a，栈顶数值出栈。此时a对应的byte值为-128。 17: return } 发现打印出的是true。这个时候这个引用作为实参传递给add方法，再次重申，Java中只有值传递，所以调用add方法的时候我们将对象的引用地址传递给了add方法的形参b。在add方法中，同样经历的拆箱、转为int、加1、强制转化、装箱的过程，b = b ++是不会改变b的引用的，因为先进行了赋值再进行了加法。而b = ++b则会改变b的引用的，这时候指向了-127的这个cache对象。add方法结束后这个b也就被销毁了。 所以这道题目打印的结果应该是\"-128, 127\"。 借着这道题，还有一个问题需要继续讨论一下，\"++a\"这种操作之后，是a的引用改变了还会说指向没变，但是指向的内容改变了。当然是指向改变了，下面这个测试程序就能说明问题了： Byte a = 127; Byte b = a; a++; System.out.println(b == a); //false Byte c = -128; System.out.println(a == c); //true 注意了啊， 包装类里面的value值都是final的，不能改变，只能改变引用。 给出以下代码，请给出结果： class Two{ Byte x; } class PassO{ public static void main(String[] args){ PassO p=new PassO(); p.start(); } void start(){ Two t=new Two(); System.out.print(t.x+””); Two t2=fix(t); System.out.print(t.x+” ” +t2.x); } Two fix(Two tt){ tt.x=42; return tt; } } A. null null 42 B. null 42 42 C. 0 0 42 D. 0 42 42 E. An exception is thrown at Runtime F. Compliation 答案：B 题目来源： 解析：考察成员变量的默认值和值传递方法，需要的是类Two中成员变量是包装类Byte，是对象，初始值是null。 下列选项中正确的方法声明的是?() A. protected abstract void f1(); B. public final void f1(){} C. static final void f1(){} D. private void f1(){} 答案 : ABCD 题目来源 ： 解析：注意A项，抽象类中的抽象方法能够被private之外的修饰符修饰(abstract不能与private、static共存)，但是接口中的抽象方法默认且唯一的修饰词是public abstract。B项是不能被重写的方法。C项是静态且不能被重写的方法；D项是私有方法。 A项好像是错的？？？ 记住！ abstract不能与final、private、static关键字共存！ 下列不属于Java语言性特点的是（） A. Java致力于检查程序在编译和运行时的错误 B. Java能运行虚拟机实现跨平台 C. Java自己操纵内存减少了内存出错的可能性 D. Java还实现了真数组，避免了覆盖数据类型的可能 答案 ： D 题目来源 ： 解析: 真数组的定义是：数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了数据覆盖的可能性，和数据类型覆盖并没有关系。注意D项说法，真数组的避免数据覆盖的可能，而不是数据覆盖类型。 Given the following code,Which statement at line 11 constructs an instance of the inner class?() import EnclosingOne.InsideOne class Enclosingone { public class InsideOne {} } public class inertest { public static void main(string[]args) { EnclosingOne eo = new EnclosingOne(); //insert code here } } A. InsideOne ei=eo.new InsideOne(); B. eo.InsideOne ei=eo.new InsideOne(); C. InsideOne ei=EnclosingOne.new InsideOne(); D. EnclosingOne.InsideOne ei=eo.new InsideOne(); 答案：AD 题目来源 ：https://www.nowcoder.com/questionTerminal/282aa74498f649cc81a41cb24ab1353e 解析 ：有了内部类的知识，D项没有问题。关键在于A，仔细看题目，import了内部类，所以A项也是对的。 What will happen when you attempt to compile and run the following code?() public class Test{ static{ int x=5; } static int x,y; public static void main(String args[]){ x--; myMethod( ); System.out.println(x+y+ ++x); } public static void myMethod( ){ y=x++ + ++x; } } A. compiletime error B. prints:1 C. prints:2 D. prints:3 E. prints:7 F. prints:8 答案：D 题目来源： 解析 ：首先是加载顺序，先加载静态域，static代码块在前所以先执行，其中x是一个局部变量，代码块执行完毕后释放。接着初始化静态x和y，默认为0。然后进入main方法，x--执行后x变成-1;进行入myMethod方法，y=x++ + ++x;相当于y=(x++)+(++x)，当++或者--和其它变量进行运算时，x++表示先运算，再自增，++x表示先自增再参与运算。所以就时x为-1参与运算，然后自增，x此时为0，++x后x为1，然后参与运算，那么y=-1+1就为0，此时x为1。注意此时y是静态变量y而不是局部变量。执行并打印x+y + ++x运算方式和第5步相同，最后计算结果就为3。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-05 14:20:13 "},"错题集/错题集2.html":{"url":"错题集/错题集2.html","title":"错题集2","keywords":"","body":"下列说法正确的是（） A. 在类方法中可用this来调用本类的类方法 B. 在类方法中调用本类的类方法时可直接调用 C. 在类方法中只能调用本类中的类方法 D. 在类方法中绝对不能调用实例方法 答案 ： B 题目来源 ： 解析 ： 类方法就是statis修饰的方法啦，类方法不能直接调用本类的实例方法，但是可以通过创建实例来调用实例方法，而this本身就是只当当前实例，当然不能直接出现在类方法中。 哎，“可以通过创建实例来调用实例方法”这一点还是要加深体会，比如下面这段代码： public class TestDemo{ private int count; public static void main(String[] args) { TestDemo test=new TestDemo(88); System.out.println(test.count); } TestDemo(int a) { count=a; } } 完全能够编译且运行通过，因为main是静态方法，通过创建实例来调用本类的非静态属性，完全是OK的，但是如果直接是System.out.println(count)就不行了，count是实例属性（非静态属性），不能直接被静态方法调用。 阅读如下代码。 请问对语句行 test.hello(). 描述正确的有（） package NowCoder; class Test { public static void hello() { System.out.println(\"hello\"); } } public class MyApplication { public static void main(String[] args) { // TODO Auto-generated method stub Test test=null; test.hello(); } } A. 能编译通过，并正确运行 B. 因为使用了未初始化的变量，所以不能编译通过 C. 以错误的方式访问了静态方法 D. 能编译通过，但因变量为null，不能正常运行 答案 ： A 题目来源 ： 解析 ：A就相当于Test.hello()。值得一说的是有些人以为是空指针，这里你们所说的空指针必须是去引用堆对象才会有空指针，而这个hello是static类型的，人家static的方法本身就没有指针，所以当然不会有空指针。 float x 与“零值”比较的if语句为？ A. if (x == 0) B. if (x C. if (fabs(x) D. if (x > -0.00001f) 答案 ： C 题目来源 ： 解析 ： float类型的还有double类型的，这些小数类型在趋近于0的时候直接等于0的可能性很小，一般都是无限趋近于0.因此不能用==来判断。应该用|x-0| 以下代码的输出结果是？ public class B { public static B t1 = new B(); public static B t2 = new B(); { System.out.println(\"构造块\"); } static { System.out.println(\"静态块\"); } public static void main(String[] args) { B t = new B(); } } A. 静态块 构造块 构造块 构造块 B. 构造块 静态块 构造块 构造块 C. 构造块 构造块 静态块 构造块 D. 构造块 构造块 构造块 静态块 答案： C 题目来源 ： 解析 ： 本题注意如下几点： 每调用一次构造方法，则执行一次构造块 静态块只在类加载的时候加载一次 有多个静态变量或块时，按声明顺序加载 开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出''构造块''）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出'构造块'），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出'静态块'），接着执行，main方法，同样也，new了对象，调用构造函数输出（'构造块'） Consider the following code: String s=null; Which code fragments cause an object of type NullPointerException to be thrown? A. if((s!=null)&(s.length()>0)) B. if((s!=null)&&(s.length()>0)) C. if((s==null)|(s.length()==0)) D. if((s==null)||(s.length()==0)) 答案 ： AC 题目来源 ： 解析 ： &和|是位运算，不具有短路功能，&&和||是逻辑运算，具有短路功能。 以下代码将打印出 public static void main (String[] args) { String classFile = \"com.jd.\". replaceAll(\".\", \"/\") + \"MyClass.class\"; System.out.println(classFile); } A. com. jd B. com/jd/MyClass.class C. /////////MyClass.class D. com.jd.MyClass 答案 ： C 题目来源 ： 解析 ： 由于replaceAll方法的第一个参数是一个正则表达式，而\".\"在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成\"/\"。如果想替换的只是\".\"，那么久要写成\"\\.\"。 以下关于final关键字说法错误的是（） A. final是Java中的修饰符， 可以修饰类、接口、抽象类、方法和属性 B. final修饰的类肯定不能被继承 C. final修饰的方法不能被重载 D. final修饰的变量不允许被再次赋值 答案 ： AC 题目来源： 解析 ：final能够修饰类、方法和属性，不能修饰接口和抽象类；被final修饰的类不能被继承；被final修饰的方法不能被重写，记住是重写不是重载；被fianl修饰的属性是一个常量，不能再次赋值。这里需要注意的是，如果这个常量是一个对象的引用，那么“不能再次赋值”的意思是，不能改变引用，但是引用所指向的对象的内容是可以被改变的。 费抽象类实现接口后，必须实现接口中的所有抽象方法，除了abstract类，方法头必须一致（） A. 正确 B. 错误 答案 ：B 题目来源 ：https://www.nowcoder.com/profile/848042/myFollowings/detail/4066199 解析：这道题考察的是继承关系中方法重写的“两同两小一大”原则： 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型 子类抛出异常小于等于父类方法抛出异常 子类访问权限大于等于父类方法访问权限。 与下面等价表示的是那一项？（） public interface IService { String NAME=”default”; } A. public String NAME=”default”; B. public static String NAME=”default”; C. private String NAME=”default”; D. public static final String NAME=”default”; 答案 ： D 题目来源 ：https://www.nowcoder.com/profile/848042/myFollowings/detail/4066193 解析 ： 接口中存在的变量只能是常量，即默认用public static final修饰，所以一答案是D 有如下一段代码，请选择其运行结果（） public class StringDemo{ private static final String MESSAGE=\"taobao\"; public static void main(String [] args) { String a =\"tao\"+\"bao\"; String b=\"tao\"; String c=\"bao\"; System.out.println(a==MESSAGE); System.out.println((b+c)==MESSAGE); } } A. true true B. false false C. true false D. false true 答案 ：C 题目来源 : https://www.nowcoder.com/profile/848042/myFollowings/detail/2938620 解析 : 这题是在考编译器的优化，hotspot中 编译时\"tao\"+\"bao\"将直接变成\"taobao\"，b+c则不会优化，因为不知道在之前的步骤中bc会不会发生改变，而针对b+c则是用语法糖，新建一个StringBuilder来处理。有关编译器对String的优化可以看另一篇博客《String高效编程》 下列说法正确的有（ ） A. 环境变量可在编译source code时指定 B. 在编译程序时，所能指定的环境变量不包括class path C. javac一次可同时编译数个Java源文件 D. javac.exe能指定编译结果要置于哪个目录（directory） 答案 ：ACD 题目来源 : 解析：A选项-d即可设置系统属性。C选项一次编译多个java文件用javac *.java. 即可编译当前目录下的所有java文件。D选项－s指定存放生成的源文件的位置。可以通过javac -help来查看命令。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-30 23:18:02 "},"错题集/错题集3.html":{"url":"错题集/错题集3.html","title":"错题集3","keywords":"","body":"下列程序，Test.main() 函数执行后的输出是（） public class Test{ public static void main(String [] args){ System.out.println(new B().getValue()); } static class A{ protected int value; public A(int v) { setValue(v); } public void setValue(int value){ this.value = value; } public int getValue(){ try{ value++; return value; } catch(Exception e){ System.out.println(e.toString()); } finally { this.setValue(value); System.out.println(value); } return value; } } static class B extends A{ public B() { super(5); setValue(getValue() - 3); } public void setValue(int value){ super.setValue(2 * value); } } } A. 11 17 34 B. 22 74 74 C. 6 7 7 D. 22 34 17 答案： D 题目来源： 解析: 这题太厉害了，弄明白了可以把继承关系和try-catch-finally搞明白。脑子要非常清楚当前执行到哪一步了，当前的value是指什么。准备返回的是什么。 首先new一个B对象。 而B的构造函数中，首先调用了父类A的构造函数，参数是5。A的构造函数调用了setValue函数，注意，B在继承A的时候重写了这个方法，所以这个时候调用的是B重定义的setValue方法，这个重写的方法中调用了父类A的setValue方法，参数是10，在父类A的setValue方法中，成员便令value被赋值为10。到这个时候suprt(5)才真正执行结束。接下来执行setValue(getValue() - 3)语句，其中getValue调用的仍是父类A定义的方法，因为这个方法没有被重写。这个方法中，首先value变成11，然后这个值被保存下来，值是11，准备返回，注意，“保存”下来的意思是保存了一个副本，无论之后value这个值实际上怎么变化，都不会影响这个副本。接着执行finally块中的代码，首先this.setValue(value);this指向的是B的实例，此时setValue是被重写的犯方法，所以执行了super.setValue(22)，将value值变成22，但是这个值并不影响前面保存的副本。所以这里首先打印出\"22\"。接着会执行try-catch-finally块外的return语句么？不会，因为try中已经有了return语句，它最大的耐心就是等待finally块执行结束。所以这里返回的是11。11 - 3 = 8，作为参数传递给setValue方法，执行super.setValue(16)。然后父类A的setValue方法将value值设定为16。 到这个时候new B()才结束。然后再执行getValue方法。 此时value的值是16，加上1变成17，保存副本准备返回。执行finally块中的this.setValue(17);,实际上执行的是super.setValue(34)，执行过后value变成34,打印出来，然后返回之前的副本17，在main中的主函数打印出来。 所以打印的最终结果是 22 34 17。这道题的调试过程可以参考 http://blog.csdn.net/zhumintao/article/details/53818972 阅读以下程序并写出运行结果： public class ExceptionTest { static String a[]={\"123\",\"abc\",null}; public static void main (String args[]) { for (int i = 0; i 答案 ： Result: 123 In 0th loop error : abc In 1th loop error null: In 2th loop 题目来源： 解析 ：看源码，Integer.parseInt()方法只会抛出NumberFormatException，就算参数是null的情况下。 一个Java源程序文件中定义几个类和接口，则编译该文件后生成几个以.class为后缀的字节码文件。 A. 正确 B. 错误 答案 ： A 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4074845 解析 ： 定义多少类（接口），就会生成多少.class文件，内部类除外 如下哪些是Java中有效的关键字（） A. native B. NULL C. false D. this 答案： AD 题目来源： https://www.nowcoder.com/profile/848042/myFollowings/detail/4098351 解析：Java关键字有些常见的坑，首先关键字都是小写的；true、false、null都不是关键字；goto、constants是保留的关键字。 What is the result of compiling and executing the following fragment of code: Boolean flag = false; if (flag = true) { System.out.println(“true”); } else { System.out.println(“false”); } A. The code fails to compile at the “if” statement. B. An exception is thrown at run-time at the “if” statement. C. The text“true” is displayed. D. The text“false”is displayed. E. Nothing is displayed. 答案：C 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4095124 解析：这道题我选择错误答案A，因为我依稀记得Java里面是不允许赋值语句组做判断语句的，而C语言中是可以的。这道题真是刷新了我的世界观。题目中flag是包装类型，首先调用的是自动装箱，值为false。在if判断语句中，在进行赋值的时候会自动拆箱成基本数据类型，因此赋值后flag的值是true。而Java赋值语句是有返回值的，返回值就等于要赋的值，所以返回true。所以if条件语句成立啊，打印出结果了。如果flag不是Boolean类型或者boolean类型，是其他类型，则会提示\"不能转为为布尔值\"，所以“Java中布尔类型与其他类型不能相互转化”才是症结所在，并不是赋值语句不允许作为判断语句。 下列不属于算法结构的是（） A. 输入数据 B. 处理数据 C. 存储数据 D. 输出结果 答案 :C 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4090435 解析：算法包括0个或多个输入，1个或多个输出，中间有穷个处理过程。 以下哪个式子有可能在某个进制下成立（） A. 13 * 14 = 204 B. 12 * 34 = 568 C. 14 * 14 = 140 D. 1 + 1 = 3 答案：A 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4090330 解析：看到这道题的解析的时候真的觉得茅塞顿开，学习还是要灵活啊同学! 设进制为x，然后进行计算，比如A项可以列出一个一元二次方程：(x + 3 )(x + 4) = (2 · x^2 + 4)， 解出的答案需要符合规则，什么规则呢？首先要是正整数，然后式子中出现的数字不能大于等于进制数，比如二进制就不能出现大于1的数字了，所以算下来只有A项了，是八进制。 下面赋值语句中正确的是（） A. double d = 5.3e12 B. float f = 11.1 C. int i = 0.0 D. Double oD = 3 答案 ：A 题目来源 ：https://www.nowcoder.com/profile/848042/myFollowings/detail/4090292 解析：让我不理解的是，为什么D不对。Java不是有一个隐式转化么？记住前提啊，那是基本类型，也就是说，如果写成double d = 1; 这是可以的，会进行隐式转化，但是oD是包装类啊。这编译是不对的。 执行以下程序，最终输出可能是（） public static void main(String[] args) throws Exception{ Thread[] ths = new Thread[3]; for (int i = 0; i A. 010 2123012 3434 B. 01201 340124 2334 C. 0012314 01223344 D. 12345 12345 12345 答案：C 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4037750 解析：多线程运行的时候输出每次都不一样，只能用排除法，怎么才能快速排除呢？找规律啊！每个线程输出0，1，2，3，4，’空格， 输出空格前必有线程输出了0-4，所以选C。学习还是要转弯的。 下面哪些赋值语句是正确的（） A. long test = 012 B. float f = - 412 C. int other = (int)true D. double d = 0x1234567 E. byte b = -128 答案： ABD 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4082900 解析：这道题又是查漏补缺了。A和B中long和float，正常定义需要l和f，但是因为是基本数据类型，会进行转化。但是如果是包装类型的，就必须加上l和f。 以下哪一个不是赋值符号？（） A. += B. C. D. >>>= 答案：C 题目来源：https://www.nowcoder.com/profile/848042/myFollowings/detail/4082893 解析：>为带符号右移，右移后左边的空位被填充为符号位；>>>为不带符号右移，右移后左边的空位被填充为0；没有 下面有关java的instanceof、?、&、&&说法正确的有？（） A. instanceof 可用来判断某个实例变量是否属于某种类的类型。 B. \"?：\" 三目运算符 C. &在逻辑运算中是非短路逻辑与，在位运算中是按位与 D. && 逻辑运算：逻辑 答案：ABD 题目来源： 解析：答案没什么好说的。需要补充一个知识点。&在逻辑运算的时候是非短路逻辑与，位运算中是按位与。 Which statement is true? void waitForSignal() { Object obj = new Object(); synchronized(Thread.currentThread()) { obj.wait(); obj.notify(); } } A. This code may throw an InterruptedException B. This code may throw an IllegalStateException C. This code may throw a TimeOutException after ten minutes D. This code will not compile unless”obj.wait()”is replaced with”(Thread)obj).wait()” E. Reversing the order of obj.wait()and obj.notify()may cause this method to complete normally 答案：A 题目来源：https://www.nowcoder.com/test/question/done?tid=12194889&qid=7689#summary 解析：有两个错误的地方。首先wait方法要用try-catch覆盖，或是掷出InterruptedException才行，因此答案就是因为缺少例外捕捉的 InterruptedException。第二， synchronized的目标与wait()方法的物件不相同，会有IllegalMonitorStateException，不过 InterruptedException会先出现，所以这不是答案。最后正确的代码应该是这样： void waitForSignal() { Object obj = new Object(); synchronized (obj) { try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } obj.notify(); } } mian方法是程序的入口，必须是public 和 static的，顺序可以调换，返回值必须是void。另外还可以用synchronized、final来修饰。 Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-06 15:48:36 "},"错题集/错题集4.html":{"url":"错题集/错题集4.html","title":"错题集4","keywords":"","body":"错题集4 在迭代时候移除List中的元素 首先，看一下在迭代过程中移除List中元素的错误代码： ArrayList list = new ArrayList(Arrays.asList(\"a\". \"b\", \"c\", \"d\")); for (int i = 0; i 本意上是想要删除整个list中的元素，但是这段代码的输出结果为[b, d]。 这是因为这段示例代码中存在一个非常严重的错误。当一个元素被移除时，该list的大小(size)就会缩小，同时也改变游标的指向，所以，在迭代的过程中，将无法从list中正确地删除多个指定元素。 上面的代码是常见的错误一般很容易修改，还有一个错误：你可能认为foreach语句与迭代器(iterator)是非常相似的，但是实际情况并非这样，我们考虑以下代码： ArrayList list = new ArrayList(Arrays.asList(\"a\", \"b\", \"c\", \"d\")); for (String s : list) { if (s.equals(\"a\")) { list.remove(s); } } 这段代码会抛出一个ConcurrentModificationException，next方法必须在remove方法被调用之前，在foreach徐娜混中，编译器使得remove方法优于next方法被调用。这就导致了ConcurrentModificationException异常，正确的写法应该是下面这样： ArrayList list = new ArrayList (Arrays.asList(\"a\", \"b\", \"c\", \"d\")); Iterator iter = list.iterator(); while(iter.hasNext()){ String s = iter.next(); if (s.equals(\"a\")) { iter.remove(); } } Collection中使用原始类型 在Java中，很容易将原始类型与无限通配符类型混淆。比如Set是原始类型，Set是无限通配符类型： public static void add(List list, Object o){ list.add(o); } public static void main(String[] args){ List list = new ArrayList(); add(list, 10); String s = list.get(0); } 这样的示例代码会抛出一个ClassCastException异常。在Collection使用原始类型是具有很多的类型错误风险的，因为原始类型没有静态类型检查。实际上，Set、Set和Set之间具有非常大的差异。 协程、孤儿线程、僵尸线程、守护线程的区别 三个线程依次输出a、b、c，现在要求输出abcabcabc /** * 三个线程，分别能打印出a、b、c， 现在要求打印出abcabcabc */ public class PrintABC { private static final int PRINT_COUNT = 3; /** * 思路1：三个线程分别有自己的锁，和下一个线程的锁。三个线程依次申请和释放响应的锁 * A线程最先持有c和a对象的锁，后释放a锁，唤醒b。B线程等待a锁，再申请b锁，打印之后释放b锁，唤醒C。线程C等待b锁，再申请b锁，打印后释放b锁，唤醒A。 */ static class Task implements Runnable{ private Object prev; private Object self; private String charToPrint; public Task(Object prev, Object self, String charToPrint) { this.prev = prev; this.self = self; this.charToPrint = charToPrint; } @Override public void run() { int printTime = 3; while (printTime >= 1){ synchronized (prev) { synchronized (self){ System.out.print(charToPrint); printTime --; self.notify(); } try { prev.wait();; }catch (InterruptedException e){ System.out.println(e); } } } } } public static void main(String[] args) { Object a = new Object(); Object b = new Object(); Object c = new Object(); new Thread(new Task(c, a, \"a\")).start(); new Thread(new Task(a, b, \"b\")).start(); new Thread(new Task(b, c, \"c\")).start(); } } Copyright © baoxiaofang.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-07-14 15:09:34 "}}